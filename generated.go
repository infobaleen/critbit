// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package critbit

import "unsafe"

// MapIntBool implements an associative array of bool indexed by int.
type MapIntBool struct {
	length int
	root   nodeMapintbool
}

func NewMapIntBool() *MapIntBool {
	var r MapIntBool
	return &r
}

type nodeMapintbool struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbool or bool)
}

// Return walking direction
func (c nodeMapintbool) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbool) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintbool) children() *[2]nodeMapintbool {
	return (*[2]nodeMapintbool)(c.child)
}

func (c *nodeMapintbool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintbool) find(key int) (uint, *nodeMapintbool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntBool) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntBool) SetP(key int, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntBool) Set(key int, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntBool) GetP(key int) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntBool) Get(key int) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntBool) Length() int {
	return t.length
}

// func (c *nodeMapintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterIntBool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntBool struct {
	t     *MapIntBool
	nodes []*nodeMapintbool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int   // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntBool.
func (t *MapIntBool) Iterator() *IterIntBool {
	var i IterIntBool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntBool) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntBool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintbool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntBool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntBool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintbool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintbool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintbool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintbool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntByte implements an associative array of byte indexed by int.
type MapIntByte struct {
	length int
	root   nodeMapintbyte
}

func NewMapIntByte() *MapIntByte {
	var r MapIntByte
	return &r
}

type nodeMapintbyte struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbyte or byte)
}

// Return walking direction
func (c nodeMapintbyte) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbyte) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintbyte) children() *[2]nodeMapintbyte {
	return (*[2]nodeMapintbyte)(c.child)
}

func (c *nodeMapintbyte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintbyte) find(key int) (uint, *nodeMapintbyte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntByte) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntByte) SetP(key int, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntByte) Set(key int, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntByte) GetP(key int) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntByte) Get(key int) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntByte) Length() int {
	return t.length
}

// func (c *nodeMapintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterIntByte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntByte struct {
	t     *MapIntByte
	nodes []*nodeMapintbyte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int   // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntByte.
func (t *MapIntByte) Iterator() *IterIntByte {
	var i IterIntByte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntByte) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntByte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintbyte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntByte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntByte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintbyte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintbyte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintbyte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintbyte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntComplex128 implements an associative array of complex128 indexed by int.
type MapIntComplex128 struct {
	length int
	root   nodeMapintcomplex128
}

func NewMapIntComplex128() *MapIntComplex128 {
	var r MapIntComplex128
	return &r
}

type nodeMapintcomplex128 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapintcomplex128) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex128) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintcomplex128) children() *[2]nodeMapintcomplex128 {
	return (*[2]nodeMapintcomplex128)(c.child)
}

func (c *nodeMapintcomplex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintcomplex128) find(key int) (uint, *nodeMapintcomplex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntComplex128) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntComplex128) SetP(key int, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntComplex128) Set(key int, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntComplex128) GetP(key int) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntComplex128) Get(key int) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex128) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterIntComplex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntComplex128 struct {
	t     *MapIntComplex128
	nodes []*nodeMapintcomplex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int         // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntComplex128.
func (t *MapIntComplex128) Iterator() *IterIntComplex128 {
	var i IterIntComplex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntComplex128) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntComplex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintcomplex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntComplex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntComplex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintcomplex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintcomplex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintcomplex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintcomplex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntComplex64 implements an associative array of complex64 indexed by int.
type MapIntComplex64 struct {
	length int
	root   nodeMapintcomplex64
}

func NewMapIntComplex64() *MapIntComplex64 {
	var r MapIntComplex64
	return &r
}

type nodeMapintcomplex64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapintcomplex64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintcomplex64) children() *[2]nodeMapintcomplex64 {
	return (*[2]nodeMapintcomplex64)(c.child)
}

func (c *nodeMapintcomplex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintcomplex64) find(key int) (uint, *nodeMapintcomplex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntComplex64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntComplex64) SetP(key int, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntComplex64) Set(key int, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntComplex64) GetP(key int) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntComplex64) Get(key int) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex64) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterIntComplex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntComplex64 struct {
	t     *MapIntComplex64
	nodes []*nodeMapintcomplex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int        // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntComplex64.
func (t *MapIntComplex64) Iterator() *IterIntComplex64 {
	var i IterIntComplex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntComplex64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntComplex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintcomplex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntComplex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntComplex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintcomplex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintcomplex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintcomplex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintcomplex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntError implements an associative array of error indexed by int.
type MapIntError struct {
	length int
	root   nodeMapinterror
}

func NewMapIntError() *MapIntError {
	var r MapIntError
	return &r
}

type nodeMapinterror struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapinterror or error)
}

// Return walking direction
func (c nodeMapinterror) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapinterror) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapinterror) children() *[2]nodeMapinterror {
	return (*[2]nodeMapinterror)(c.child)
}

func (c *nodeMapinterror) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapinterror) find(key int) (uint, *nodeMapinterror) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntError) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntError) SetP(key int, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntError) Set(key int, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntError) GetP(key int) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntError) Get(key int) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntError) Length() int {
	return t.length
}

// func (c *nodeMapinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterIntError The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntError struct {
	t     *MapIntError
	nodes []*nodeMapinterror
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int    // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntError.
func (t *MapIntError) Iterator() *IterIntError {
	var i IterIntError
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntError) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntError) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapinterror, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntError) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntError) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapinterror = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapinterror)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapinterror)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapinterror)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntFloat32 implements an associative array of float32 indexed by int.
type MapIntFloat32 struct {
	length int
	root   nodeMapintfloat32
}

func NewMapIntFloat32() *MapIntFloat32 {
	var r MapIntFloat32
	return &r
}

type nodeMapintfloat32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat32 or float32)
}

// Return walking direction
func (c nodeMapintfloat32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintfloat32) children() *[2]nodeMapintfloat32 {
	return (*[2]nodeMapintfloat32)(c.child)
}

func (c *nodeMapintfloat32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintfloat32) find(key int) (uint, *nodeMapintfloat32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntFloat32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntFloat32) SetP(key int, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntFloat32) Set(key int, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntFloat32) GetP(key int) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntFloat32) Get(key int) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat32) Length() int {
	return t.length
}

// func (c *nodeMapintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterIntFloat32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntFloat32 struct {
	t     *MapIntFloat32
	nodes []*nodeMapintfloat32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int      // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntFloat32.
func (t *MapIntFloat32) Iterator() *IterIntFloat32 {
	var i IterIntFloat32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntFloat32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntFloat32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintfloat32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntFloat32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntFloat32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintfloat32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintfloat32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintfloat32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintfloat32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntFloat64 implements an associative array of float64 indexed by int.
type MapIntFloat64 struct {
	length int
	root   nodeMapintfloat64
}

func NewMapIntFloat64() *MapIntFloat64 {
	var r MapIntFloat64
	return &r
}

type nodeMapintfloat64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat64 or float64)
}

// Return walking direction
func (c nodeMapintfloat64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintfloat64) children() *[2]nodeMapintfloat64 {
	return (*[2]nodeMapintfloat64)(c.child)
}

func (c *nodeMapintfloat64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintfloat64) find(key int) (uint, *nodeMapintfloat64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntFloat64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntFloat64) SetP(key int, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntFloat64) Set(key int, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntFloat64) GetP(key int) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntFloat64) Get(key int) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat64) Length() int {
	return t.length
}

// func (c *nodeMapintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterIntFloat64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntFloat64 struct {
	t     *MapIntFloat64
	nodes []*nodeMapintfloat64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int      // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntFloat64.
func (t *MapIntFloat64) Iterator() *IterIntFloat64 {
	var i IterIntFloat64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntFloat64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntFloat64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintfloat64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntFloat64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntFloat64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintfloat64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintfloat64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintfloat64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintfloat64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntInt implements an associative array of int indexed by int.
type MapIntInt struct {
	length int
	root   nodeMapintint
}

func NewMapIntInt() *MapIntInt {
	var r MapIntInt
	return &r
}

type nodeMapintint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint or int)
}

// Return walking direction
func (c nodeMapintint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint) children() *[2]nodeMapintint {
	return (*[2]nodeMapintint)(c.child)
}

func (c *nodeMapintint) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint) find(key int) (uint, *nodeMapintint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt) SetP(key int, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt) Set(key int, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt) GetP(key int) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt) Get(key int) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt) Length() int {
	return t.length
}

// func (c *nodeMapintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterIntInt The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt struct {
	t     *MapIntInt
	nodes []*nodeMapintint
	Found bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int  // Key found by last call to Next, Prev.
	Value *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt.
func (t *MapIntInt) Iterator() *IterIntInt {
	var i IterIntInt
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntInt) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntInt) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntInt) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntInt) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntInt16 implements an associative array of int16 indexed by int.
type MapIntInt16 struct {
	length int
	root   nodeMapintint16
}

func NewMapIntInt16() *MapIntInt16 {
	var r MapIntInt16
	return &r
}

type nodeMapintint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint16 or int16)
}

// Return walking direction
func (c nodeMapintint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint16) children() *[2]nodeMapintint16 {
	return (*[2]nodeMapintint16)(c.child)
}

func (c *nodeMapintint16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint16) find(key int) (uint, *nodeMapintint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt16) SetP(key int, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt16) Set(key int, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt16) GetP(key int) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt16) Get(key int) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt16) Length() int {
	return t.length
}

// func (c *nodeMapintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterIntInt16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt16 struct {
	t     *MapIntInt16
	nodes []*nodeMapintint16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int    // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt16.
func (t *MapIntInt16) Iterator() *IterIntInt16 {
	var i IterIntInt16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntInt16) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntInt16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntInt16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntInt16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntInt32 implements an associative array of int32 indexed by int.
type MapIntInt32 struct {
	length int
	root   nodeMapintint32
}

func NewMapIntInt32() *MapIntInt32 {
	var r MapIntInt32
	return &r
}

type nodeMapintint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint32 or int32)
}

// Return walking direction
func (c nodeMapintint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint32) children() *[2]nodeMapintint32 {
	return (*[2]nodeMapintint32)(c.child)
}

func (c *nodeMapintint32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint32) find(key int) (uint, *nodeMapintint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt32) SetP(key int, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt32) Set(key int, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt32) GetP(key int) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt32) Get(key int) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt32) Length() int {
	return t.length
}

// func (c *nodeMapintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterIntInt32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt32 struct {
	t     *MapIntInt32
	nodes []*nodeMapintint32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int    // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt32.
func (t *MapIntInt32) Iterator() *IterIntInt32 {
	var i IterIntInt32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntInt32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntInt32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntInt32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntInt32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntInt64 implements an associative array of int64 indexed by int.
type MapIntInt64 struct {
	length int
	root   nodeMapintint64
}

func NewMapIntInt64() *MapIntInt64 {
	var r MapIntInt64
	return &r
}

type nodeMapintint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint64 or int64)
}

// Return walking direction
func (c nodeMapintint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint64) children() *[2]nodeMapintint64 {
	return (*[2]nodeMapintint64)(c.child)
}

func (c *nodeMapintint64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint64) find(key int) (uint, *nodeMapintint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt64) SetP(key int, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt64) Set(key int, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt64) GetP(key int) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt64) Get(key int) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt64) Length() int {
	return t.length
}

// func (c *nodeMapintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterIntInt64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt64 struct {
	t     *MapIntInt64
	nodes []*nodeMapintint64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int    // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt64.
func (t *MapIntInt64) Iterator() *IterIntInt64 {
	var i IterIntInt64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntInt64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntInt64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntInt64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntInt64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntInt8 implements an associative array of int8 indexed by int.
type MapIntInt8 struct {
	length int
	root   nodeMapintint8
}

func NewMapIntInt8() *MapIntInt8 {
	var r MapIntInt8
	return &r
}

type nodeMapintint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint8 or int8)
}

// Return walking direction
func (c nodeMapintint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint8) children() *[2]nodeMapintint8 {
	return (*[2]nodeMapintint8)(c.child)
}

func (c *nodeMapintint8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint8) find(key int) (uint, *nodeMapintint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt8) SetP(key int, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt8) Set(key int, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt8) GetP(key int) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt8) Get(key int) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt8) Length() int {
	return t.length
}

// func (c *nodeMapintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterIntInt8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt8 struct {
	t     *MapIntInt8
	nodes []*nodeMapintint8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int   // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt8.
func (t *MapIntInt8) Iterator() *IterIntInt8 {
	var i IterIntInt8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntInt8) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntInt8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntInt8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntInt8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntRune implements an associative array of rune indexed by int.
type MapIntRune struct {
	length int
	root   nodeMapintrune
}

func NewMapIntRune() *MapIntRune {
	var r MapIntRune
	return &r
}

type nodeMapintrune struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintrune or rune)
}

// Return walking direction
func (c nodeMapintrune) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintrune) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintrune) children() *[2]nodeMapintrune {
	return (*[2]nodeMapintrune)(c.child)
}

func (c *nodeMapintrune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintrune) find(key int) (uint, *nodeMapintrune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntRune) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntRune) SetP(key int, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntRune) Set(key int, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntRune) GetP(key int) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntRune) Get(key int) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntRune) Length() int {
	return t.length
}

// func (c *nodeMapintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterIntRune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntRune struct {
	t     *MapIntRune
	nodes []*nodeMapintrune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int   // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntRune.
func (t *MapIntRune) Iterator() *IterIntRune {
	var i IterIntRune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntRune) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntRune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintrune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntRune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntRune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintrune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintrune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintrune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintrune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntString implements an associative array of string indexed by int.
type MapIntString struct {
	length int
	root   nodeMapintstring
}

func NewMapIntString() *MapIntString {
	var r MapIntString
	return &r
}

type nodeMapintstring struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintstring or string)
}

// Return walking direction
func (c nodeMapintstring) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintstring) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintstring) children() *[2]nodeMapintstring {
	return (*[2]nodeMapintstring)(c.child)
}

func (c *nodeMapintstring) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintstring) find(key int) (uint, *nodeMapintstring) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntString) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntString) SetP(key int, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntString) Set(key int, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntString) GetP(key int) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntString) Get(key int) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntString) Length() int {
	return t.length
}

// func (c *nodeMapintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterIntString The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntString struct {
	t     *MapIntString
	nodes []*nodeMapintstring
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int     // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntString.
func (t *MapIntString) Iterator() *IterIntString {
	var i IterIntString
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntString) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntString) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintstring, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntString) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntString) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintstring = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintstring)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintstring)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintstring)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUint implements an associative array of uint indexed by int.
type MapIntUint struct {
	length int
	root   nodeMapintuint
}

func NewMapIntUint() *MapIntUint {
	var r MapIntUint
	return &r
}

type nodeMapintuint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint or uint)
}

// Return walking direction
func (c nodeMapintuint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint) children() *[2]nodeMapintuint {
	return (*[2]nodeMapintuint)(c.child)
}

func (c *nodeMapintuint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint) find(key int) (uint, *nodeMapintuint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint) SetP(key int, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint) Set(key int, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint) GetP(key int) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint) Get(key int) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint) Length() int {
	return t.length
}

// func (c *nodeMapintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterIntUint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint struct {
	t     *MapIntUint
	nodes []*nodeMapintuint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int   // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint.
func (t *MapIntUint) Iterator() *IterIntUint {
	var i IterIntUint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUint) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUint16 implements an associative array of uint16 indexed by int.
type MapIntUint16 struct {
	length int
	root   nodeMapintuint16
}

func NewMapIntUint16() *MapIntUint16 {
	var r MapIntUint16
	return &r
}

type nodeMapintuint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint16 or uint16)
}

// Return walking direction
func (c nodeMapintuint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint16) children() *[2]nodeMapintuint16 {
	return (*[2]nodeMapintuint16)(c.child)
}

func (c *nodeMapintuint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint16) find(key int) (uint, *nodeMapintuint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint16) SetP(key int, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint16) Set(key int, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint16) GetP(key int) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint16) Get(key int) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint16) Length() int {
	return t.length
}

// func (c *nodeMapintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterIntUint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint16 struct {
	t     *MapIntUint16
	nodes []*nodeMapintuint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int     // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint16.
func (t *MapIntUint16) Iterator() *IterIntUint16 {
	var i IterIntUint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUint16) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUint32 implements an associative array of uint32 indexed by int.
type MapIntUint32 struct {
	length int
	root   nodeMapintuint32
}

func NewMapIntUint32() *MapIntUint32 {
	var r MapIntUint32
	return &r
}

type nodeMapintuint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint32 or uint32)
}

// Return walking direction
func (c nodeMapintuint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint32) children() *[2]nodeMapintuint32 {
	return (*[2]nodeMapintuint32)(c.child)
}

func (c *nodeMapintuint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint32) find(key int) (uint, *nodeMapintuint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint32) SetP(key int, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint32) Set(key int, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint32) GetP(key int) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint32) Get(key int) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint32) Length() int {
	return t.length
}

// func (c *nodeMapintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterIntUint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint32 struct {
	t     *MapIntUint32
	nodes []*nodeMapintuint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int     // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint32.
func (t *MapIntUint32) Iterator() *IterIntUint32 {
	var i IterIntUint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUint32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUint64 implements an associative array of uint64 indexed by int.
type MapIntUint64 struct {
	length int
	root   nodeMapintuint64
}

func NewMapIntUint64() *MapIntUint64 {
	var r MapIntUint64
	return &r
}

type nodeMapintuint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint64 or uint64)
}

// Return walking direction
func (c nodeMapintuint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint64) children() *[2]nodeMapintuint64 {
	return (*[2]nodeMapintuint64)(c.child)
}

func (c *nodeMapintuint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint64) find(key int) (uint, *nodeMapintuint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint64) SetP(key int, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint64) Set(key int, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint64) GetP(key int) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint64) Get(key int) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint64) Length() int {
	return t.length
}

// func (c *nodeMapintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterIntUint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint64 struct {
	t     *MapIntUint64
	nodes []*nodeMapintuint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int     // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint64.
func (t *MapIntUint64) Iterator() *IterIntUint64 {
	var i IterIntUint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUint64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUint8 implements an associative array of uint8 indexed by int.
type MapIntUint8 struct {
	length int
	root   nodeMapintuint8
}

func NewMapIntUint8() *MapIntUint8 {
	var r MapIntUint8
	return &r
}

type nodeMapintuint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint8 or uint8)
}

// Return walking direction
func (c nodeMapintuint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint8) children() *[2]nodeMapintuint8 {
	return (*[2]nodeMapintuint8)(c.child)
}

func (c *nodeMapintuint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint8) find(key int) (uint, *nodeMapintuint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint8) SetP(key int, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint8) Set(key int, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint8) GetP(key int) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint8) Get(key int) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint8) Length() int {
	return t.length
}

// func (c *nodeMapintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterIntUint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint8 struct {
	t     *MapIntUint8
	nodes []*nodeMapintuint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int    // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint8.
func (t *MapIntUint8) Iterator() *IterIntUint8 {
	var i IterIntUint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUint8) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapIntUintptr implements an associative array of uintptr indexed by int.
type MapIntUintptr struct {
	length int
	root   nodeMapintuintptr
}

func NewMapIntUintptr() *MapIntUintptr {
	var r MapIntUintptr
	return &r
}

type nodeMapintuintptr struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapintuintptr) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuintptr) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuintptr) children() *[2]nodeMapintuintptr {
	return (*[2]nodeMapintuintptr)(c.child)
}

func (c *nodeMapintuintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuintptr) find(key int) (uint, *nodeMapintuintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUintptr) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUintptr) SetP(key int, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUintptr) Set(key int, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUintptr) GetP(key int) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUintptr) Get(key int) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUintptr) Length() int {
	return t.length
}

// func (c *nodeMapintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterIntUintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUintptr struct {
	t     *MapIntUintptr
	nodes []*nodeMapintuintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int      // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUintptr.
func (t *MapIntUintptr) Iterator() *IterIntUintptr {
	var i IterIntUintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterIntUintptr) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterIntUintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterIntUintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterIntUintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapintuintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapintuintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapintuintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Bool implements an associative array of bool indexed by int64.
type MapInt64Bool struct {
	length int
	root   nodeMapint64bool
}

func NewMapInt64Bool() *MapInt64Bool {
	var r MapInt64Bool
	return &r
}

type nodeMapint64bool struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64bool or bool)
}

// Return walking direction
func (c nodeMapint64bool) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64bool) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64bool) children() *[2]nodeMapint64bool {
	return (*[2]nodeMapint64bool)(c.child)
}

func (c *nodeMapint64bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64bool) find(key int64) (uint, *nodeMapint64bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Bool) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Bool) SetP(key int64, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Bool) Set(key int64, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Bool) GetP(key int64) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Bool) Get(key int64) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Bool) Length() int {
	return t.length
}

// func (c *nodeMapint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt64Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Bool struct {
	t     *MapInt64Bool
	nodes []*nodeMapint64bool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Bool.
func (t *MapInt64Bool) Iterator() *IterInt64Bool {
	var i IterInt64Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Bool) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Byte implements an associative array of byte indexed by int64.
type MapInt64Byte struct {
	length int
	root   nodeMapint64byte
}

func NewMapInt64Byte() *MapInt64Byte {
	var r MapInt64Byte
	return &r
}

type nodeMapint64byte struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64byte or byte)
}

// Return walking direction
func (c nodeMapint64byte) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64byte) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64byte) children() *[2]nodeMapint64byte {
	return (*[2]nodeMapint64byte)(c.child)
}

func (c *nodeMapint64byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64byte) find(key int64) (uint, *nodeMapint64byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Byte) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Byte) SetP(key int64, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Byte) Set(key int64, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Byte) GetP(key int64) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Byte) Get(key int64) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Byte) Length() int {
	return t.length
}

// func (c *nodeMapint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt64Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Byte struct {
	t     *MapInt64Byte
	nodes []*nodeMapint64byte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Byte.
func (t *MapInt64Byte) Iterator() *IterInt64Byte {
	var i IterInt64Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Byte) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Complex128 implements an associative array of complex128 indexed by int64.
type MapInt64Complex128 struct {
	length int
	root   nodeMapint64complex128
}

func NewMapInt64Complex128() *MapInt64Complex128 {
	var r MapInt64Complex128
	return &r
}

type nodeMapint64complex128 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapint64complex128) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex128) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64complex128) children() *[2]nodeMapint64complex128 {
	return (*[2]nodeMapint64complex128)(c.child)
}

func (c *nodeMapint64complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64complex128) find(key int64) (uint, *nodeMapint64complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Complex128) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Complex128) SetP(key int64, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Complex128) Set(key int64, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Complex128) GetP(key int64) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Complex128) Get(key int64) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt64Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Complex128 struct {
	t     *MapInt64Complex128
	nodes []*nodeMapint64complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64       // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Complex128.
func (t *MapInt64Complex128) Iterator() *IterInt64Complex128 {
	var i IterInt64Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Complex128) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Complex64 implements an associative array of complex64 indexed by int64.
type MapInt64Complex64 struct {
	length int
	root   nodeMapint64complex64
}

func NewMapInt64Complex64() *MapInt64Complex64 {
	var r MapInt64Complex64
	return &r
}

type nodeMapint64complex64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapint64complex64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64complex64) children() *[2]nodeMapint64complex64 {
	return (*[2]nodeMapint64complex64)(c.child)
}

func (c *nodeMapint64complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64complex64) find(key int64) (uint, *nodeMapint64complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Complex64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Complex64) SetP(key int64, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Complex64) Set(key int64, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Complex64) GetP(key int64) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Complex64) Get(key int64) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt64Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Complex64 struct {
	t     *MapInt64Complex64
	nodes []*nodeMapint64complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64      // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Complex64.
func (t *MapInt64Complex64) Iterator() *IterInt64Complex64 {
	var i IterInt64Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Complex64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Error implements an associative array of error indexed by int64.
type MapInt64Error struct {
	length int
	root   nodeMapint64error
}

func NewMapInt64Error() *MapInt64Error {
	var r MapInt64Error
	return &r
}

type nodeMapint64error struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64error or error)
}

// Return walking direction
func (c nodeMapint64error) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64error) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64error) children() *[2]nodeMapint64error {
	return (*[2]nodeMapint64error)(c.child)
}

func (c *nodeMapint64error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64error) find(key int64) (uint, *nodeMapint64error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Error) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Error) SetP(key int64, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Error) Set(key int64, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Error) GetP(key int64) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Error) Get(key int64) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Error) Length() int {
	return t.length
}

// func (c *nodeMapint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt64Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Error struct {
	t     *MapInt64Error
	nodes []*nodeMapint64error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64  // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Error.
func (t *MapInt64Error) Iterator() *IterInt64Error {
	var i IterInt64Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Error) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Float32 implements an associative array of float32 indexed by int64.
type MapInt64Float32 struct {
	length int
	root   nodeMapint64float32
}

func NewMapInt64Float32() *MapInt64Float32 {
	var r MapInt64Float32
	return &r
}

type nodeMapint64float32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float32 or float32)
}

// Return walking direction
func (c nodeMapint64float32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64float32) children() *[2]nodeMapint64float32 {
	return (*[2]nodeMapint64float32)(c.child)
}

func (c *nodeMapint64float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64float32) find(key int64) (uint, *nodeMapint64float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Float32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Float32) SetP(key int64, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Float32) Set(key int64, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Float32) GetP(key int64) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Float32) Get(key int64) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float32) Length() int {
	return t.length
}

// func (c *nodeMapint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt64Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Float32 struct {
	t     *MapInt64Float32
	nodes []*nodeMapint64float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64    // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Float32.
func (t *MapInt64Float32) Iterator() *IterInt64Float32 {
	var i IterInt64Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Float32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Float64 implements an associative array of float64 indexed by int64.
type MapInt64Float64 struct {
	length int
	root   nodeMapint64float64
}

func NewMapInt64Float64() *MapInt64Float64 {
	var r MapInt64Float64
	return &r
}

type nodeMapint64float64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float64 or float64)
}

// Return walking direction
func (c nodeMapint64float64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64float64) children() *[2]nodeMapint64float64 {
	return (*[2]nodeMapint64float64)(c.child)
}

func (c *nodeMapint64float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64float64) find(key int64) (uint, *nodeMapint64float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Float64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Float64) SetP(key int64, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Float64) Set(key int64, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Float64) GetP(key int64) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Float64) Get(key int64) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float64) Length() int {
	return t.length
}

// func (c *nodeMapint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt64Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Float64 struct {
	t     *MapInt64Float64
	nodes []*nodeMapint64float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64    // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Float64.
func (t *MapInt64Float64) Iterator() *IterInt64Float64 {
	var i IterInt64Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Float64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Int implements an associative array of int indexed by int64.
type MapInt64Int struct {
	length int
	root   nodeMapint64int
}

func NewMapInt64Int() *MapInt64Int {
	var r MapInt64Int
	return &r
}

type nodeMapint64int struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int or int)
}

// Return walking direction
func (c nodeMapint64int) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int) children() *[2]nodeMapint64int {
	return (*[2]nodeMapint64int)(c.child)
}

func (c *nodeMapint64int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int) find(key int64) (uint, *nodeMapint64int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int) SetP(key int64, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int) Set(key int64, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int) GetP(key int64) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int) Get(key int64) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int) Length() int {
	return t.length
}

// func (c *nodeMapint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt64Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int struct {
	t     *MapInt64Int
	nodes []*nodeMapint64int
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int.
func (t *MapInt64Int) Iterator() *IterInt64Int {
	var i IterInt64Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Int) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Int16 implements an associative array of int16 indexed by int64.
type MapInt64Int16 struct {
	length int
	root   nodeMapint64int16
}

func NewMapInt64Int16() *MapInt64Int16 {
	var r MapInt64Int16
	return &r
}

type nodeMapint64int16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int16 or int16)
}

// Return walking direction
func (c nodeMapint64int16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int16) children() *[2]nodeMapint64int16 {
	return (*[2]nodeMapint64int16)(c.child)
}

func (c *nodeMapint64int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int16) find(key int64) (uint, *nodeMapint64int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int16) SetP(key int64, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int16) Set(key int64, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int16) GetP(key int64) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int16) Get(key int64) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int16) Length() int {
	return t.length
}

// func (c *nodeMapint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt64Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int16 struct {
	t     *MapInt64Int16
	nodes []*nodeMapint64int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64  // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int16.
func (t *MapInt64Int16) Iterator() *IterInt64Int16 {
	var i IterInt64Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Int16) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Int32 implements an associative array of int32 indexed by int64.
type MapInt64Int32 struct {
	length int
	root   nodeMapint64int32
}

func NewMapInt64Int32() *MapInt64Int32 {
	var r MapInt64Int32
	return &r
}

type nodeMapint64int32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int32 or int32)
}

// Return walking direction
func (c nodeMapint64int32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int32) children() *[2]nodeMapint64int32 {
	return (*[2]nodeMapint64int32)(c.child)
}

func (c *nodeMapint64int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int32) find(key int64) (uint, *nodeMapint64int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int32) SetP(key int64, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int32) Set(key int64, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int32) GetP(key int64) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int32) Get(key int64) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int32) Length() int {
	return t.length
}

// func (c *nodeMapint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt64Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int32 struct {
	t     *MapInt64Int32
	nodes []*nodeMapint64int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64  // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int32.
func (t *MapInt64Int32) Iterator() *IterInt64Int32 {
	var i IterInt64Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Int32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Int64 implements an associative array of int64 indexed by int64.
type MapInt64Int64 struct {
	length int
	root   nodeMapint64int64
}

func NewMapInt64Int64() *MapInt64Int64 {
	var r MapInt64Int64
	return &r
}

type nodeMapint64int64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int64 or int64)
}

// Return walking direction
func (c nodeMapint64int64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int64) children() *[2]nodeMapint64int64 {
	return (*[2]nodeMapint64int64)(c.child)
}

func (c *nodeMapint64int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int64) find(key int64) (uint, *nodeMapint64int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int64) SetP(key int64, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int64) Set(key int64, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int64) GetP(key int64) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int64) Get(key int64) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int64) Length() int {
	return t.length
}

// func (c *nodeMapint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt64Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int64 struct {
	t     *MapInt64Int64
	nodes []*nodeMapint64int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64  // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int64.
func (t *MapInt64Int64) Iterator() *IterInt64Int64 {
	var i IterInt64Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Int64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Int8 implements an associative array of int8 indexed by int64.
type MapInt64Int8 struct {
	length int
	root   nodeMapint64int8
}

func NewMapInt64Int8() *MapInt64Int8 {
	var r MapInt64Int8
	return &r
}

type nodeMapint64int8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int8 or int8)
}

// Return walking direction
func (c nodeMapint64int8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int8) children() *[2]nodeMapint64int8 {
	return (*[2]nodeMapint64int8)(c.child)
}

func (c *nodeMapint64int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int8) find(key int64) (uint, *nodeMapint64int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int8) SetP(key int64, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int8) Set(key int64, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int8) GetP(key int64) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int8) Get(key int64) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int8) Length() int {
	return t.length
}

// func (c *nodeMapint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt64Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int8 struct {
	t     *MapInt64Int8
	nodes []*nodeMapint64int8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int8.
func (t *MapInt64Int8) Iterator() *IterInt64Int8 {
	var i IterInt64Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Int8) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Rune implements an associative array of rune indexed by int64.
type MapInt64Rune struct {
	length int
	root   nodeMapint64rune
}

func NewMapInt64Rune() *MapInt64Rune {
	var r MapInt64Rune
	return &r
}

type nodeMapint64rune struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64rune or rune)
}

// Return walking direction
func (c nodeMapint64rune) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64rune) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64rune) children() *[2]nodeMapint64rune {
	return (*[2]nodeMapint64rune)(c.child)
}

func (c *nodeMapint64rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64rune) find(key int64) (uint, *nodeMapint64rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Rune) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Rune) SetP(key int64, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Rune) Set(key int64, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Rune) GetP(key int64) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Rune) Get(key int64) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Rune) Length() int {
	return t.length
}

// func (c *nodeMapint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt64Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Rune struct {
	t     *MapInt64Rune
	nodes []*nodeMapint64rune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Rune.
func (t *MapInt64Rune) Iterator() *IterInt64Rune {
	var i IterInt64Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Rune) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64String implements an associative array of string indexed by int64.
type MapInt64String struct {
	length int
	root   nodeMapint64string
}

func NewMapInt64String() *MapInt64String {
	var r MapInt64String
	return &r
}

type nodeMapint64string struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64string or string)
}

// Return walking direction
func (c nodeMapint64string) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64string) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64string) children() *[2]nodeMapint64string {
	return (*[2]nodeMapint64string)(c.child)
}

func (c *nodeMapint64string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64string) find(key int64) (uint, *nodeMapint64string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64String) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64String) SetP(key int64, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64String) Set(key int64, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64String) GetP(key int64) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64String) Get(key int64) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64String) Length() int {
	return t.length
}

// func (c *nodeMapint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt64String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64String struct {
	t     *MapInt64String
	nodes []*nodeMapint64string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64   // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64String.
func (t *MapInt64String) Iterator() *IterInt64String {
	var i IterInt64String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64String) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uint implements an associative array of uint indexed by int64.
type MapInt64Uint struct {
	length int
	root   nodeMapint64uint
}

func NewMapInt64Uint() *MapInt64Uint {
	var r MapInt64Uint
	return &r
}

type nodeMapint64uint struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint or uint)
}

// Return walking direction
func (c nodeMapint64uint) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint) children() *[2]nodeMapint64uint {
	return (*[2]nodeMapint64uint)(c.child)
}

func (c *nodeMapint64uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint) find(key int64) (uint, *nodeMapint64uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint) SetP(key int64, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint) Set(key int64, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint) GetP(key int64) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint) Get(key int64) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint) Length() int {
	return t.length
}

// func (c *nodeMapint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt64Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint struct {
	t     *MapInt64Uint
	nodes []*nodeMapint64uint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64 // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint.
func (t *MapInt64Uint) Iterator() *IterInt64Uint {
	var i IterInt64Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uint) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uint16 implements an associative array of uint16 indexed by int64.
type MapInt64Uint16 struct {
	length int
	root   nodeMapint64uint16
}

func NewMapInt64Uint16() *MapInt64Uint16 {
	var r MapInt64Uint16
	return &r
}

type nodeMapint64uint16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapint64uint16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint16) children() *[2]nodeMapint64uint16 {
	return (*[2]nodeMapint64uint16)(c.child)
}

func (c *nodeMapint64uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint16) find(key int64) (uint, *nodeMapint64uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint16) SetP(key int64, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint16) Set(key int64, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint16) GetP(key int64) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint16) Get(key int64) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt64Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint16 struct {
	t     *MapInt64Uint16
	nodes []*nodeMapint64uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64   // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint16.
func (t *MapInt64Uint16) Iterator() *IterInt64Uint16 {
	var i IterInt64Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uint16) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uint32 implements an associative array of uint32 indexed by int64.
type MapInt64Uint32 struct {
	length int
	root   nodeMapint64uint32
}

func NewMapInt64Uint32() *MapInt64Uint32 {
	var r MapInt64Uint32
	return &r
}

type nodeMapint64uint32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapint64uint32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint32) children() *[2]nodeMapint64uint32 {
	return (*[2]nodeMapint64uint32)(c.child)
}

func (c *nodeMapint64uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint32) find(key int64) (uint, *nodeMapint64uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint32) SetP(key int64, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint32) Set(key int64, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint32) GetP(key int64) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint32) Get(key int64) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt64Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint32 struct {
	t     *MapInt64Uint32
	nodes []*nodeMapint64uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64   // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint32.
func (t *MapInt64Uint32) Iterator() *IterInt64Uint32 {
	var i IterInt64Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uint32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uint64 implements an associative array of uint64 indexed by int64.
type MapInt64Uint64 struct {
	length int
	root   nodeMapint64uint64
}

func NewMapInt64Uint64() *MapInt64Uint64 {
	var r MapInt64Uint64
	return &r
}

type nodeMapint64uint64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapint64uint64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint64) children() *[2]nodeMapint64uint64 {
	return (*[2]nodeMapint64uint64)(c.child)
}

func (c *nodeMapint64uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint64) find(key int64) (uint, *nodeMapint64uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint64) SetP(key int64, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint64) Set(key int64, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint64) GetP(key int64) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint64) Get(key int64) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt64Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint64 struct {
	t     *MapInt64Uint64
	nodes []*nodeMapint64uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64   // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint64.
func (t *MapInt64Uint64) Iterator() *IterInt64Uint64 {
	var i IterInt64Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uint64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uint8 implements an associative array of uint8 indexed by int64.
type MapInt64Uint8 struct {
	length int
	root   nodeMapint64uint8
}

func NewMapInt64Uint8() *MapInt64Uint8 {
	var r MapInt64Uint8
	return &r
}

type nodeMapint64uint8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapint64uint8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint8) children() *[2]nodeMapint64uint8 {
	return (*[2]nodeMapint64uint8)(c.child)
}

func (c *nodeMapint64uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint8) find(key int64) (uint, *nodeMapint64uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint8) SetP(key int64, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint8) Set(key int64, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint8) GetP(key int64) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint8) Get(key int64) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt64Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint8 struct {
	t     *MapInt64Uint8
	nodes []*nodeMapint64uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64  // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint8.
func (t *MapInt64Uint8) Iterator() *IterInt64Uint8 {
	var i IterInt64Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uint8) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt64Uintptr implements an associative array of uintptr indexed by int64.
type MapInt64Uintptr struct {
	length int
	root   nodeMapint64uintptr
}

func NewMapInt64Uintptr() *MapInt64Uintptr {
	var r MapInt64Uintptr
	return &r
}

type nodeMapint64uintptr struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint64uintptr) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uintptr) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uintptr) children() *[2]nodeMapint64uintptr {
	return (*[2]nodeMapint64uintptr)(c.child)
}

func (c *nodeMapint64uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uintptr) find(key int64) (uint, *nodeMapint64uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uintptr) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uintptr) SetP(key int64, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uintptr) Set(key int64, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uintptr) GetP(key int64) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uintptr) Get(key int64) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt64Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uintptr struct {
	t     *MapInt64Uintptr
	nodes []*nodeMapint64uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int64    // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uintptr.
func (t *MapInt64Uintptr) Iterator() *IterInt64Uintptr {
	var i IterInt64Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt64Uintptr) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt64Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt64Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt64Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint64uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint64uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint64uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Bool implements an associative array of bool indexed by int32.
type MapInt32Bool struct {
	length int
	root   nodeMapint32bool
}

func NewMapInt32Bool() *MapInt32Bool {
	var r MapInt32Bool
	return &r
}

type nodeMapint32bool struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32bool or bool)
}

// Return walking direction
func (c nodeMapint32bool) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32bool) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32bool) children() *[2]nodeMapint32bool {
	return (*[2]nodeMapint32bool)(c.child)
}

func (c *nodeMapint32bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32bool) find(key int32) (uint, *nodeMapint32bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Bool) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Bool) SetP(key int32, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Bool) Set(key int32, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Bool) GetP(key int32) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Bool) Get(key int32) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Bool) Length() int {
	return t.length
}

// func (c *nodeMapint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt32Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Bool struct {
	t     *MapInt32Bool
	nodes []*nodeMapint32bool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Bool.
func (t *MapInt32Bool) Iterator() *IterInt32Bool {
	var i IterInt32Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Bool) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Byte implements an associative array of byte indexed by int32.
type MapInt32Byte struct {
	length int
	root   nodeMapint32byte
}

func NewMapInt32Byte() *MapInt32Byte {
	var r MapInt32Byte
	return &r
}

type nodeMapint32byte struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32byte or byte)
}

// Return walking direction
func (c nodeMapint32byte) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32byte) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32byte) children() *[2]nodeMapint32byte {
	return (*[2]nodeMapint32byte)(c.child)
}

func (c *nodeMapint32byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32byte) find(key int32) (uint, *nodeMapint32byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Byte) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Byte) SetP(key int32, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Byte) Set(key int32, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Byte) GetP(key int32) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Byte) Get(key int32) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Byte) Length() int {
	return t.length
}

// func (c *nodeMapint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt32Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Byte struct {
	t     *MapInt32Byte
	nodes []*nodeMapint32byte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Byte.
func (t *MapInt32Byte) Iterator() *IterInt32Byte {
	var i IterInt32Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Byte) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Complex128 implements an associative array of complex128 indexed by int32.
type MapInt32Complex128 struct {
	length int
	root   nodeMapint32complex128
}

func NewMapInt32Complex128() *MapInt32Complex128 {
	var r MapInt32Complex128
	return &r
}

type nodeMapint32complex128 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapint32complex128) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex128) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32complex128) children() *[2]nodeMapint32complex128 {
	return (*[2]nodeMapint32complex128)(c.child)
}

func (c *nodeMapint32complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32complex128) find(key int32) (uint, *nodeMapint32complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Complex128) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Complex128) SetP(key int32, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Complex128) Set(key int32, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Complex128) GetP(key int32) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Complex128) Get(key int32) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt32Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Complex128 struct {
	t     *MapInt32Complex128
	nodes []*nodeMapint32complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32       // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Complex128.
func (t *MapInt32Complex128) Iterator() *IterInt32Complex128 {
	var i IterInt32Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Complex128) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Complex64 implements an associative array of complex64 indexed by int32.
type MapInt32Complex64 struct {
	length int
	root   nodeMapint32complex64
}

func NewMapInt32Complex64() *MapInt32Complex64 {
	var r MapInt32Complex64
	return &r
}

type nodeMapint32complex64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapint32complex64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32complex64) children() *[2]nodeMapint32complex64 {
	return (*[2]nodeMapint32complex64)(c.child)
}

func (c *nodeMapint32complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32complex64) find(key int32) (uint, *nodeMapint32complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Complex64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Complex64) SetP(key int32, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Complex64) Set(key int32, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Complex64) GetP(key int32) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Complex64) Get(key int32) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt32Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Complex64 struct {
	t     *MapInt32Complex64
	nodes []*nodeMapint32complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32      // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Complex64.
func (t *MapInt32Complex64) Iterator() *IterInt32Complex64 {
	var i IterInt32Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Complex64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Error implements an associative array of error indexed by int32.
type MapInt32Error struct {
	length int
	root   nodeMapint32error
}

func NewMapInt32Error() *MapInt32Error {
	var r MapInt32Error
	return &r
}

type nodeMapint32error struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32error or error)
}

// Return walking direction
func (c nodeMapint32error) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32error) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32error) children() *[2]nodeMapint32error {
	return (*[2]nodeMapint32error)(c.child)
}

func (c *nodeMapint32error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32error) find(key int32) (uint, *nodeMapint32error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Error) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Error) SetP(key int32, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Error) Set(key int32, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Error) GetP(key int32) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Error) Get(key int32) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Error) Length() int {
	return t.length
}

// func (c *nodeMapint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt32Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Error struct {
	t     *MapInt32Error
	nodes []*nodeMapint32error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32  // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Error.
func (t *MapInt32Error) Iterator() *IterInt32Error {
	var i IterInt32Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Error) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Float32 implements an associative array of float32 indexed by int32.
type MapInt32Float32 struct {
	length int
	root   nodeMapint32float32
}

func NewMapInt32Float32() *MapInt32Float32 {
	var r MapInt32Float32
	return &r
}

type nodeMapint32float32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float32 or float32)
}

// Return walking direction
func (c nodeMapint32float32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32float32) children() *[2]nodeMapint32float32 {
	return (*[2]nodeMapint32float32)(c.child)
}

func (c *nodeMapint32float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32float32) find(key int32) (uint, *nodeMapint32float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Float32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Float32) SetP(key int32, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Float32) Set(key int32, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Float32) GetP(key int32) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Float32) Get(key int32) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float32) Length() int {
	return t.length
}

// func (c *nodeMapint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt32Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Float32 struct {
	t     *MapInt32Float32
	nodes []*nodeMapint32float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32    // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Float32.
func (t *MapInt32Float32) Iterator() *IterInt32Float32 {
	var i IterInt32Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Float32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Float64 implements an associative array of float64 indexed by int32.
type MapInt32Float64 struct {
	length int
	root   nodeMapint32float64
}

func NewMapInt32Float64() *MapInt32Float64 {
	var r MapInt32Float64
	return &r
}

type nodeMapint32float64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float64 or float64)
}

// Return walking direction
func (c nodeMapint32float64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32float64) children() *[2]nodeMapint32float64 {
	return (*[2]nodeMapint32float64)(c.child)
}

func (c *nodeMapint32float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32float64) find(key int32) (uint, *nodeMapint32float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Float64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Float64) SetP(key int32, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Float64) Set(key int32, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Float64) GetP(key int32) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Float64) Get(key int32) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float64) Length() int {
	return t.length
}

// func (c *nodeMapint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt32Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Float64 struct {
	t     *MapInt32Float64
	nodes []*nodeMapint32float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32    // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Float64.
func (t *MapInt32Float64) Iterator() *IterInt32Float64 {
	var i IterInt32Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Float64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Int implements an associative array of int indexed by int32.
type MapInt32Int struct {
	length int
	root   nodeMapint32int
}

func NewMapInt32Int() *MapInt32Int {
	var r MapInt32Int
	return &r
}

type nodeMapint32int struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int or int)
}

// Return walking direction
func (c nodeMapint32int) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int) children() *[2]nodeMapint32int {
	return (*[2]nodeMapint32int)(c.child)
}

func (c *nodeMapint32int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int) find(key int32) (uint, *nodeMapint32int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int) SetP(key int32, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int) Set(key int32, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int) GetP(key int32) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int) Get(key int32) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int) Length() int {
	return t.length
}

// func (c *nodeMapint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt32Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int struct {
	t     *MapInt32Int
	nodes []*nodeMapint32int
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int.
func (t *MapInt32Int) Iterator() *IterInt32Int {
	var i IterInt32Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Int) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Int16 implements an associative array of int16 indexed by int32.
type MapInt32Int16 struct {
	length int
	root   nodeMapint32int16
}

func NewMapInt32Int16() *MapInt32Int16 {
	var r MapInt32Int16
	return &r
}

type nodeMapint32int16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int16 or int16)
}

// Return walking direction
func (c nodeMapint32int16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int16) children() *[2]nodeMapint32int16 {
	return (*[2]nodeMapint32int16)(c.child)
}

func (c *nodeMapint32int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int16) find(key int32) (uint, *nodeMapint32int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int16) SetP(key int32, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int16) Set(key int32, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int16) GetP(key int32) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int16) Get(key int32) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int16) Length() int {
	return t.length
}

// func (c *nodeMapint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt32Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int16 struct {
	t     *MapInt32Int16
	nodes []*nodeMapint32int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32  // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int16.
func (t *MapInt32Int16) Iterator() *IterInt32Int16 {
	var i IterInt32Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Int16) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Int32 implements an associative array of int32 indexed by int32.
type MapInt32Int32 struct {
	length int
	root   nodeMapint32int32
}

func NewMapInt32Int32() *MapInt32Int32 {
	var r MapInt32Int32
	return &r
}

type nodeMapint32int32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int32 or int32)
}

// Return walking direction
func (c nodeMapint32int32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int32) children() *[2]nodeMapint32int32 {
	return (*[2]nodeMapint32int32)(c.child)
}

func (c *nodeMapint32int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int32) find(key int32) (uint, *nodeMapint32int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int32) SetP(key int32, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int32) Set(key int32, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int32) GetP(key int32) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int32) Get(key int32) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int32) Length() int {
	return t.length
}

// func (c *nodeMapint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt32Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int32 struct {
	t     *MapInt32Int32
	nodes []*nodeMapint32int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32  // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int32.
func (t *MapInt32Int32) Iterator() *IterInt32Int32 {
	var i IterInt32Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Int32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Int64 implements an associative array of int64 indexed by int32.
type MapInt32Int64 struct {
	length int
	root   nodeMapint32int64
}

func NewMapInt32Int64() *MapInt32Int64 {
	var r MapInt32Int64
	return &r
}

type nodeMapint32int64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int64 or int64)
}

// Return walking direction
func (c nodeMapint32int64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int64) children() *[2]nodeMapint32int64 {
	return (*[2]nodeMapint32int64)(c.child)
}

func (c *nodeMapint32int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int64) find(key int32) (uint, *nodeMapint32int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int64) SetP(key int32, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int64) Set(key int32, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int64) GetP(key int32) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int64) Get(key int32) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int64) Length() int {
	return t.length
}

// func (c *nodeMapint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt32Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int64 struct {
	t     *MapInt32Int64
	nodes []*nodeMapint32int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32  // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int64.
func (t *MapInt32Int64) Iterator() *IterInt32Int64 {
	var i IterInt32Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Int64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Int8 implements an associative array of int8 indexed by int32.
type MapInt32Int8 struct {
	length int
	root   nodeMapint32int8
}

func NewMapInt32Int8() *MapInt32Int8 {
	var r MapInt32Int8
	return &r
}

type nodeMapint32int8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int8 or int8)
}

// Return walking direction
func (c nodeMapint32int8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int8) children() *[2]nodeMapint32int8 {
	return (*[2]nodeMapint32int8)(c.child)
}

func (c *nodeMapint32int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int8) find(key int32) (uint, *nodeMapint32int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int8) SetP(key int32, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int8) Set(key int32, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int8) GetP(key int32) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int8) Get(key int32) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int8) Length() int {
	return t.length
}

// func (c *nodeMapint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt32Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int8 struct {
	t     *MapInt32Int8
	nodes []*nodeMapint32int8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int8.
func (t *MapInt32Int8) Iterator() *IterInt32Int8 {
	var i IterInt32Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Int8) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Rune implements an associative array of rune indexed by int32.
type MapInt32Rune struct {
	length int
	root   nodeMapint32rune
}

func NewMapInt32Rune() *MapInt32Rune {
	var r MapInt32Rune
	return &r
}

type nodeMapint32rune struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32rune or rune)
}

// Return walking direction
func (c nodeMapint32rune) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32rune) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32rune) children() *[2]nodeMapint32rune {
	return (*[2]nodeMapint32rune)(c.child)
}

func (c *nodeMapint32rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32rune) find(key int32) (uint, *nodeMapint32rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Rune) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Rune) SetP(key int32, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Rune) Set(key int32, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Rune) GetP(key int32) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Rune) Get(key int32) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Rune) Length() int {
	return t.length
}

// func (c *nodeMapint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt32Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Rune struct {
	t     *MapInt32Rune
	nodes []*nodeMapint32rune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Rune.
func (t *MapInt32Rune) Iterator() *IterInt32Rune {
	var i IterInt32Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Rune) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32String implements an associative array of string indexed by int32.
type MapInt32String struct {
	length int
	root   nodeMapint32string
}

func NewMapInt32String() *MapInt32String {
	var r MapInt32String
	return &r
}

type nodeMapint32string struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32string or string)
}

// Return walking direction
func (c nodeMapint32string) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32string) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32string) children() *[2]nodeMapint32string {
	return (*[2]nodeMapint32string)(c.child)
}

func (c *nodeMapint32string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32string) find(key int32) (uint, *nodeMapint32string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32String) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32String) SetP(key int32, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32String) Set(key int32, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32String) GetP(key int32) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32String) Get(key int32) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32String) Length() int {
	return t.length
}

// func (c *nodeMapint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt32String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32String struct {
	t     *MapInt32String
	nodes []*nodeMapint32string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32   // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32String.
func (t *MapInt32String) Iterator() *IterInt32String {
	var i IterInt32String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32String) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uint implements an associative array of uint indexed by int32.
type MapInt32Uint struct {
	length int
	root   nodeMapint32uint
}

func NewMapInt32Uint() *MapInt32Uint {
	var r MapInt32Uint
	return &r
}

type nodeMapint32uint struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint or uint)
}

// Return walking direction
func (c nodeMapint32uint) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint) children() *[2]nodeMapint32uint {
	return (*[2]nodeMapint32uint)(c.child)
}

func (c *nodeMapint32uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint) find(key int32) (uint, *nodeMapint32uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint) SetP(key int32, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint) Set(key int32, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint) GetP(key int32) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint) Get(key int32) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint) Length() int {
	return t.length
}

// func (c *nodeMapint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt32Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint struct {
	t     *MapInt32Uint
	nodes []*nodeMapint32uint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32 // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint.
func (t *MapInt32Uint) Iterator() *IterInt32Uint {
	var i IterInt32Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uint) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uint16 implements an associative array of uint16 indexed by int32.
type MapInt32Uint16 struct {
	length int
	root   nodeMapint32uint16
}

func NewMapInt32Uint16() *MapInt32Uint16 {
	var r MapInt32Uint16
	return &r
}

type nodeMapint32uint16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapint32uint16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint16) children() *[2]nodeMapint32uint16 {
	return (*[2]nodeMapint32uint16)(c.child)
}

func (c *nodeMapint32uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint16) find(key int32) (uint, *nodeMapint32uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint16) SetP(key int32, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint16) Set(key int32, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint16) GetP(key int32) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint16) Get(key int32) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt32Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint16 struct {
	t     *MapInt32Uint16
	nodes []*nodeMapint32uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32   // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint16.
func (t *MapInt32Uint16) Iterator() *IterInt32Uint16 {
	var i IterInt32Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uint16) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uint32 implements an associative array of uint32 indexed by int32.
type MapInt32Uint32 struct {
	length int
	root   nodeMapint32uint32
}

func NewMapInt32Uint32() *MapInt32Uint32 {
	var r MapInt32Uint32
	return &r
}

type nodeMapint32uint32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapint32uint32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint32) children() *[2]nodeMapint32uint32 {
	return (*[2]nodeMapint32uint32)(c.child)
}

func (c *nodeMapint32uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint32) find(key int32) (uint, *nodeMapint32uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint32) SetP(key int32, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint32) Set(key int32, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint32) GetP(key int32) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint32) Get(key int32) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt32Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint32 struct {
	t     *MapInt32Uint32
	nodes []*nodeMapint32uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32   // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint32.
func (t *MapInt32Uint32) Iterator() *IterInt32Uint32 {
	var i IterInt32Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uint32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uint64 implements an associative array of uint64 indexed by int32.
type MapInt32Uint64 struct {
	length int
	root   nodeMapint32uint64
}

func NewMapInt32Uint64() *MapInt32Uint64 {
	var r MapInt32Uint64
	return &r
}

type nodeMapint32uint64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapint32uint64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint64) children() *[2]nodeMapint32uint64 {
	return (*[2]nodeMapint32uint64)(c.child)
}

func (c *nodeMapint32uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint64) find(key int32) (uint, *nodeMapint32uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint64) SetP(key int32, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint64) Set(key int32, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint64) GetP(key int32) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint64) Get(key int32) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt32Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint64 struct {
	t     *MapInt32Uint64
	nodes []*nodeMapint32uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32   // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint64.
func (t *MapInt32Uint64) Iterator() *IterInt32Uint64 {
	var i IterInt32Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uint64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uint8 implements an associative array of uint8 indexed by int32.
type MapInt32Uint8 struct {
	length int
	root   nodeMapint32uint8
}

func NewMapInt32Uint8() *MapInt32Uint8 {
	var r MapInt32Uint8
	return &r
}

type nodeMapint32uint8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapint32uint8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint8) children() *[2]nodeMapint32uint8 {
	return (*[2]nodeMapint32uint8)(c.child)
}

func (c *nodeMapint32uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint8) find(key int32) (uint, *nodeMapint32uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint8) SetP(key int32, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint8) Set(key int32, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint8) GetP(key int32) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint8) Get(key int32) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt32Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint8 struct {
	t     *MapInt32Uint8
	nodes []*nodeMapint32uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32  // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint8.
func (t *MapInt32Uint8) Iterator() *IterInt32Uint8 {
	var i IterInt32Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uint8) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt32Uintptr implements an associative array of uintptr indexed by int32.
type MapInt32Uintptr struct {
	length int
	root   nodeMapint32uintptr
}

func NewMapInt32Uintptr() *MapInt32Uintptr {
	var r MapInt32Uintptr
	return &r
}

type nodeMapint32uintptr struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint32uintptr) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uintptr) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uintptr) children() *[2]nodeMapint32uintptr {
	return (*[2]nodeMapint32uintptr)(c.child)
}

func (c *nodeMapint32uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uintptr) find(key int32) (uint, *nodeMapint32uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uintptr) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uintptr) SetP(key int32, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uintptr) Set(key int32, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uintptr) GetP(key int32) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uintptr) Get(key int32) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt32Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uintptr struct {
	t     *MapInt32Uintptr
	nodes []*nodeMapint32uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int32    // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uintptr.
func (t *MapInt32Uintptr) Iterator() *IterInt32Uintptr {
	var i IterInt32Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt32Uintptr) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt32Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt32Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt32Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint32uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint32uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint32uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Bool implements an associative array of bool indexed by int16.
type MapInt16Bool struct {
	length int
	root   nodeMapint16bool
}

func NewMapInt16Bool() *MapInt16Bool {
	var r MapInt16Bool
	return &r
}

type nodeMapint16bool struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16bool or bool)
}

// Return walking direction
func (c nodeMapint16bool) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16bool) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16bool) children() *[2]nodeMapint16bool {
	return (*[2]nodeMapint16bool)(c.child)
}

func (c *nodeMapint16bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16bool) find(key int16) (uint, *nodeMapint16bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Bool) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Bool) SetP(key int16, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Bool) Set(key int16, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Bool) GetP(key int16) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Bool) Get(key int16) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Bool) Length() int {
	return t.length
}

// func (c *nodeMapint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt16Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Bool struct {
	t     *MapInt16Bool
	nodes []*nodeMapint16bool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Bool.
func (t *MapInt16Bool) Iterator() *IterInt16Bool {
	var i IterInt16Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Bool) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Byte implements an associative array of byte indexed by int16.
type MapInt16Byte struct {
	length int
	root   nodeMapint16byte
}

func NewMapInt16Byte() *MapInt16Byte {
	var r MapInt16Byte
	return &r
}

type nodeMapint16byte struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16byte or byte)
}

// Return walking direction
func (c nodeMapint16byte) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16byte) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16byte) children() *[2]nodeMapint16byte {
	return (*[2]nodeMapint16byte)(c.child)
}

func (c *nodeMapint16byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16byte) find(key int16) (uint, *nodeMapint16byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Byte) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Byte) SetP(key int16, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Byte) Set(key int16, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Byte) GetP(key int16) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Byte) Get(key int16) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Byte) Length() int {
	return t.length
}

// func (c *nodeMapint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt16Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Byte struct {
	t     *MapInt16Byte
	nodes []*nodeMapint16byte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Byte.
func (t *MapInt16Byte) Iterator() *IterInt16Byte {
	var i IterInt16Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Byte) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Complex128 implements an associative array of complex128 indexed by int16.
type MapInt16Complex128 struct {
	length int
	root   nodeMapint16complex128
}

func NewMapInt16Complex128() *MapInt16Complex128 {
	var r MapInt16Complex128
	return &r
}

type nodeMapint16complex128 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapint16complex128) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex128) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16complex128) children() *[2]nodeMapint16complex128 {
	return (*[2]nodeMapint16complex128)(c.child)
}

func (c *nodeMapint16complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16complex128) find(key int16) (uint, *nodeMapint16complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Complex128) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Complex128) SetP(key int16, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Complex128) Set(key int16, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Complex128) GetP(key int16) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Complex128) Get(key int16) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt16Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Complex128 struct {
	t     *MapInt16Complex128
	nodes []*nodeMapint16complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16       // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Complex128.
func (t *MapInt16Complex128) Iterator() *IterInt16Complex128 {
	var i IterInt16Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Complex128) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Complex64 implements an associative array of complex64 indexed by int16.
type MapInt16Complex64 struct {
	length int
	root   nodeMapint16complex64
}

func NewMapInt16Complex64() *MapInt16Complex64 {
	var r MapInt16Complex64
	return &r
}

type nodeMapint16complex64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapint16complex64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16complex64) children() *[2]nodeMapint16complex64 {
	return (*[2]nodeMapint16complex64)(c.child)
}

func (c *nodeMapint16complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16complex64) find(key int16) (uint, *nodeMapint16complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Complex64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Complex64) SetP(key int16, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Complex64) Set(key int16, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Complex64) GetP(key int16) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Complex64) Get(key int16) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt16Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Complex64 struct {
	t     *MapInt16Complex64
	nodes []*nodeMapint16complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16      // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Complex64.
func (t *MapInt16Complex64) Iterator() *IterInt16Complex64 {
	var i IterInt16Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Complex64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Error implements an associative array of error indexed by int16.
type MapInt16Error struct {
	length int
	root   nodeMapint16error
}

func NewMapInt16Error() *MapInt16Error {
	var r MapInt16Error
	return &r
}

type nodeMapint16error struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16error or error)
}

// Return walking direction
func (c nodeMapint16error) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16error) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16error) children() *[2]nodeMapint16error {
	return (*[2]nodeMapint16error)(c.child)
}

func (c *nodeMapint16error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16error) find(key int16) (uint, *nodeMapint16error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Error) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Error) SetP(key int16, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Error) Set(key int16, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Error) GetP(key int16) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Error) Get(key int16) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Error) Length() int {
	return t.length
}

// func (c *nodeMapint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt16Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Error struct {
	t     *MapInt16Error
	nodes []*nodeMapint16error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16  // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Error.
func (t *MapInt16Error) Iterator() *IterInt16Error {
	var i IterInt16Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Error) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Float32 implements an associative array of float32 indexed by int16.
type MapInt16Float32 struct {
	length int
	root   nodeMapint16float32
}

func NewMapInt16Float32() *MapInt16Float32 {
	var r MapInt16Float32
	return &r
}

type nodeMapint16float32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float32 or float32)
}

// Return walking direction
func (c nodeMapint16float32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16float32) children() *[2]nodeMapint16float32 {
	return (*[2]nodeMapint16float32)(c.child)
}

func (c *nodeMapint16float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16float32) find(key int16) (uint, *nodeMapint16float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Float32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Float32) SetP(key int16, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Float32) Set(key int16, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Float32) GetP(key int16) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Float32) Get(key int16) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float32) Length() int {
	return t.length
}

// func (c *nodeMapint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt16Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Float32 struct {
	t     *MapInt16Float32
	nodes []*nodeMapint16float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16    // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Float32.
func (t *MapInt16Float32) Iterator() *IterInt16Float32 {
	var i IterInt16Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Float32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Float64 implements an associative array of float64 indexed by int16.
type MapInt16Float64 struct {
	length int
	root   nodeMapint16float64
}

func NewMapInt16Float64() *MapInt16Float64 {
	var r MapInt16Float64
	return &r
}

type nodeMapint16float64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float64 or float64)
}

// Return walking direction
func (c nodeMapint16float64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16float64) children() *[2]nodeMapint16float64 {
	return (*[2]nodeMapint16float64)(c.child)
}

func (c *nodeMapint16float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16float64) find(key int16) (uint, *nodeMapint16float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Float64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Float64) SetP(key int16, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Float64) Set(key int16, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Float64) GetP(key int16) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Float64) Get(key int16) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float64) Length() int {
	return t.length
}

// func (c *nodeMapint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt16Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Float64 struct {
	t     *MapInt16Float64
	nodes []*nodeMapint16float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16    // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Float64.
func (t *MapInt16Float64) Iterator() *IterInt16Float64 {
	var i IterInt16Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Float64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Int implements an associative array of int indexed by int16.
type MapInt16Int struct {
	length int
	root   nodeMapint16int
}

func NewMapInt16Int() *MapInt16Int {
	var r MapInt16Int
	return &r
}

type nodeMapint16int struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int or int)
}

// Return walking direction
func (c nodeMapint16int) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int) children() *[2]nodeMapint16int {
	return (*[2]nodeMapint16int)(c.child)
}

func (c *nodeMapint16int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int) find(key int16) (uint, *nodeMapint16int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int) SetP(key int16, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int) Set(key int16, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int) GetP(key int16) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int) Get(key int16) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int) Length() int {
	return t.length
}

// func (c *nodeMapint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt16Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int struct {
	t     *MapInt16Int
	nodes []*nodeMapint16int
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int.
func (t *MapInt16Int) Iterator() *IterInt16Int {
	var i IterInt16Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Int) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Int16 implements an associative array of int16 indexed by int16.
type MapInt16Int16 struct {
	length int
	root   nodeMapint16int16
}

func NewMapInt16Int16() *MapInt16Int16 {
	var r MapInt16Int16
	return &r
}

type nodeMapint16int16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int16 or int16)
}

// Return walking direction
func (c nodeMapint16int16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int16) children() *[2]nodeMapint16int16 {
	return (*[2]nodeMapint16int16)(c.child)
}

func (c *nodeMapint16int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int16) find(key int16) (uint, *nodeMapint16int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int16) SetP(key int16, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int16) Set(key int16, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int16) GetP(key int16) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int16) Get(key int16) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int16) Length() int {
	return t.length
}

// func (c *nodeMapint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt16Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int16 struct {
	t     *MapInt16Int16
	nodes []*nodeMapint16int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16  // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int16.
func (t *MapInt16Int16) Iterator() *IterInt16Int16 {
	var i IterInt16Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Int16) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Int32 implements an associative array of int32 indexed by int16.
type MapInt16Int32 struct {
	length int
	root   nodeMapint16int32
}

func NewMapInt16Int32() *MapInt16Int32 {
	var r MapInt16Int32
	return &r
}

type nodeMapint16int32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int32 or int32)
}

// Return walking direction
func (c nodeMapint16int32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int32) children() *[2]nodeMapint16int32 {
	return (*[2]nodeMapint16int32)(c.child)
}

func (c *nodeMapint16int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int32) find(key int16) (uint, *nodeMapint16int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int32) SetP(key int16, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int32) Set(key int16, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int32) GetP(key int16) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int32) Get(key int16) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int32) Length() int {
	return t.length
}

// func (c *nodeMapint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt16Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int32 struct {
	t     *MapInt16Int32
	nodes []*nodeMapint16int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16  // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int32.
func (t *MapInt16Int32) Iterator() *IterInt16Int32 {
	var i IterInt16Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Int32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Int64 implements an associative array of int64 indexed by int16.
type MapInt16Int64 struct {
	length int
	root   nodeMapint16int64
}

func NewMapInt16Int64() *MapInt16Int64 {
	var r MapInt16Int64
	return &r
}

type nodeMapint16int64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int64 or int64)
}

// Return walking direction
func (c nodeMapint16int64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int64) children() *[2]nodeMapint16int64 {
	return (*[2]nodeMapint16int64)(c.child)
}

func (c *nodeMapint16int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int64) find(key int16) (uint, *nodeMapint16int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int64) SetP(key int16, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int64) Set(key int16, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int64) GetP(key int16) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int64) Get(key int16) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int64) Length() int {
	return t.length
}

// func (c *nodeMapint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt16Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int64 struct {
	t     *MapInt16Int64
	nodes []*nodeMapint16int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16  // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int64.
func (t *MapInt16Int64) Iterator() *IterInt16Int64 {
	var i IterInt16Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Int64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Int8 implements an associative array of int8 indexed by int16.
type MapInt16Int8 struct {
	length int
	root   nodeMapint16int8
}

func NewMapInt16Int8() *MapInt16Int8 {
	var r MapInt16Int8
	return &r
}

type nodeMapint16int8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int8 or int8)
}

// Return walking direction
func (c nodeMapint16int8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int8) children() *[2]nodeMapint16int8 {
	return (*[2]nodeMapint16int8)(c.child)
}

func (c *nodeMapint16int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int8) find(key int16) (uint, *nodeMapint16int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int8) SetP(key int16, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int8) Set(key int16, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int8) GetP(key int16) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int8) Get(key int16) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int8) Length() int {
	return t.length
}

// func (c *nodeMapint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt16Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int8 struct {
	t     *MapInt16Int8
	nodes []*nodeMapint16int8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int8.
func (t *MapInt16Int8) Iterator() *IterInt16Int8 {
	var i IterInt16Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Int8) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Rune implements an associative array of rune indexed by int16.
type MapInt16Rune struct {
	length int
	root   nodeMapint16rune
}

func NewMapInt16Rune() *MapInt16Rune {
	var r MapInt16Rune
	return &r
}

type nodeMapint16rune struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16rune or rune)
}

// Return walking direction
func (c nodeMapint16rune) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16rune) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16rune) children() *[2]nodeMapint16rune {
	return (*[2]nodeMapint16rune)(c.child)
}

func (c *nodeMapint16rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16rune) find(key int16) (uint, *nodeMapint16rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Rune) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Rune) SetP(key int16, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Rune) Set(key int16, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Rune) GetP(key int16) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Rune) Get(key int16) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Rune) Length() int {
	return t.length
}

// func (c *nodeMapint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt16Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Rune struct {
	t     *MapInt16Rune
	nodes []*nodeMapint16rune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Rune.
func (t *MapInt16Rune) Iterator() *IterInt16Rune {
	var i IterInt16Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Rune) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16String implements an associative array of string indexed by int16.
type MapInt16String struct {
	length int
	root   nodeMapint16string
}

func NewMapInt16String() *MapInt16String {
	var r MapInt16String
	return &r
}

type nodeMapint16string struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16string or string)
}

// Return walking direction
func (c nodeMapint16string) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16string) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16string) children() *[2]nodeMapint16string {
	return (*[2]nodeMapint16string)(c.child)
}

func (c *nodeMapint16string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16string) find(key int16) (uint, *nodeMapint16string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16String) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16String) SetP(key int16, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16String) Set(key int16, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16String) GetP(key int16) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16String) Get(key int16) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16String) Length() int {
	return t.length
}

// func (c *nodeMapint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt16String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16String struct {
	t     *MapInt16String
	nodes []*nodeMapint16string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16   // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16String.
func (t *MapInt16String) Iterator() *IterInt16String {
	var i IterInt16String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16String) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uint implements an associative array of uint indexed by int16.
type MapInt16Uint struct {
	length int
	root   nodeMapint16uint
}

func NewMapInt16Uint() *MapInt16Uint {
	var r MapInt16Uint
	return &r
}

type nodeMapint16uint struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint or uint)
}

// Return walking direction
func (c nodeMapint16uint) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint) children() *[2]nodeMapint16uint {
	return (*[2]nodeMapint16uint)(c.child)
}

func (c *nodeMapint16uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint) find(key int16) (uint, *nodeMapint16uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint) SetP(key int16, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint) Set(key int16, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint) GetP(key int16) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint) Get(key int16) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint) Length() int {
	return t.length
}

// func (c *nodeMapint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt16Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint struct {
	t     *MapInt16Uint
	nodes []*nodeMapint16uint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16 // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint.
func (t *MapInt16Uint) Iterator() *IterInt16Uint {
	var i IterInt16Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uint) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uint16 implements an associative array of uint16 indexed by int16.
type MapInt16Uint16 struct {
	length int
	root   nodeMapint16uint16
}

func NewMapInt16Uint16() *MapInt16Uint16 {
	var r MapInt16Uint16
	return &r
}

type nodeMapint16uint16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapint16uint16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint16) children() *[2]nodeMapint16uint16 {
	return (*[2]nodeMapint16uint16)(c.child)
}

func (c *nodeMapint16uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint16) find(key int16) (uint, *nodeMapint16uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint16) SetP(key int16, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint16) Set(key int16, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint16) GetP(key int16) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint16) Get(key int16) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt16Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint16 struct {
	t     *MapInt16Uint16
	nodes []*nodeMapint16uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16   // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint16.
func (t *MapInt16Uint16) Iterator() *IterInt16Uint16 {
	var i IterInt16Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uint16) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uint32 implements an associative array of uint32 indexed by int16.
type MapInt16Uint32 struct {
	length int
	root   nodeMapint16uint32
}

func NewMapInt16Uint32() *MapInt16Uint32 {
	var r MapInt16Uint32
	return &r
}

type nodeMapint16uint32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapint16uint32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint32) children() *[2]nodeMapint16uint32 {
	return (*[2]nodeMapint16uint32)(c.child)
}

func (c *nodeMapint16uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint32) find(key int16) (uint, *nodeMapint16uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint32) SetP(key int16, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint32) Set(key int16, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint32) GetP(key int16) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint32) Get(key int16) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt16Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint32 struct {
	t     *MapInt16Uint32
	nodes []*nodeMapint16uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16   // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint32.
func (t *MapInt16Uint32) Iterator() *IterInt16Uint32 {
	var i IterInt16Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uint32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uint64 implements an associative array of uint64 indexed by int16.
type MapInt16Uint64 struct {
	length int
	root   nodeMapint16uint64
}

func NewMapInt16Uint64() *MapInt16Uint64 {
	var r MapInt16Uint64
	return &r
}

type nodeMapint16uint64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapint16uint64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint64) children() *[2]nodeMapint16uint64 {
	return (*[2]nodeMapint16uint64)(c.child)
}

func (c *nodeMapint16uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint64) find(key int16) (uint, *nodeMapint16uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint64) SetP(key int16, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint64) Set(key int16, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint64) GetP(key int16) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint64) Get(key int16) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt16Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint64 struct {
	t     *MapInt16Uint64
	nodes []*nodeMapint16uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16   // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint64.
func (t *MapInt16Uint64) Iterator() *IterInt16Uint64 {
	var i IterInt16Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uint64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uint8 implements an associative array of uint8 indexed by int16.
type MapInt16Uint8 struct {
	length int
	root   nodeMapint16uint8
}

func NewMapInt16Uint8() *MapInt16Uint8 {
	var r MapInt16Uint8
	return &r
}

type nodeMapint16uint8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapint16uint8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint8) children() *[2]nodeMapint16uint8 {
	return (*[2]nodeMapint16uint8)(c.child)
}

func (c *nodeMapint16uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint8) find(key int16) (uint, *nodeMapint16uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint8) SetP(key int16, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint8) Set(key int16, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint8) GetP(key int16) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint8) Get(key int16) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt16Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint8 struct {
	t     *MapInt16Uint8
	nodes []*nodeMapint16uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16  // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint8.
func (t *MapInt16Uint8) Iterator() *IterInt16Uint8 {
	var i IterInt16Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uint8) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt16Uintptr implements an associative array of uintptr indexed by int16.
type MapInt16Uintptr struct {
	length int
	root   nodeMapint16uintptr
}

func NewMapInt16Uintptr() *MapInt16Uintptr {
	var r MapInt16Uintptr
	return &r
}

type nodeMapint16uintptr struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint16uintptr) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uintptr) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uintptr) children() *[2]nodeMapint16uintptr {
	return (*[2]nodeMapint16uintptr)(c.child)
}

func (c *nodeMapint16uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uintptr) find(key int16) (uint, *nodeMapint16uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uintptr) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uintptr) SetP(key int16, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uintptr) Set(key int16, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uintptr) GetP(key int16) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uintptr) Get(key int16) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt16Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uintptr struct {
	t     *MapInt16Uintptr
	nodes []*nodeMapint16uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int16    // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uintptr.
func (t *MapInt16Uintptr) Iterator() *IterInt16Uintptr {
	var i IterInt16Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt16Uintptr) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt16Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt16Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt16Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint16uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint16uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint16uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Bool implements an associative array of bool indexed by int8.
type MapInt8Bool struct {
	length int
	root   nodeMapint8bool
}

func NewMapInt8Bool() *MapInt8Bool {
	var r MapInt8Bool
	return &r
}

type nodeMapint8bool struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8bool or bool)
}

// Return walking direction
func (c nodeMapint8bool) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8bool) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8bool) children() *[2]nodeMapint8bool {
	return (*[2]nodeMapint8bool)(c.child)
}

func (c *nodeMapint8bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8bool) find(key int8) (uint, *nodeMapint8bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Bool) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Bool) SetP(key int8, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Bool) Set(key int8, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Bool) GetP(key int8) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Bool) Get(key int8) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Bool) Length() int {
	return t.length
}

// func (c *nodeMapint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt8Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Bool struct {
	t     *MapInt8Bool
	nodes []*nodeMapint8bool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8  // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Bool.
func (t *MapInt8Bool) Iterator() *IterInt8Bool {
	var i IterInt8Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Bool) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Byte implements an associative array of byte indexed by int8.
type MapInt8Byte struct {
	length int
	root   nodeMapint8byte
}

func NewMapInt8Byte() *MapInt8Byte {
	var r MapInt8Byte
	return &r
}

type nodeMapint8byte struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8byte or byte)
}

// Return walking direction
func (c nodeMapint8byte) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8byte) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8byte) children() *[2]nodeMapint8byte {
	return (*[2]nodeMapint8byte)(c.child)
}

func (c *nodeMapint8byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8byte) find(key int8) (uint, *nodeMapint8byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Byte) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Byte) SetP(key int8, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Byte) Set(key int8, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Byte) GetP(key int8) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Byte) Get(key int8) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Byte) Length() int {
	return t.length
}

// func (c *nodeMapint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt8Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Byte struct {
	t     *MapInt8Byte
	nodes []*nodeMapint8byte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8  // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Byte.
func (t *MapInt8Byte) Iterator() *IterInt8Byte {
	var i IterInt8Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Byte) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Complex128 implements an associative array of complex128 indexed by int8.
type MapInt8Complex128 struct {
	length int
	root   nodeMapint8complex128
}

func NewMapInt8Complex128() *MapInt8Complex128 {
	var r MapInt8Complex128
	return &r
}

type nodeMapint8complex128 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapint8complex128) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex128) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8complex128) children() *[2]nodeMapint8complex128 {
	return (*[2]nodeMapint8complex128)(c.child)
}

func (c *nodeMapint8complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8complex128) find(key int8) (uint, *nodeMapint8complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Complex128) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Complex128) SetP(key int8, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Complex128) Set(key int8, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Complex128) GetP(key int8) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Complex128) Get(key int8) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt8Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Complex128 struct {
	t     *MapInt8Complex128
	nodes []*nodeMapint8complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8        // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Complex128.
func (t *MapInt8Complex128) Iterator() *IterInt8Complex128 {
	var i IterInt8Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Complex128) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Complex64 implements an associative array of complex64 indexed by int8.
type MapInt8Complex64 struct {
	length int
	root   nodeMapint8complex64
}

func NewMapInt8Complex64() *MapInt8Complex64 {
	var r MapInt8Complex64
	return &r
}

type nodeMapint8complex64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapint8complex64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8complex64) children() *[2]nodeMapint8complex64 {
	return (*[2]nodeMapint8complex64)(c.child)
}

func (c *nodeMapint8complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8complex64) find(key int8) (uint, *nodeMapint8complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Complex64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Complex64) SetP(key int8, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Complex64) Set(key int8, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Complex64) GetP(key int8) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Complex64) Get(key int8) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt8Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Complex64 struct {
	t     *MapInt8Complex64
	nodes []*nodeMapint8complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8       // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Complex64.
func (t *MapInt8Complex64) Iterator() *IterInt8Complex64 {
	var i IterInt8Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Complex64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Error implements an associative array of error indexed by int8.
type MapInt8Error struct {
	length int
	root   nodeMapint8error
}

func NewMapInt8Error() *MapInt8Error {
	var r MapInt8Error
	return &r
}

type nodeMapint8error struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8error or error)
}

// Return walking direction
func (c nodeMapint8error) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8error) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8error) children() *[2]nodeMapint8error {
	return (*[2]nodeMapint8error)(c.child)
}

func (c *nodeMapint8error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8error) find(key int8) (uint, *nodeMapint8error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Error) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Error) SetP(key int8, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Error) Set(key int8, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Error) GetP(key int8) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Error) Get(key int8) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Error) Length() int {
	return t.length
}

// func (c *nodeMapint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt8Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Error struct {
	t     *MapInt8Error
	nodes []*nodeMapint8error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8   // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Error.
func (t *MapInt8Error) Iterator() *IterInt8Error {
	var i IterInt8Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Error) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Float32 implements an associative array of float32 indexed by int8.
type MapInt8Float32 struct {
	length int
	root   nodeMapint8float32
}

func NewMapInt8Float32() *MapInt8Float32 {
	var r MapInt8Float32
	return &r
}

type nodeMapint8float32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float32 or float32)
}

// Return walking direction
func (c nodeMapint8float32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8float32) children() *[2]nodeMapint8float32 {
	return (*[2]nodeMapint8float32)(c.child)
}

func (c *nodeMapint8float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8float32) find(key int8) (uint, *nodeMapint8float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Float32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Float32) SetP(key int8, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Float32) Set(key int8, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Float32) GetP(key int8) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Float32) Get(key int8) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float32) Length() int {
	return t.length
}

// func (c *nodeMapint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt8Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Float32 struct {
	t     *MapInt8Float32
	nodes []*nodeMapint8float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8     // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Float32.
func (t *MapInt8Float32) Iterator() *IterInt8Float32 {
	var i IterInt8Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Float32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Float64 implements an associative array of float64 indexed by int8.
type MapInt8Float64 struct {
	length int
	root   nodeMapint8float64
}

func NewMapInt8Float64() *MapInt8Float64 {
	var r MapInt8Float64
	return &r
}

type nodeMapint8float64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float64 or float64)
}

// Return walking direction
func (c nodeMapint8float64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8float64) children() *[2]nodeMapint8float64 {
	return (*[2]nodeMapint8float64)(c.child)
}

func (c *nodeMapint8float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8float64) find(key int8) (uint, *nodeMapint8float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Float64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Float64) SetP(key int8, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Float64) Set(key int8, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Float64) GetP(key int8) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Float64) Get(key int8) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float64) Length() int {
	return t.length
}

// func (c *nodeMapint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt8Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Float64 struct {
	t     *MapInt8Float64
	nodes []*nodeMapint8float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8     // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Float64.
func (t *MapInt8Float64) Iterator() *IterInt8Float64 {
	var i IterInt8Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Float64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Int implements an associative array of int indexed by int8.
type MapInt8Int struct {
	length int
	root   nodeMapint8int
}

func NewMapInt8Int() *MapInt8Int {
	var r MapInt8Int
	return &r
}

type nodeMapint8int struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int or int)
}

// Return walking direction
func (c nodeMapint8int) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int) children() *[2]nodeMapint8int {
	return (*[2]nodeMapint8int)(c.child)
}

func (c *nodeMapint8int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int) find(key int8) (uint, *nodeMapint8int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int) SetP(key int8, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int) Set(key int8, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int) GetP(key int8) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int) Get(key int8) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int) Length() int {
	return t.length
}

// func (c *nodeMapint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt8Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int struct {
	t     *MapInt8Int
	nodes []*nodeMapint8int
	Found bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8 // Key found by last call to Next, Prev.
	Value *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int.
func (t *MapInt8Int) Iterator() *IterInt8Int {
	var i IterInt8Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Int) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Int16 implements an associative array of int16 indexed by int8.
type MapInt8Int16 struct {
	length int
	root   nodeMapint8int16
}

func NewMapInt8Int16() *MapInt8Int16 {
	var r MapInt8Int16
	return &r
}

type nodeMapint8int16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int16 or int16)
}

// Return walking direction
func (c nodeMapint8int16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int16) children() *[2]nodeMapint8int16 {
	return (*[2]nodeMapint8int16)(c.child)
}

func (c *nodeMapint8int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int16) find(key int8) (uint, *nodeMapint8int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int16) SetP(key int8, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int16) Set(key int8, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int16) GetP(key int8) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int16) Get(key int8) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int16) Length() int {
	return t.length
}

// func (c *nodeMapint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt8Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int16 struct {
	t     *MapInt8Int16
	nodes []*nodeMapint8int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8   // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int16.
func (t *MapInt8Int16) Iterator() *IterInt8Int16 {
	var i IterInt8Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Int16) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Int32 implements an associative array of int32 indexed by int8.
type MapInt8Int32 struct {
	length int
	root   nodeMapint8int32
}

func NewMapInt8Int32() *MapInt8Int32 {
	var r MapInt8Int32
	return &r
}

type nodeMapint8int32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int32 or int32)
}

// Return walking direction
func (c nodeMapint8int32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int32) children() *[2]nodeMapint8int32 {
	return (*[2]nodeMapint8int32)(c.child)
}

func (c *nodeMapint8int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int32) find(key int8) (uint, *nodeMapint8int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int32) SetP(key int8, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int32) Set(key int8, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int32) GetP(key int8) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int32) Get(key int8) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int32) Length() int {
	return t.length
}

// func (c *nodeMapint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt8Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int32 struct {
	t     *MapInt8Int32
	nodes []*nodeMapint8int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8   // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int32.
func (t *MapInt8Int32) Iterator() *IterInt8Int32 {
	var i IterInt8Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Int32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Int64 implements an associative array of int64 indexed by int8.
type MapInt8Int64 struct {
	length int
	root   nodeMapint8int64
}

func NewMapInt8Int64() *MapInt8Int64 {
	var r MapInt8Int64
	return &r
}

type nodeMapint8int64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int64 or int64)
}

// Return walking direction
func (c nodeMapint8int64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int64) children() *[2]nodeMapint8int64 {
	return (*[2]nodeMapint8int64)(c.child)
}

func (c *nodeMapint8int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int64) find(key int8) (uint, *nodeMapint8int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int64) SetP(key int8, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int64) Set(key int8, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int64) GetP(key int8) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int64) Get(key int8) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int64) Length() int {
	return t.length
}

// func (c *nodeMapint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt8Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int64 struct {
	t     *MapInt8Int64
	nodes []*nodeMapint8int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8   // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int64.
func (t *MapInt8Int64) Iterator() *IterInt8Int64 {
	var i IterInt8Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Int64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Int8 implements an associative array of int8 indexed by int8.
type MapInt8Int8 struct {
	length int
	root   nodeMapint8int8
}

func NewMapInt8Int8() *MapInt8Int8 {
	var r MapInt8Int8
	return &r
}

type nodeMapint8int8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int8 or int8)
}

// Return walking direction
func (c nodeMapint8int8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int8) children() *[2]nodeMapint8int8 {
	return (*[2]nodeMapint8int8)(c.child)
}

func (c *nodeMapint8int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int8) find(key int8) (uint, *nodeMapint8int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int8) SetP(key int8, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int8) Set(key int8, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int8) GetP(key int8) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int8) Get(key int8) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int8) Length() int {
	return t.length
}

// func (c *nodeMapint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt8Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int8 struct {
	t     *MapInt8Int8
	nodes []*nodeMapint8int8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8  // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int8.
func (t *MapInt8Int8) Iterator() *IterInt8Int8 {
	var i IterInt8Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Int8) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Rune implements an associative array of rune indexed by int8.
type MapInt8Rune struct {
	length int
	root   nodeMapint8rune
}

func NewMapInt8Rune() *MapInt8Rune {
	var r MapInt8Rune
	return &r
}

type nodeMapint8rune struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8rune or rune)
}

// Return walking direction
func (c nodeMapint8rune) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8rune) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8rune) children() *[2]nodeMapint8rune {
	return (*[2]nodeMapint8rune)(c.child)
}

func (c *nodeMapint8rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8rune) find(key int8) (uint, *nodeMapint8rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Rune) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Rune) SetP(key int8, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Rune) Set(key int8, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Rune) GetP(key int8) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Rune) Get(key int8) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Rune) Length() int {
	return t.length
}

// func (c *nodeMapint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt8Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Rune struct {
	t     *MapInt8Rune
	nodes []*nodeMapint8rune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8  // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Rune.
func (t *MapInt8Rune) Iterator() *IterInt8Rune {
	var i IterInt8Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Rune) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8String implements an associative array of string indexed by int8.
type MapInt8String struct {
	length int
	root   nodeMapint8string
}

func NewMapInt8String() *MapInt8String {
	var r MapInt8String
	return &r
}

type nodeMapint8string struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8string or string)
}

// Return walking direction
func (c nodeMapint8string) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8string) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8string) children() *[2]nodeMapint8string {
	return (*[2]nodeMapint8string)(c.child)
}

func (c *nodeMapint8string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8string) find(key int8) (uint, *nodeMapint8string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8String) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8String) SetP(key int8, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8String) Set(key int8, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8String) GetP(key int8) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8String) Get(key int8) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8String) Length() int {
	return t.length
}

// func (c *nodeMapint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt8String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8String struct {
	t     *MapInt8String
	nodes []*nodeMapint8string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8    // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8String.
func (t *MapInt8String) Iterator() *IterInt8String {
	var i IterInt8String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8String) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uint implements an associative array of uint indexed by int8.
type MapInt8Uint struct {
	length int
	root   nodeMapint8uint
}

func NewMapInt8Uint() *MapInt8Uint {
	var r MapInt8Uint
	return &r
}

type nodeMapint8uint struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint or uint)
}

// Return walking direction
func (c nodeMapint8uint) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint) children() *[2]nodeMapint8uint {
	return (*[2]nodeMapint8uint)(c.child)
}

func (c *nodeMapint8uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint) find(key int8) (uint, *nodeMapint8uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint) SetP(key int8, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint) Set(key int8, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint) GetP(key int8) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint) Get(key int8) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint) Length() int {
	return t.length
}

// func (c *nodeMapint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt8Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint struct {
	t     *MapInt8Uint
	nodes []*nodeMapint8uint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8  // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint.
func (t *MapInt8Uint) Iterator() *IterInt8Uint {
	var i IterInt8Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uint) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uint16 implements an associative array of uint16 indexed by int8.
type MapInt8Uint16 struct {
	length int
	root   nodeMapint8uint16
}

func NewMapInt8Uint16() *MapInt8Uint16 {
	var r MapInt8Uint16
	return &r
}

type nodeMapint8uint16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapint8uint16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint16) children() *[2]nodeMapint8uint16 {
	return (*[2]nodeMapint8uint16)(c.child)
}

func (c *nodeMapint8uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint16) find(key int8) (uint, *nodeMapint8uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint16) SetP(key int8, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint16) Set(key int8, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint16) GetP(key int8) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint16) Get(key int8) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt8Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint16 struct {
	t     *MapInt8Uint16
	nodes []*nodeMapint8uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8    // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint16.
func (t *MapInt8Uint16) Iterator() *IterInt8Uint16 {
	var i IterInt8Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uint16) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uint32 implements an associative array of uint32 indexed by int8.
type MapInt8Uint32 struct {
	length int
	root   nodeMapint8uint32
}

func NewMapInt8Uint32() *MapInt8Uint32 {
	var r MapInt8Uint32
	return &r
}

type nodeMapint8uint32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapint8uint32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint32) children() *[2]nodeMapint8uint32 {
	return (*[2]nodeMapint8uint32)(c.child)
}

func (c *nodeMapint8uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint32) find(key int8) (uint, *nodeMapint8uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint32) SetP(key int8, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint32) Set(key int8, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint32) GetP(key int8) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint32) Get(key int8) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt8Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint32 struct {
	t     *MapInt8Uint32
	nodes []*nodeMapint8uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8    // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint32.
func (t *MapInt8Uint32) Iterator() *IterInt8Uint32 {
	var i IterInt8Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uint32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uint64 implements an associative array of uint64 indexed by int8.
type MapInt8Uint64 struct {
	length int
	root   nodeMapint8uint64
}

func NewMapInt8Uint64() *MapInt8Uint64 {
	var r MapInt8Uint64
	return &r
}

type nodeMapint8uint64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapint8uint64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint64) children() *[2]nodeMapint8uint64 {
	return (*[2]nodeMapint8uint64)(c.child)
}

func (c *nodeMapint8uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint64) find(key int8) (uint, *nodeMapint8uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint64) SetP(key int8, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint64) Set(key int8, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint64) GetP(key int8) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint64) Get(key int8) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt8Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint64 struct {
	t     *MapInt8Uint64
	nodes []*nodeMapint8uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8    // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint64.
func (t *MapInt8Uint64) Iterator() *IterInt8Uint64 {
	var i IterInt8Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uint64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uint8 implements an associative array of uint8 indexed by int8.
type MapInt8Uint8 struct {
	length int
	root   nodeMapint8uint8
}

func NewMapInt8Uint8() *MapInt8Uint8 {
	var r MapInt8Uint8
	return &r
}

type nodeMapint8uint8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapint8uint8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint8) children() *[2]nodeMapint8uint8 {
	return (*[2]nodeMapint8uint8)(c.child)
}

func (c *nodeMapint8uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint8) find(key int8) (uint, *nodeMapint8uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint8) SetP(key int8, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint8) Set(key int8, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint8) GetP(key int8) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint8) Get(key int8) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt8Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint8 struct {
	t     *MapInt8Uint8
	nodes []*nodeMapint8uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8   // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint8.
func (t *MapInt8Uint8) Iterator() *IterInt8Uint8 {
	var i IterInt8Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uint8) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapInt8Uintptr implements an associative array of uintptr indexed by int8.
type MapInt8Uintptr struct {
	length int
	root   nodeMapint8uintptr
}

func NewMapInt8Uintptr() *MapInt8Uintptr {
	var r MapInt8Uintptr
	return &r
}

type nodeMapint8uintptr struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint8uintptr) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uintptr) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uintptr) children() *[2]nodeMapint8uintptr {
	return (*[2]nodeMapint8uintptr)(c.child)
}

func (c *nodeMapint8uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uintptr) find(key int8) (uint, *nodeMapint8uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uintptr) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uintptr) SetP(key int8, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uintptr) Set(key int8, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uintptr) GetP(key int8) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uintptr) Get(key int8) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt8Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uintptr struct {
	t     *MapInt8Uintptr
	nodes []*nodeMapint8uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   int8     // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uintptr.
func (t *MapInt8Uintptr) Iterator() *IterInt8Uintptr {
	var i IterInt8Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterInt8Uintptr) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterInt8Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterInt8Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterInt8Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapint8uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapint8uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapint8uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintBool implements an associative array of bool indexed by uint.
type MapUintBool struct {
	length int
	root   nodeMapuintbool
}

func NewMapUintBool() *MapUintBool {
	var r MapUintBool
	return &r
}

type nodeMapuintbool struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbool or bool)
}

// Return walking direction
func (c nodeMapuintbool) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbool) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintbool) children() *[2]nodeMapuintbool {
	return (*[2]nodeMapuintbool)(c.child)
}

func (c *nodeMapuintbool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintbool) find(key uint) (uint, *nodeMapuintbool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintBool) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintBool) SetP(key uint, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintBool) Set(key uint, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintBool) GetP(key uint) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintBool) Get(key uint) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintBool) Length() int {
	return t.length
}

// func (c *nodeMapuintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUintBool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintBool struct {
	t     *MapUintBool
	nodes []*nodeMapuintbool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint  // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintBool.
func (t *MapUintBool) Iterator() *IterUintBool {
	var i IterUintBool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintBool) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintBool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintbool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintBool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintBool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintbool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintbool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintbool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintbool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintByte implements an associative array of byte indexed by uint.
type MapUintByte struct {
	length int
	root   nodeMapuintbyte
}

func NewMapUintByte() *MapUintByte {
	var r MapUintByte
	return &r
}

type nodeMapuintbyte struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbyte or byte)
}

// Return walking direction
func (c nodeMapuintbyte) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbyte) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintbyte) children() *[2]nodeMapuintbyte {
	return (*[2]nodeMapuintbyte)(c.child)
}

func (c *nodeMapuintbyte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintbyte) find(key uint) (uint, *nodeMapuintbyte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintByte) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintByte) SetP(key uint, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintByte) Set(key uint, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintByte) GetP(key uint) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintByte) Get(key uint) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintByte) Length() int {
	return t.length
}

// func (c *nodeMapuintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUintByte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintByte struct {
	t     *MapUintByte
	nodes []*nodeMapuintbyte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint  // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintByte.
func (t *MapUintByte) Iterator() *IterUintByte {
	var i IterUintByte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintByte) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintByte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintbyte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintByte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintByte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintbyte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintbyte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintbyte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintbyte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintComplex128 implements an associative array of complex128 indexed by uint.
type MapUintComplex128 struct {
	length int
	root   nodeMapuintcomplex128
}

func NewMapUintComplex128() *MapUintComplex128 {
	var r MapUintComplex128
	return &r
}

type nodeMapuintcomplex128 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapuintcomplex128) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex128) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintcomplex128) children() *[2]nodeMapuintcomplex128 {
	return (*[2]nodeMapuintcomplex128)(c.child)
}

func (c *nodeMapuintcomplex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintcomplex128) find(key uint) (uint, *nodeMapuintcomplex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintComplex128) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintComplex128) SetP(key uint, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintComplex128) Set(key uint, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintComplex128) GetP(key uint) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintComplex128) Get(key uint) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex128) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUintComplex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintComplex128 struct {
	t     *MapUintComplex128
	nodes []*nodeMapuintcomplex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint        // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintComplex128.
func (t *MapUintComplex128) Iterator() *IterUintComplex128 {
	var i IterUintComplex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintComplex128) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintComplex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintcomplex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintComplex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintComplex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintcomplex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintcomplex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintcomplex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintcomplex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintComplex64 implements an associative array of complex64 indexed by uint.
type MapUintComplex64 struct {
	length int
	root   nodeMapuintcomplex64
}

func NewMapUintComplex64() *MapUintComplex64 {
	var r MapUintComplex64
	return &r
}

type nodeMapuintcomplex64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapuintcomplex64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintcomplex64) children() *[2]nodeMapuintcomplex64 {
	return (*[2]nodeMapuintcomplex64)(c.child)
}

func (c *nodeMapuintcomplex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintcomplex64) find(key uint) (uint, *nodeMapuintcomplex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintComplex64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintComplex64) SetP(key uint, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintComplex64) Set(key uint, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintComplex64) GetP(key uint) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintComplex64) Get(key uint) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex64) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUintComplex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintComplex64 struct {
	t     *MapUintComplex64
	nodes []*nodeMapuintcomplex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint       // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintComplex64.
func (t *MapUintComplex64) Iterator() *IterUintComplex64 {
	var i IterUintComplex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintComplex64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintComplex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintcomplex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintComplex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintComplex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintcomplex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintcomplex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintcomplex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintcomplex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintError implements an associative array of error indexed by uint.
type MapUintError struct {
	length int
	root   nodeMapuinterror
}

func NewMapUintError() *MapUintError {
	var r MapUintError
	return &r
}

type nodeMapuinterror struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuinterror or error)
}

// Return walking direction
func (c nodeMapuinterror) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuinterror) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuinterror) children() *[2]nodeMapuinterror {
	return (*[2]nodeMapuinterror)(c.child)
}

func (c *nodeMapuinterror) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuinterror) find(key uint) (uint, *nodeMapuinterror) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintError) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintError) SetP(key uint, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintError) Set(key uint, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintError) GetP(key uint) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintError) Get(key uint) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintError) Length() int {
	return t.length
}

// func (c *nodeMapuinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUintError The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintError struct {
	t     *MapUintError
	nodes []*nodeMapuinterror
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint   // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintError.
func (t *MapUintError) Iterator() *IterUintError {
	var i IterUintError
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintError) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintError) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuinterror, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintError) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintError) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuinterror = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuinterror)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuinterror)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuinterror)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintFloat32 implements an associative array of float32 indexed by uint.
type MapUintFloat32 struct {
	length int
	root   nodeMapuintfloat32
}

func NewMapUintFloat32() *MapUintFloat32 {
	var r MapUintFloat32
	return &r
}

type nodeMapuintfloat32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat32 or float32)
}

// Return walking direction
func (c nodeMapuintfloat32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintfloat32) children() *[2]nodeMapuintfloat32 {
	return (*[2]nodeMapuintfloat32)(c.child)
}

func (c *nodeMapuintfloat32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintfloat32) find(key uint) (uint, *nodeMapuintfloat32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintFloat32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintFloat32) SetP(key uint, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintFloat32) Set(key uint, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintFloat32) GetP(key uint) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintFloat32) Get(key uint) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat32) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUintFloat32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintFloat32 struct {
	t     *MapUintFloat32
	nodes []*nodeMapuintfloat32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint     // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintFloat32.
func (t *MapUintFloat32) Iterator() *IterUintFloat32 {
	var i IterUintFloat32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintFloat32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintFloat32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintfloat32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintFloat32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintFloat32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintfloat32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintfloat32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintfloat32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintfloat32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintFloat64 implements an associative array of float64 indexed by uint.
type MapUintFloat64 struct {
	length int
	root   nodeMapuintfloat64
}

func NewMapUintFloat64() *MapUintFloat64 {
	var r MapUintFloat64
	return &r
}

type nodeMapuintfloat64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat64 or float64)
}

// Return walking direction
func (c nodeMapuintfloat64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintfloat64) children() *[2]nodeMapuintfloat64 {
	return (*[2]nodeMapuintfloat64)(c.child)
}

func (c *nodeMapuintfloat64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintfloat64) find(key uint) (uint, *nodeMapuintfloat64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintFloat64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintFloat64) SetP(key uint, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintFloat64) Set(key uint, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintFloat64) GetP(key uint) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintFloat64) Get(key uint) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat64) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUintFloat64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintFloat64 struct {
	t     *MapUintFloat64
	nodes []*nodeMapuintfloat64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint     // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintFloat64.
func (t *MapUintFloat64) Iterator() *IterUintFloat64 {
	var i IterUintFloat64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintFloat64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintFloat64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintfloat64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintFloat64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintFloat64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintfloat64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintfloat64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintfloat64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintfloat64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintInt implements an associative array of int indexed by uint.
type MapUintInt struct {
	length int
	root   nodeMapuintint
}

func NewMapUintInt() *MapUintInt {
	var r MapUintInt
	return &r
}

type nodeMapuintint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint or int)
}

// Return walking direction
func (c nodeMapuintint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint) children() *[2]nodeMapuintint {
	return (*[2]nodeMapuintint)(c.child)
}

func (c *nodeMapuintint) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint) find(key uint) (uint, *nodeMapuintint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt) SetP(key uint, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt) Set(key uint, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt) GetP(key uint) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt) Get(key uint) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt) Length() int {
	return t.length
}

// func (c *nodeMapuintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUintInt The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt struct {
	t     *MapUintInt
	nodes []*nodeMapuintint
	Found bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint // Key found by last call to Next, Prev.
	Value *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt.
func (t *MapUintInt) Iterator() *IterUintInt {
	var i IterUintInt
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintInt) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintInt) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintInt) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintInt) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintInt16 implements an associative array of int16 indexed by uint.
type MapUintInt16 struct {
	length int
	root   nodeMapuintint16
}

func NewMapUintInt16() *MapUintInt16 {
	var r MapUintInt16
	return &r
}

type nodeMapuintint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint16 or int16)
}

// Return walking direction
func (c nodeMapuintint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint16) children() *[2]nodeMapuintint16 {
	return (*[2]nodeMapuintint16)(c.child)
}

func (c *nodeMapuintint16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint16) find(key uint) (uint, *nodeMapuintint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt16) SetP(key uint, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt16) Set(key uint, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt16) GetP(key uint) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt16) Get(key uint) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt16) Length() int {
	return t.length
}

// func (c *nodeMapuintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUintInt16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt16 struct {
	t     *MapUintInt16
	nodes []*nodeMapuintint16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint   // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt16.
func (t *MapUintInt16) Iterator() *IterUintInt16 {
	var i IterUintInt16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintInt16) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintInt16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintInt16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintInt16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintInt32 implements an associative array of int32 indexed by uint.
type MapUintInt32 struct {
	length int
	root   nodeMapuintint32
}

func NewMapUintInt32() *MapUintInt32 {
	var r MapUintInt32
	return &r
}

type nodeMapuintint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint32 or int32)
}

// Return walking direction
func (c nodeMapuintint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint32) children() *[2]nodeMapuintint32 {
	return (*[2]nodeMapuintint32)(c.child)
}

func (c *nodeMapuintint32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint32) find(key uint) (uint, *nodeMapuintint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt32) SetP(key uint, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt32) Set(key uint, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt32) GetP(key uint) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt32) Get(key uint) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt32) Length() int {
	return t.length
}

// func (c *nodeMapuintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUintInt32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt32 struct {
	t     *MapUintInt32
	nodes []*nodeMapuintint32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint   // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt32.
func (t *MapUintInt32) Iterator() *IterUintInt32 {
	var i IterUintInt32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintInt32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintInt32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintInt32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintInt32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintInt64 implements an associative array of int64 indexed by uint.
type MapUintInt64 struct {
	length int
	root   nodeMapuintint64
}

func NewMapUintInt64() *MapUintInt64 {
	var r MapUintInt64
	return &r
}

type nodeMapuintint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint64 or int64)
}

// Return walking direction
func (c nodeMapuintint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint64) children() *[2]nodeMapuintint64 {
	return (*[2]nodeMapuintint64)(c.child)
}

func (c *nodeMapuintint64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint64) find(key uint) (uint, *nodeMapuintint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt64) SetP(key uint, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt64) Set(key uint, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt64) GetP(key uint) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt64) Get(key uint) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt64) Length() int {
	return t.length
}

// func (c *nodeMapuintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUintInt64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt64 struct {
	t     *MapUintInt64
	nodes []*nodeMapuintint64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint   // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt64.
func (t *MapUintInt64) Iterator() *IterUintInt64 {
	var i IterUintInt64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintInt64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintInt64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintInt64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintInt64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintInt8 implements an associative array of int8 indexed by uint.
type MapUintInt8 struct {
	length int
	root   nodeMapuintint8
}

func NewMapUintInt8() *MapUintInt8 {
	var r MapUintInt8
	return &r
}

type nodeMapuintint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint8 or int8)
}

// Return walking direction
func (c nodeMapuintint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint8) children() *[2]nodeMapuintint8 {
	return (*[2]nodeMapuintint8)(c.child)
}

func (c *nodeMapuintint8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint8) find(key uint) (uint, *nodeMapuintint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt8) SetP(key uint, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt8) Set(key uint, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt8) GetP(key uint) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt8) Get(key uint) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt8) Length() int {
	return t.length
}

// func (c *nodeMapuintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUintInt8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt8 struct {
	t     *MapUintInt8
	nodes []*nodeMapuintint8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint  // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt8.
func (t *MapUintInt8) Iterator() *IterUintInt8 {
	var i IterUintInt8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintInt8) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintInt8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintInt8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintInt8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintRune implements an associative array of rune indexed by uint.
type MapUintRune struct {
	length int
	root   nodeMapuintrune
}

func NewMapUintRune() *MapUintRune {
	var r MapUintRune
	return &r
}

type nodeMapuintrune struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintrune or rune)
}

// Return walking direction
func (c nodeMapuintrune) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintrune) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintrune) children() *[2]nodeMapuintrune {
	return (*[2]nodeMapuintrune)(c.child)
}

func (c *nodeMapuintrune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintrune) find(key uint) (uint, *nodeMapuintrune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintRune) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintRune) SetP(key uint, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintRune) Set(key uint, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintRune) GetP(key uint) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintRune) Get(key uint) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintRune) Length() int {
	return t.length
}

// func (c *nodeMapuintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUintRune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintRune struct {
	t     *MapUintRune
	nodes []*nodeMapuintrune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint  // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintRune.
func (t *MapUintRune) Iterator() *IterUintRune {
	var i IterUintRune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintRune) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintRune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintrune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintRune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintRune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintrune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintrune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintrune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintrune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintString implements an associative array of string indexed by uint.
type MapUintString struct {
	length int
	root   nodeMapuintstring
}

func NewMapUintString() *MapUintString {
	var r MapUintString
	return &r
}

type nodeMapuintstring struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintstring or string)
}

// Return walking direction
func (c nodeMapuintstring) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintstring) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintstring) children() *[2]nodeMapuintstring {
	return (*[2]nodeMapuintstring)(c.child)
}

func (c *nodeMapuintstring) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintstring) find(key uint) (uint, *nodeMapuintstring) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintString) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintString) SetP(key uint, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintString) Set(key uint, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintString) GetP(key uint) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintString) Get(key uint) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintString) Length() int {
	return t.length
}

// func (c *nodeMapuintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUintString The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintString struct {
	t     *MapUintString
	nodes []*nodeMapuintstring
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint    // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintString.
func (t *MapUintString) Iterator() *IterUintString {
	var i IterUintString
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintString) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintString) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintstring, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintString) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintString) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintstring = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintstring)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintstring)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintstring)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUint implements an associative array of uint indexed by uint.
type MapUintUint struct {
	length int
	root   nodeMapuintuint
}

func NewMapUintUint() *MapUintUint {
	var r MapUintUint
	return &r
}

type nodeMapuintuint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint or uint)
}

// Return walking direction
func (c nodeMapuintuint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint) children() *[2]nodeMapuintuint {
	return (*[2]nodeMapuintuint)(c.child)
}

func (c *nodeMapuintuint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint) find(key uint) (uint, *nodeMapuintuint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint) SetP(key uint, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint) Set(key uint, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint) GetP(key uint) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint) Get(key uint) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint) Length() int {
	return t.length
}

// func (c *nodeMapuintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUintUint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint struct {
	t     *MapUintUint
	nodes []*nodeMapuintuint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint  // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint.
func (t *MapUintUint) Iterator() *IterUintUint {
	var i IterUintUint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUint) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUint16 implements an associative array of uint16 indexed by uint.
type MapUintUint16 struct {
	length int
	root   nodeMapuintuint16
}

func NewMapUintUint16() *MapUintUint16 {
	var r MapUintUint16
	return &r
}

type nodeMapuintuint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint16 or uint16)
}

// Return walking direction
func (c nodeMapuintuint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint16) children() *[2]nodeMapuintuint16 {
	return (*[2]nodeMapuintuint16)(c.child)
}

func (c *nodeMapuintuint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint16) find(key uint) (uint, *nodeMapuintuint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint16) SetP(key uint, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint16) Set(key uint, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint16) GetP(key uint) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint16) Get(key uint) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint16) Length() int {
	return t.length
}

// func (c *nodeMapuintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUintUint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint16 struct {
	t     *MapUintUint16
	nodes []*nodeMapuintuint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint    // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint16.
func (t *MapUintUint16) Iterator() *IterUintUint16 {
	var i IterUintUint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUint16) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUint32 implements an associative array of uint32 indexed by uint.
type MapUintUint32 struct {
	length int
	root   nodeMapuintuint32
}

func NewMapUintUint32() *MapUintUint32 {
	var r MapUintUint32
	return &r
}

type nodeMapuintuint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint32 or uint32)
}

// Return walking direction
func (c nodeMapuintuint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint32) children() *[2]nodeMapuintuint32 {
	return (*[2]nodeMapuintuint32)(c.child)
}

func (c *nodeMapuintuint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint32) find(key uint) (uint, *nodeMapuintuint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint32) SetP(key uint, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint32) Set(key uint, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint32) GetP(key uint) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint32) Get(key uint) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint32) Length() int {
	return t.length
}

// func (c *nodeMapuintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUintUint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint32 struct {
	t     *MapUintUint32
	nodes []*nodeMapuintuint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint    // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint32.
func (t *MapUintUint32) Iterator() *IterUintUint32 {
	var i IterUintUint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUint32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUint64 implements an associative array of uint64 indexed by uint.
type MapUintUint64 struct {
	length int
	root   nodeMapuintuint64
}

func NewMapUintUint64() *MapUintUint64 {
	var r MapUintUint64
	return &r
}

type nodeMapuintuint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint64 or uint64)
}

// Return walking direction
func (c nodeMapuintuint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint64) children() *[2]nodeMapuintuint64 {
	return (*[2]nodeMapuintuint64)(c.child)
}

func (c *nodeMapuintuint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint64) find(key uint) (uint, *nodeMapuintuint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint64) SetP(key uint, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint64) Set(key uint, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint64) GetP(key uint) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint64) Get(key uint) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint64) Length() int {
	return t.length
}

// func (c *nodeMapuintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUintUint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint64 struct {
	t     *MapUintUint64
	nodes []*nodeMapuintuint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint    // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint64.
func (t *MapUintUint64) Iterator() *IterUintUint64 {
	var i IterUintUint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUint64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUint8 implements an associative array of uint8 indexed by uint.
type MapUintUint8 struct {
	length int
	root   nodeMapuintuint8
}

func NewMapUintUint8() *MapUintUint8 {
	var r MapUintUint8
	return &r
}

type nodeMapuintuint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint8 or uint8)
}

// Return walking direction
func (c nodeMapuintuint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint8) children() *[2]nodeMapuintuint8 {
	return (*[2]nodeMapuintuint8)(c.child)
}

func (c *nodeMapuintuint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint8) find(key uint) (uint, *nodeMapuintuint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint8) SetP(key uint, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint8) Set(key uint, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint8) GetP(key uint) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint8) Get(key uint) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint8) Length() int {
	return t.length
}

// func (c *nodeMapuintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUintUint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint8 struct {
	t     *MapUintUint8
	nodes []*nodeMapuintuint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint   // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint8.
func (t *MapUintUint8) Iterator() *IterUintUint8 {
	var i IterUintUint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUint8) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUintUintptr implements an associative array of uintptr indexed by uint.
type MapUintUintptr struct {
	length int
	root   nodeMapuintuintptr
}

func NewMapUintUintptr() *MapUintUintptr {
	var r MapUintUintptr
	return &r
}

type nodeMapuintuintptr struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapuintuintptr) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuintptr) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuintptr) children() *[2]nodeMapuintuintptr {
	return (*[2]nodeMapuintuintptr)(c.child)
}

func (c *nodeMapuintuintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuintptr) find(key uint) (uint, *nodeMapuintuintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUintptr) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUintptr) SetP(key uint, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUintptr) Set(key uint, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUintptr) GetP(key uint) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUintptr) Get(key uint) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUintptr) Length() int {
	return t.length
}

// func (c *nodeMapuintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUintUintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUintptr struct {
	t     *MapUintUintptr
	nodes []*nodeMapuintuintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint     // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUintptr.
func (t *MapUintUintptr) Iterator() *IterUintUintptr {
	var i IterUintUintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUintUintptr) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUintUintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUintUintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUintUintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuintuintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuintuintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuintuintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Bool implements an associative array of bool indexed by uint64.
type MapUint64Bool struct {
	length int
	root   nodeMapuint64bool
}

func NewMapUint64Bool() *MapUint64Bool {
	var r MapUint64Bool
	return &r
}

type nodeMapuint64bool struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64bool or bool)
}

// Return walking direction
func (c nodeMapuint64bool) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64bool) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64bool) children() *[2]nodeMapuint64bool {
	return (*[2]nodeMapuint64bool)(c.child)
}

func (c *nodeMapuint64bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64bool) find(key uint64) (uint, *nodeMapuint64bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Bool) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Bool) SetP(key uint64, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Bool) Set(key uint64, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Bool) GetP(key uint64) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Bool) Get(key uint64) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint64Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Bool struct {
	t     *MapUint64Bool
	nodes []*nodeMapuint64bool
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Bool.
func (t *MapUint64Bool) Iterator() *IterUint64Bool {
	var i IterUint64Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Bool) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Byte implements an associative array of byte indexed by uint64.
type MapUint64Byte struct {
	length int
	root   nodeMapuint64byte
}

func NewMapUint64Byte() *MapUint64Byte {
	var r MapUint64Byte
	return &r
}

type nodeMapuint64byte struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64byte or byte)
}

// Return walking direction
func (c nodeMapuint64byte) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64byte) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64byte) children() *[2]nodeMapuint64byte {
	return (*[2]nodeMapuint64byte)(c.child)
}

func (c *nodeMapuint64byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64byte) find(key uint64) (uint, *nodeMapuint64byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Byte) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Byte) SetP(key uint64, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Byte) Set(key uint64, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Byte) GetP(key uint64) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Byte) Get(key uint64) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint64Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Byte struct {
	t     *MapUint64Byte
	nodes []*nodeMapuint64byte
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Byte.
func (t *MapUint64Byte) Iterator() *IterUint64Byte {
	var i IterUint64Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Byte) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Complex128 implements an associative array of complex128 indexed by uint64.
type MapUint64Complex128 struct {
	length int
	root   nodeMapuint64complex128
}

func NewMapUint64Complex128() *MapUint64Complex128 {
	var r MapUint64Complex128
	return &r
}

type nodeMapuint64complex128 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint64complex128) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex128) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64complex128) children() *[2]nodeMapuint64complex128 {
	return (*[2]nodeMapuint64complex128)(c.child)
}

func (c *nodeMapuint64complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64complex128) find(key uint64) (uint, *nodeMapuint64complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Complex128) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Complex128) SetP(key uint64, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Complex128) Set(key uint64, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Complex128) GetP(key uint64) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Complex128) Get(key uint64) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint64Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Complex128 struct {
	t     *MapUint64Complex128
	nodes []*nodeMapuint64complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64      // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Complex128.
func (t *MapUint64Complex128) Iterator() *IterUint64Complex128 {
	var i IterUint64Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Complex128) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Complex64 implements an associative array of complex64 indexed by uint64.
type MapUint64Complex64 struct {
	length int
	root   nodeMapuint64complex64
}

func NewMapUint64Complex64() *MapUint64Complex64 {
	var r MapUint64Complex64
	return &r
}

type nodeMapuint64complex64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint64complex64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64complex64) children() *[2]nodeMapuint64complex64 {
	return (*[2]nodeMapuint64complex64)(c.child)
}

func (c *nodeMapuint64complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64complex64) find(key uint64) (uint, *nodeMapuint64complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Complex64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Complex64) SetP(key uint64, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Complex64) Set(key uint64, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Complex64) GetP(key uint64) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Complex64) Get(key uint64) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint64Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Complex64 struct {
	t     *MapUint64Complex64
	nodes []*nodeMapuint64complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64     // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Complex64.
func (t *MapUint64Complex64) Iterator() *IterUint64Complex64 {
	var i IterUint64Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Complex64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Error implements an associative array of error indexed by uint64.
type MapUint64Error struct {
	length int
	root   nodeMapuint64error
}

func NewMapUint64Error() *MapUint64Error {
	var r MapUint64Error
	return &r
}

type nodeMapuint64error struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64error or error)
}

// Return walking direction
func (c nodeMapuint64error) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64error) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64error) children() *[2]nodeMapuint64error {
	return (*[2]nodeMapuint64error)(c.child)
}

func (c *nodeMapuint64error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64error) find(key uint64) (uint, *nodeMapuint64error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Error) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Error) SetP(key uint64, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Error) Set(key uint64, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Error) GetP(key uint64) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Error) Get(key uint64) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Error) Length() int {
	return t.length
}

// func (c *nodeMapuint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint64Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Error struct {
	t     *MapUint64Error
	nodes []*nodeMapuint64error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Error.
func (t *MapUint64Error) Iterator() *IterUint64Error {
	var i IterUint64Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Error) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Float32 implements an associative array of float32 indexed by uint64.
type MapUint64Float32 struct {
	length int
	root   nodeMapuint64float32
}

func NewMapUint64Float32() *MapUint64Float32 {
	var r MapUint64Float32
	return &r
}

type nodeMapuint64float32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float32 or float32)
}

// Return walking direction
func (c nodeMapuint64float32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64float32) children() *[2]nodeMapuint64float32 {
	return (*[2]nodeMapuint64float32)(c.child)
}

func (c *nodeMapuint64float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64float32) find(key uint64) (uint, *nodeMapuint64float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Float32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Float32) SetP(key uint64, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Float32) Set(key uint64, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Float32) GetP(key uint64) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Float32) Get(key uint64) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint64Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Float32 struct {
	t     *MapUint64Float32
	nodes []*nodeMapuint64float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64   // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Float32.
func (t *MapUint64Float32) Iterator() *IterUint64Float32 {
	var i IterUint64Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Float32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Float64 implements an associative array of float64 indexed by uint64.
type MapUint64Float64 struct {
	length int
	root   nodeMapuint64float64
}

func NewMapUint64Float64() *MapUint64Float64 {
	var r MapUint64Float64
	return &r
}

type nodeMapuint64float64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float64 or float64)
}

// Return walking direction
func (c nodeMapuint64float64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64float64) children() *[2]nodeMapuint64float64 {
	return (*[2]nodeMapuint64float64)(c.child)
}

func (c *nodeMapuint64float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64float64) find(key uint64) (uint, *nodeMapuint64float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Float64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Float64) SetP(key uint64, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Float64) Set(key uint64, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Float64) GetP(key uint64) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Float64) Get(key uint64) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint64Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Float64 struct {
	t     *MapUint64Float64
	nodes []*nodeMapuint64float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64   // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Float64.
func (t *MapUint64Float64) Iterator() *IterUint64Float64 {
	var i IterUint64Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Float64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Int implements an associative array of int indexed by uint64.
type MapUint64Int struct {
	length int
	root   nodeMapuint64int
}

func NewMapUint64Int() *MapUint64Int {
	var r MapUint64Int
	return &r
}

type nodeMapuint64int struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int or int)
}

// Return walking direction
func (c nodeMapuint64int) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int) children() *[2]nodeMapuint64int {
	return (*[2]nodeMapuint64int)(c.child)
}

func (c *nodeMapuint64int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int) find(key uint64) (uint, *nodeMapuint64int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int) SetP(key uint64, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int) Set(key uint64, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int) GetP(key uint64) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int) Get(key uint64) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int) Length() int {
	return t.length
}

// func (c *nodeMapuint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint64Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int struct {
	t     *MapUint64Int
	nodes []*nodeMapuint64int
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int.
func (t *MapUint64Int) Iterator() *IterUint64Int {
	var i IterUint64Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Int) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Int16 implements an associative array of int16 indexed by uint64.
type MapUint64Int16 struct {
	length int
	root   nodeMapuint64int16
}

func NewMapUint64Int16() *MapUint64Int16 {
	var r MapUint64Int16
	return &r
}

type nodeMapuint64int16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int16 or int16)
}

// Return walking direction
func (c nodeMapuint64int16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int16) children() *[2]nodeMapuint64int16 {
	return (*[2]nodeMapuint64int16)(c.child)
}

func (c *nodeMapuint64int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int16) find(key uint64) (uint, *nodeMapuint64int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int16) SetP(key uint64, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int16) Set(key uint64, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int16) GetP(key uint64) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int16) Get(key uint64) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint64Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int16 struct {
	t     *MapUint64Int16
	nodes []*nodeMapuint64int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int16.
func (t *MapUint64Int16) Iterator() *IterUint64Int16 {
	var i IterUint64Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Int16) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Int32 implements an associative array of int32 indexed by uint64.
type MapUint64Int32 struct {
	length int
	root   nodeMapuint64int32
}

func NewMapUint64Int32() *MapUint64Int32 {
	var r MapUint64Int32
	return &r
}

type nodeMapuint64int32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int32 or int32)
}

// Return walking direction
func (c nodeMapuint64int32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int32) children() *[2]nodeMapuint64int32 {
	return (*[2]nodeMapuint64int32)(c.child)
}

func (c *nodeMapuint64int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int32) find(key uint64) (uint, *nodeMapuint64int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int32) SetP(key uint64, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int32) Set(key uint64, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int32) GetP(key uint64) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int32) Get(key uint64) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint64Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int32 struct {
	t     *MapUint64Int32
	nodes []*nodeMapuint64int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int32.
func (t *MapUint64Int32) Iterator() *IterUint64Int32 {
	var i IterUint64Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Int32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Int64 implements an associative array of int64 indexed by uint64.
type MapUint64Int64 struct {
	length int
	root   nodeMapuint64int64
}

func NewMapUint64Int64() *MapUint64Int64 {
	var r MapUint64Int64
	return &r
}

type nodeMapuint64int64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int64 or int64)
}

// Return walking direction
func (c nodeMapuint64int64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int64) children() *[2]nodeMapuint64int64 {
	return (*[2]nodeMapuint64int64)(c.child)
}

func (c *nodeMapuint64int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int64) find(key uint64) (uint, *nodeMapuint64int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int64) SetP(key uint64, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int64) Set(key uint64, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int64) GetP(key uint64) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int64) Get(key uint64) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint64Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int64 struct {
	t     *MapUint64Int64
	nodes []*nodeMapuint64int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int64.
func (t *MapUint64Int64) Iterator() *IterUint64Int64 {
	var i IterUint64Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Int64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Int8 implements an associative array of int8 indexed by uint64.
type MapUint64Int8 struct {
	length int
	root   nodeMapuint64int8
}

func NewMapUint64Int8() *MapUint64Int8 {
	var r MapUint64Int8
	return &r
}

type nodeMapuint64int8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int8 or int8)
}

// Return walking direction
func (c nodeMapuint64int8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int8) children() *[2]nodeMapuint64int8 {
	return (*[2]nodeMapuint64int8)(c.child)
}

func (c *nodeMapuint64int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int8) find(key uint64) (uint, *nodeMapuint64int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int8) SetP(key uint64, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int8) Set(key uint64, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int8) GetP(key uint64) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int8) Get(key uint64) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint64Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int8 struct {
	t     *MapUint64Int8
	nodes []*nodeMapuint64int8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int8.
func (t *MapUint64Int8) Iterator() *IterUint64Int8 {
	var i IterUint64Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Int8) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Rune implements an associative array of rune indexed by uint64.
type MapUint64Rune struct {
	length int
	root   nodeMapuint64rune
}

func NewMapUint64Rune() *MapUint64Rune {
	var r MapUint64Rune
	return &r
}

type nodeMapuint64rune struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64rune or rune)
}

// Return walking direction
func (c nodeMapuint64rune) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64rune) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64rune) children() *[2]nodeMapuint64rune {
	return (*[2]nodeMapuint64rune)(c.child)
}

func (c *nodeMapuint64rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64rune) find(key uint64) (uint, *nodeMapuint64rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Rune) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Rune) SetP(key uint64, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Rune) Set(key uint64, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Rune) GetP(key uint64) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Rune) Get(key uint64) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint64Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Rune struct {
	t     *MapUint64Rune
	nodes []*nodeMapuint64rune
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Rune.
func (t *MapUint64Rune) Iterator() *IterUint64Rune {
	var i IterUint64Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Rune) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64String implements an associative array of string indexed by uint64.
type MapUint64String struct {
	length int
	root   nodeMapuint64string
}

func NewMapUint64String() *MapUint64String {
	var r MapUint64String
	return &r
}

type nodeMapuint64string struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64string or string)
}

// Return walking direction
func (c nodeMapuint64string) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64string) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64string) children() *[2]nodeMapuint64string {
	return (*[2]nodeMapuint64string)(c.child)
}

func (c *nodeMapuint64string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64string) find(key uint64) (uint, *nodeMapuint64string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64String) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64String) SetP(key uint64, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64String) Set(key uint64, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64String) GetP(key uint64) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64String) Get(key uint64) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64String) Length() int {
	return t.length
}

// func (c *nodeMapuint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint64String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64String struct {
	t     *MapUint64String
	nodes []*nodeMapuint64string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64  // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64String.
func (t *MapUint64String) Iterator() *IterUint64String {
	var i IterUint64String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64String) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uint implements an associative array of uint indexed by uint64.
type MapUint64Uint struct {
	length int
	root   nodeMapuint64uint
}

func NewMapUint64Uint() *MapUint64Uint {
	var r MapUint64Uint
	return &r
}

type nodeMapuint64uint struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint or uint)
}

// Return walking direction
func (c nodeMapuint64uint) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint) children() *[2]nodeMapuint64uint {
	return (*[2]nodeMapuint64uint)(c.child)
}

func (c *nodeMapuint64uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint) find(key uint64) (uint, *nodeMapuint64uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint) SetP(key uint64, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint) Set(key uint64, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint) GetP(key uint64) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint) Get(key uint64) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint64Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint struct {
	t     *MapUint64Uint
	nodes []*nodeMapuint64uint
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint.
func (t *MapUint64Uint) Iterator() *IterUint64Uint {
	var i IterUint64Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uint) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uint16 implements an associative array of uint16 indexed by uint64.
type MapUint64Uint16 struct {
	length int
	root   nodeMapuint64uint16
}

func NewMapUint64Uint16() *MapUint64Uint16 {
	var r MapUint64Uint16
	return &r
}

type nodeMapuint64uint16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint64uint16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint16) children() *[2]nodeMapuint64uint16 {
	return (*[2]nodeMapuint64uint16)(c.child)
}

func (c *nodeMapuint64uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint16) find(key uint64) (uint, *nodeMapuint64uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint16) SetP(key uint64, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint16) Set(key uint64, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint16) GetP(key uint64) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint16) Get(key uint64) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint64Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint16 struct {
	t     *MapUint64Uint16
	nodes []*nodeMapuint64uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64  // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint16.
func (t *MapUint64Uint16) Iterator() *IterUint64Uint16 {
	var i IterUint64Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uint16) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uint32 implements an associative array of uint32 indexed by uint64.
type MapUint64Uint32 struct {
	length int
	root   nodeMapuint64uint32
}

func NewMapUint64Uint32() *MapUint64Uint32 {
	var r MapUint64Uint32
	return &r
}

type nodeMapuint64uint32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint64uint32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint32) children() *[2]nodeMapuint64uint32 {
	return (*[2]nodeMapuint64uint32)(c.child)
}

func (c *nodeMapuint64uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint32) find(key uint64) (uint, *nodeMapuint64uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint32) SetP(key uint64, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint32) Set(key uint64, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint32) GetP(key uint64) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint32) Get(key uint64) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint64Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint32 struct {
	t     *MapUint64Uint32
	nodes []*nodeMapuint64uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64  // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint32.
func (t *MapUint64Uint32) Iterator() *IterUint64Uint32 {
	var i IterUint64Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uint32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uint64 implements an associative array of uint64 indexed by uint64.
type MapUint64Uint64 struct {
	length int
	root   nodeMapuint64uint64
}

func NewMapUint64Uint64() *MapUint64Uint64 {
	var r MapUint64Uint64
	return &r
}

type nodeMapuint64uint64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint64uint64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint64) children() *[2]nodeMapuint64uint64 {
	return (*[2]nodeMapuint64uint64)(c.child)
}

func (c *nodeMapuint64uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint64) find(key uint64) (uint, *nodeMapuint64uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint64) SetP(key uint64, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint64) Set(key uint64, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint64) GetP(key uint64) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint64) Get(key uint64) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint64Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint64 struct {
	t     *MapUint64Uint64
	nodes []*nodeMapuint64uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64  // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint64.
func (t *MapUint64Uint64) Iterator() *IterUint64Uint64 {
	var i IterUint64Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uint64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uint8 implements an associative array of uint8 indexed by uint64.
type MapUint64Uint8 struct {
	length int
	root   nodeMapuint64uint8
}

func NewMapUint64Uint8() *MapUint64Uint8 {
	var r MapUint64Uint8
	return &r
}

type nodeMapuint64uint8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint64uint8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint8) children() *[2]nodeMapuint64uint8 {
	return (*[2]nodeMapuint64uint8)(c.child)
}

func (c *nodeMapuint64uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint8) find(key uint64) (uint, *nodeMapuint64uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint8) SetP(key uint64, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint8) Set(key uint64, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint8) GetP(key uint64) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint8) Get(key uint64) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint64Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint8 struct {
	t     *MapUint64Uint8
	nodes []*nodeMapuint64uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64 // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint8.
func (t *MapUint64Uint8) Iterator() *IterUint64Uint8 {
	var i IterUint64Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uint8) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint64Uintptr implements an associative array of uintptr indexed by uint64.
type MapUint64Uintptr struct {
	length int
	root   nodeMapuint64uintptr
}

func NewMapUint64Uintptr() *MapUint64Uintptr {
	var r MapUint64Uintptr
	return &r
}

type nodeMapuint64uintptr struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint64uintptr) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uintptr) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uintptr) children() *[2]nodeMapuint64uintptr {
	return (*[2]nodeMapuint64uintptr)(c.child)
}

func (c *nodeMapuint64uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uintptr) find(key uint64) (uint, *nodeMapuint64uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uintptr) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uintptr) SetP(key uint64, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uintptr) Set(key uint64, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uintptr) GetP(key uint64) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uintptr) Get(key uint64) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint64Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uintptr struct {
	t     *MapUint64Uintptr
	nodes []*nodeMapuint64uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint64   // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uintptr.
func (t *MapUint64Uintptr) Iterator() *IterUint64Uintptr {
	var i IterUint64Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint64Uintptr) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint64Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint64Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint64Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint64uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint64uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Bool implements an associative array of bool indexed by uint32.
type MapUint32Bool struct {
	length int
	root   nodeMapuint32bool
}

func NewMapUint32Bool() *MapUint32Bool {
	var r MapUint32Bool
	return &r
}

type nodeMapuint32bool struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32bool or bool)
}

// Return walking direction
func (c nodeMapuint32bool) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32bool) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32bool) children() *[2]nodeMapuint32bool {
	return (*[2]nodeMapuint32bool)(c.child)
}

func (c *nodeMapuint32bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32bool) find(key uint32) (uint, *nodeMapuint32bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Bool) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Bool) SetP(key uint32, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Bool) Set(key uint32, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Bool) GetP(key uint32) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Bool) Get(key uint32) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint32Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Bool struct {
	t     *MapUint32Bool
	nodes []*nodeMapuint32bool
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Bool.
func (t *MapUint32Bool) Iterator() *IterUint32Bool {
	var i IterUint32Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Bool) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Byte implements an associative array of byte indexed by uint32.
type MapUint32Byte struct {
	length int
	root   nodeMapuint32byte
}

func NewMapUint32Byte() *MapUint32Byte {
	var r MapUint32Byte
	return &r
}

type nodeMapuint32byte struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32byte or byte)
}

// Return walking direction
func (c nodeMapuint32byte) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32byte) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32byte) children() *[2]nodeMapuint32byte {
	return (*[2]nodeMapuint32byte)(c.child)
}

func (c *nodeMapuint32byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32byte) find(key uint32) (uint, *nodeMapuint32byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Byte) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Byte) SetP(key uint32, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Byte) Set(key uint32, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Byte) GetP(key uint32) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Byte) Get(key uint32) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint32Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Byte struct {
	t     *MapUint32Byte
	nodes []*nodeMapuint32byte
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Byte.
func (t *MapUint32Byte) Iterator() *IterUint32Byte {
	var i IterUint32Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Byte) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Complex128 implements an associative array of complex128 indexed by uint32.
type MapUint32Complex128 struct {
	length int
	root   nodeMapuint32complex128
}

func NewMapUint32Complex128() *MapUint32Complex128 {
	var r MapUint32Complex128
	return &r
}

type nodeMapuint32complex128 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint32complex128) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex128) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32complex128) children() *[2]nodeMapuint32complex128 {
	return (*[2]nodeMapuint32complex128)(c.child)
}

func (c *nodeMapuint32complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32complex128) find(key uint32) (uint, *nodeMapuint32complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Complex128) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Complex128) SetP(key uint32, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Complex128) Set(key uint32, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Complex128) GetP(key uint32) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Complex128) Get(key uint32) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint32Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Complex128 struct {
	t     *MapUint32Complex128
	nodes []*nodeMapuint32complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32      // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Complex128.
func (t *MapUint32Complex128) Iterator() *IterUint32Complex128 {
	var i IterUint32Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Complex128) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Complex64 implements an associative array of complex64 indexed by uint32.
type MapUint32Complex64 struct {
	length int
	root   nodeMapuint32complex64
}

func NewMapUint32Complex64() *MapUint32Complex64 {
	var r MapUint32Complex64
	return &r
}

type nodeMapuint32complex64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint32complex64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32complex64) children() *[2]nodeMapuint32complex64 {
	return (*[2]nodeMapuint32complex64)(c.child)
}

func (c *nodeMapuint32complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32complex64) find(key uint32) (uint, *nodeMapuint32complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Complex64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Complex64) SetP(key uint32, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Complex64) Set(key uint32, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Complex64) GetP(key uint32) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Complex64) Get(key uint32) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint32Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Complex64 struct {
	t     *MapUint32Complex64
	nodes []*nodeMapuint32complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32     // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Complex64.
func (t *MapUint32Complex64) Iterator() *IterUint32Complex64 {
	var i IterUint32Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Complex64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Error implements an associative array of error indexed by uint32.
type MapUint32Error struct {
	length int
	root   nodeMapuint32error
}

func NewMapUint32Error() *MapUint32Error {
	var r MapUint32Error
	return &r
}

type nodeMapuint32error struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32error or error)
}

// Return walking direction
func (c nodeMapuint32error) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32error) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32error) children() *[2]nodeMapuint32error {
	return (*[2]nodeMapuint32error)(c.child)
}

func (c *nodeMapuint32error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32error) find(key uint32) (uint, *nodeMapuint32error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Error) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Error) SetP(key uint32, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Error) Set(key uint32, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Error) GetP(key uint32) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Error) Get(key uint32) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Error) Length() int {
	return t.length
}

// func (c *nodeMapuint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint32Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Error struct {
	t     *MapUint32Error
	nodes []*nodeMapuint32error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Error.
func (t *MapUint32Error) Iterator() *IterUint32Error {
	var i IterUint32Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Error) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Float32 implements an associative array of float32 indexed by uint32.
type MapUint32Float32 struct {
	length int
	root   nodeMapuint32float32
}

func NewMapUint32Float32() *MapUint32Float32 {
	var r MapUint32Float32
	return &r
}

type nodeMapuint32float32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float32 or float32)
}

// Return walking direction
func (c nodeMapuint32float32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32float32) children() *[2]nodeMapuint32float32 {
	return (*[2]nodeMapuint32float32)(c.child)
}

func (c *nodeMapuint32float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32float32) find(key uint32) (uint, *nodeMapuint32float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Float32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Float32) SetP(key uint32, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Float32) Set(key uint32, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Float32) GetP(key uint32) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Float32) Get(key uint32) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint32Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Float32 struct {
	t     *MapUint32Float32
	nodes []*nodeMapuint32float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32   // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Float32.
func (t *MapUint32Float32) Iterator() *IterUint32Float32 {
	var i IterUint32Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Float32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Float64 implements an associative array of float64 indexed by uint32.
type MapUint32Float64 struct {
	length int
	root   nodeMapuint32float64
}

func NewMapUint32Float64() *MapUint32Float64 {
	var r MapUint32Float64
	return &r
}

type nodeMapuint32float64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float64 or float64)
}

// Return walking direction
func (c nodeMapuint32float64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32float64) children() *[2]nodeMapuint32float64 {
	return (*[2]nodeMapuint32float64)(c.child)
}

func (c *nodeMapuint32float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32float64) find(key uint32) (uint, *nodeMapuint32float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Float64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Float64) SetP(key uint32, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Float64) Set(key uint32, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Float64) GetP(key uint32) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Float64) Get(key uint32) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint32Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Float64 struct {
	t     *MapUint32Float64
	nodes []*nodeMapuint32float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32   // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Float64.
func (t *MapUint32Float64) Iterator() *IterUint32Float64 {
	var i IterUint32Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Float64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Int implements an associative array of int indexed by uint32.
type MapUint32Int struct {
	length int
	root   nodeMapuint32int
}

func NewMapUint32Int() *MapUint32Int {
	var r MapUint32Int
	return &r
}

type nodeMapuint32int struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int or int)
}

// Return walking direction
func (c nodeMapuint32int) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int) children() *[2]nodeMapuint32int {
	return (*[2]nodeMapuint32int)(c.child)
}

func (c *nodeMapuint32int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int) find(key uint32) (uint, *nodeMapuint32int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int) SetP(key uint32, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int) Set(key uint32, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int) GetP(key uint32) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int) Get(key uint32) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int) Length() int {
	return t.length
}

// func (c *nodeMapuint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint32Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int struct {
	t     *MapUint32Int
	nodes []*nodeMapuint32int
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int.
func (t *MapUint32Int) Iterator() *IterUint32Int {
	var i IterUint32Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Int) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Int16 implements an associative array of int16 indexed by uint32.
type MapUint32Int16 struct {
	length int
	root   nodeMapuint32int16
}

func NewMapUint32Int16() *MapUint32Int16 {
	var r MapUint32Int16
	return &r
}

type nodeMapuint32int16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int16 or int16)
}

// Return walking direction
func (c nodeMapuint32int16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int16) children() *[2]nodeMapuint32int16 {
	return (*[2]nodeMapuint32int16)(c.child)
}

func (c *nodeMapuint32int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int16) find(key uint32) (uint, *nodeMapuint32int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int16) SetP(key uint32, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int16) Set(key uint32, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int16) GetP(key uint32) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int16) Get(key uint32) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint32Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int16 struct {
	t     *MapUint32Int16
	nodes []*nodeMapuint32int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int16.
func (t *MapUint32Int16) Iterator() *IterUint32Int16 {
	var i IterUint32Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Int16) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Int32 implements an associative array of int32 indexed by uint32.
type MapUint32Int32 struct {
	length int
	root   nodeMapuint32int32
}

func NewMapUint32Int32() *MapUint32Int32 {
	var r MapUint32Int32
	return &r
}

type nodeMapuint32int32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int32 or int32)
}

// Return walking direction
func (c nodeMapuint32int32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int32) children() *[2]nodeMapuint32int32 {
	return (*[2]nodeMapuint32int32)(c.child)
}

func (c *nodeMapuint32int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int32) find(key uint32) (uint, *nodeMapuint32int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int32) SetP(key uint32, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int32) Set(key uint32, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int32) GetP(key uint32) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int32) Get(key uint32) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint32Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int32 struct {
	t     *MapUint32Int32
	nodes []*nodeMapuint32int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int32.
func (t *MapUint32Int32) Iterator() *IterUint32Int32 {
	var i IterUint32Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Int32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Int64 implements an associative array of int64 indexed by uint32.
type MapUint32Int64 struct {
	length int
	root   nodeMapuint32int64
}

func NewMapUint32Int64() *MapUint32Int64 {
	var r MapUint32Int64
	return &r
}

type nodeMapuint32int64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int64 or int64)
}

// Return walking direction
func (c nodeMapuint32int64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int64) children() *[2]nodeMapuint32int64 {
	return (*[2]nodeMapuint32int64)(c.child)
}

func (c *nodeMapuint32int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int64) find(key uint32) (uint, *nodeMapuint32int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int64) SetP(key uint32, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int64) Set(key uint32, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int64) GetP(key uint32) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int64) Get(key uint32) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint32Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int64 struct {
	t     *MapUint32Int64
	nodes []*nodeMapuint32int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int64.
func (t *MapUint32Int64) Iterator() *IterUint32Int64 {
	var i IterUint32Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Int64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Int8 implements an associative array of int8 indexed by uint32.
type MapUint32Int8 struct {
	length int
	root   nodeMapuint32int8
}

func NewMapUint32Int8() *MapUint32Int8 {
	var r MapUint32Int8
	return &r
}

type nodeMapuint32int8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int8 or int8)
}

// Return walking direction
func (c nodeMapuint32int8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int8) children() *[2]nodeMapuint32int8 {
	return (*[2]nodeMapuint32int8)(c.child)
}

func (c *nodeMapuint32int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int8) find(key uint32) (uint, *nodeMapuint32int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int8) SetP(key uint32, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int8) Set(key uint32, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int8) GetP(key uint32) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int8) Get(key uint32) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint32Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int8 struct {
	t     *MapUint32Int8
	nodes []*nodeMapuint32int8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int8.
func (t *MapUint32Int8) Iterator() *IterUint32Int8 {
	var i IterUint32Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Int8) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Rune implements an associative array of rune indexed by uint32.
type MapUint32Rune struct {
	length int
	root   nodeMapuint32rune
}

func NewMapUint32Rune() *MapUint32Rune {
	var r MapUint32Rune
	return &r
}

type nodeMapuint32rune struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32rune or rune)
}

// Return walking direction
func (c nodeMapuint32rune) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32rune) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32rune) children() *[2]nodeMapuint32rune {
	return (*[2]nodeMapuint32rune)(c.child)
}

func (c *nodeMapuint32rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32rune) find(key uint32) (uint, *nodeMapuint32rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Rune) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Rune) SetP(key uint32, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Rune) Set(key uint32, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Rune) GetP(key uint32) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Rune) Get(key uint32) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint32Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Rune struct {
	t     *MapUint32Rune
	nodes []*nodeMapuint32rune
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Rune.
func (t *MapUint32Rune) Iterator() *IterUint32Rune {
	var i IterUint32Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Rune) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32String implements an associative array of string indexed by uint32.
type MapUint32String struct {
	length int
	root   nodeMapuint32string
}

func NewMapUint32String() *MapUint32String {
	var r MapUint32String
	return &r
}

type nodeMapuint32string struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32string or string)
}

// Return walking direction
func (c nodeMapuint32string) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32string) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32string) children() *[2]nodeMapuint32string {
	return (*[2]nodeMapuint32string)(c.child)
}

func (c *nodeMapuint32string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32string) find(key uint32) (uint, *nodeMapuint32string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32String) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32String) SetP(key uint32, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32String) Set(key uint32, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32String) GetP(key uint32) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32String) Get(key uint32) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32String) Length() int {
	return t.length
}

// func (c *nodeMapuint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint32String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32String struct {
	t     *MapUint32String
	nodes []*nodeMapuint32string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32  // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32String.
func (t *MapUint32String) Iterator() *IterUint32String {
	var i IterUint32String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32String) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uint implements an associative array of uint indexed by uint32.
type MapUint32Uint struct {
	length int
	root   nodeMapuint32uint
}

func NewMapUint32Uint() *MapUint32Uint {
	var r MapUint32Uint
	return &r
}

type nodeMapuint32uint struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint or uint)
}

// Return walking direction
func (c nodeMapuint32uint) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint) children() *[2]nodeMapuint32uint {
	return (*[2]nodeMapuint32uint)(c.child)
}

func (c *nodeMapuint32uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint) find(key uint32) (uint, *nodeMapuint32uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint) SetP(key uint32, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint) Set(key uint32, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint) GetP(key uint32) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint) Get(key uint32) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint32Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint struct {
	t     *MapUint32Uint
	nodes []*nodeMapuint32uint
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint.
func (t *MapUint32Uint) Iterator() *IterUint32Uint {
	var i IterUint32Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uint) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uint16 implements an associative array of uint16 indexed by uint32.
type MapUint32Uint16 struct {
	length int
	root   nodeMapuint32uint16
}

func NewMapUint32Uint16() *MapUint32Uint16 {
	var r MapUint32Uint16
	return &r
}

type nodeMapuint32uint16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint32uint16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint16) children() *[2]nodeMapuint32uint16 {
	return (*[2]nodeMapuint32uint16)(c.child)
}

func (c *nodeMapuint32uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint16) find(key uint32) (uint, *nodeMapuint32uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint16) SetP(key uint32, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint16) Set(key uint32, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint16) GetP(key uint32) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint16) Get(key uint32) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint32Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint16 struct {
	t     *MapUint32Uint16
	nodes []*nodeMapuint32uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32  // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint16.
func (t *MapUint32Uint16) Iterator() *IterUint32Uint16 {
	var i IterUint32Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uint16) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uint32 implements an associative array of uint32 indexed by uint32.
type MapUint32Uint32 struct {
	length int
	root   nodeMapuint32uint32
}

func NewMapUint32Uint32() *MapUint32Uint32 {
	var r MapUint32Uint32
	return &r
}

type nodeMapuint32uint32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint32uint32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint32) children() *[2]nodeMapuint32uint32 {
	return (*[2]nodeMapuint32uint32)(c.child)
}

func (c *nodeMapuint32uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint32) find(key uint32) (uint, *nodeMapuint32uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint32) SetP(key uint32, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint32) Set(key uint32, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint32) GetP(key uint32) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint32) Get(key uint32) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint32Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint32 struct {
	t     *MapUint32Uint32
	nodes []*nodeMapuint32uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32  // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint32.
func (t *MapUint32Uint32) Iterator() *IterUint32Uint32 {
	var i IterUint32Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uint32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uint64 implements an associative array of uint64 indexed by uint32.
type MapUint32Uint64 struct {
	length int
	root   nodeMapuint32uint64
}

func NewMapUint32Uint64() *MapUint32Uint64 {
	var r MapUint32Uint64
	return &r
}

type nodeMapuint32uint64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint32uint64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint64) children() *[2]nodeMapuint32uint64 {
	return (*[2]nodeMapuint32uint64)(c.child)
}

func (c *nodeMapuint32uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint64) find(key uint32) (uint, *nodeMapuint32uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint64) SetP(key uint32, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint64) Set(key uint32, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint64) GetP(key uint32) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint64) Get(key uint32) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint32Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint64 struct {
	t     *MapUint32Uint64
	nodes []*nodeMapuint32uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32  // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint64.
func (t *MapUint32Uint64) Iterator() *IterUint32Uint64 {
	var i IterUint32Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uint64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uint8 implements an associative array of uint8 indexed by uint32.
type MapUint32Uint8 struct {
	length int
	root   nodeMapuint32uint8
}

func NewMapUint32Uint8() *MapUint32Uint8 {
	var r MapUint32Uint8
	return &r
}

type nodeMapuint32uint8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint32uint8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint8) children() *[2]nodeMapuint32uint8 {
	return (*[2]nodeMapuint32uint8)(c.child)
}

func (c *nodeMapuint32uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint8) find(key uint32) (uint, *nodeMapuint32uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint8) SetP(key uint32, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint8) Set(key uint32, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint8) GetP(key uint32) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint8) Get(key uint32) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint32Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint8 struct {
	t     *MapUint32Uint8
	nodes []*nodeMapuint32uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32 // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint8.
func (t *MapUint32Uint8) Iterator() *IterUint32Uint8 {
	var i IterUint32Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uint8) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint32Uintptr implements an associative array of uintptr indexed by uint32.
type MapUint32Uintptr struct {
	length int
	root   nodeMapuint32uintptr
}

func NewMapUint32Uintptr() *MapUint32Uintptr {
	var r MapUint32Uintptr
	return &r
}

type nodeMapuint32uintptr struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint32uintptr) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uintptr) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uintptr) children() *[2]nodeMapuint32uintptr {
	return (*[2]nodeMapuint32uintptr)(c.child)
}

func (c *nodeMapuint32uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uintptr) find(key uint32) (uint, *nodeMapuint32uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uintptr) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uintptr) SetP(key uint32, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uintptr) Set(key uint32, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uintptr) GetP(key uint32) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uintptr) Get(key uint32) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint32Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uintptr struct {
	t     *MapUint32Uintptr
	nodes []*nodeMapuint32uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint32   // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uintptr.
func (t *MapUint32Uintptr) Iterator() *IterUint32Uintptr {
	var i IterUint32Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint32Uintptr) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint32Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint32Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint32Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint32uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint32uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Bool implements an associative array of bool indexed by uint16.
type MapUint16Bool struct {
	length int
	root   nodeMapuint16bool
}

func NewMapUint16Bool() *MapUint16Bool {
	var r MapUint16Bool
	return &r
}

type nodeMapuint16bool struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16bool or bool)
}

// Return walking direction
func (c nodeMapuint16bool) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16bool) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16bool) children() *[2]nodeMapuint16bool {
	return (*[2]nodeMapuint16bool)(c.child)
}

func (c *nodeMapuint16bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16bool) find(key uint16) (uint, *nodeMapuint16bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Bool) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Bool) SetP(key uint16, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Bool) Set(key uint16, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Bool) GetP(key uint16) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Bool) Get(key uint16) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint16Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Bool struct {
	t     *MapUint16Bool
	nodes []*nodeMapuint16bool
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Bool.
func (t *MapUint16Bool) Iterator() *IterUint16Bool {
	var i IterUint16Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Bool) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Byte implements an associative array of byte indexed by uint16.
type MapUint16Byte struct {
	length int
	root   nodeMapuint16byte
}

func NewMapUint16Byte() *MapUint16Byte {
	var r MapUint16Byte
	return &r
}

type nodeMapuint16byte struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16byte or byte)
}

// Return walking direction
func (c nodeMapuint16byte) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16byte) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16byte) children() *[2]nodeMapuint16byte {
	return (*[2]nodeMapuint16byte)(c.child)
}

func (c *nodeMapuint16byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16byte) find(key uint16) (uint, *nodeMapuint16byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Byte) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Byte) SetP(key uint16, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Byte) Set(key uint16, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Byte) GetP(key uint16) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Byte) Get(key uint16) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint16Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Byte struct {
	t     *MapUint16Byte
	nodes []*nodeMapuint16byte
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Byte.
func (t *MapUint16Byte) Iterator() *IterUint16Byte {
	var i IterUint16Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Byte) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Complex128 implements an associative array of complex128 indexed by uint16.
type MapUint16Complex128 struct {
	length int
	root   nodeMapuint16complex128
}

func NewMapUint16Complex128() *MapUint16Complex128 {
	var r MapUint16Complex128
	return &r
}

type nodeMapuint16complex128 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint16complex128) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex128) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16complex128) children() *[2]nodeMapuint16complex128 {
	return (*[2]nodeMapuint16complex128)(c.child)
}

func (c *nodeMapuint16complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16complex128) find(key uint16) (uint, *nodeMapuint16complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Complex128) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Complex128) SetP(key uint16, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Complex128) Set(key uint16, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Complex128) GetP(key uint16) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Complex128) Get(key uint16) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint16Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Complex128 struct {
	t     *MapUint16Complex128
	nodes []*nodeMapuint16complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16      // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Complex128.
func (t *MapUint16Complex128) Iterator() *IterUint16Complex128 {
	var i IterUint16Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Complex128) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Complex64 implements an associative array of complex64 indexed by uint16.
type MapUint16Complex64 struct {
	length int
	root   nodeMapuint16complex64
}

func NewMapUint16Complex64() *MapUint16Complex64 {
	var r MapUint16Complex64
	return &r
}

type nodeMapuint16complex64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint16complex64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16complex64) children() *[2]nodeMapuint16complex64 {
	return (*[2]nodeMapuint16complex64)(c.child)
}

func (c *nodeMapuint16complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16complex64) find(key uint16) (uint, *nodeMapuint16complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Complex64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Complex64) SetP(key uint16, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Complex64) Set(key uint16, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Complex64) GetP(key uint16) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Complex64) Get(key uint16) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint16Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Complex64 struct {
	t     *MapUint16Complex64
	nodes []*nodeMapuint16complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16     // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Complex64.
func (t *MapUint16Complex64) Iterator() *IterUint16Complex64 {
	var i IterUint16Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Complex64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Error implements an associative array of error indexed by uint16.
type MapUint16Error struct {
	length int
	root   nodeMapuint16error
}

func NewMapUint16Error() *MapUint16Error {
	var r MapUint16Error
	return &r
}

type nodeMapuint16error struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16error or error)
}

// Return walking direction
func (c nodeMapuint16error) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16error) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16error) children() *[2]nodeMapuint16error {
	return (*[2]nodeMapuint16error)(c.child)
}

func (c *nodeMapuint16error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16error) find(key uint16) (uint, *nodeMapuint16error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Error) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Error) SetP(key uint16, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Error) Set(key uint16, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Error) GetP(key uint16) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Error) Get(key uint16) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Error) Length() int {
	return t.length
}

// func (c *nodeMapuint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint16Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Error struct {
	t     *MapUint16Error
	nodes []*nodeMapuint16error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Error.
func (t *MapUint16Error) Iterator() *IterUint16Error {
	var i IterUint16Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Error) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Float32 implements an associative array of float32 indexed by uint16.
type MapUint16Float32 struct {
	length int
	root   nodeMapuint16float32
}

func NewMapUint16Float32() *MapUint16Float32 {
	var r MapUint16Float32
	return &r
}

type nodeMapuint16float32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float32 or float32)
}

// Return walking direction
func (c nodeMapuint16float32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16float32) children() *[2]nodeMapuint16float32 {
	return (*[2]nodeMapuint16float32)(c.child)
}

func (c *nodeMapuint16float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16float32) find(key uint16) (uint, *nodeMapuint16float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Float32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Float32) SetP(key uint16, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Float32) Set(key uint16, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Float32) GetP(key uint16) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Float32) Get(key uint16) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint16Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Float32 struct {
	t     *MapUint16Float32
	nodes []*nodeMapuint16float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16   // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Float32.
func (t *MapUint16Float32) Iterator() *IterUint16Float32 {
	var i IterUint16Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Float32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Float64 implements an associative array of float64 indexed by uint16.
type MapUint16Float64 struct {
	length int
	root   nodeMapuint16float64
}

func NewMapUint16Float64() *MapUint16Float64 {
	var r MapUint16Float64
	return &r
}

type nodeMapuint16float64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float64 or float64)
}

// Return walking direction
func (c nodeMapuint16float64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16float64) children() *[2]nodeMapuint16float64 {
	return (*[2]nodeMapuint16float64)(c.child)
}

func (c *nodeMapuint16float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16float64) find(key uint16) (uint, *nodeMapuint16float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Float64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Float64) SetP(key uint16, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Float64) Set(key uint16, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Float64) GetP(key uint16) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Float64) Get(key uint16) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint16Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Float64 struct {
	t     *MapUint16Float64
	nodes []*nodeMapuint16float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16   // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Float64.
func (t *MapUint16Float64) Iterator() *IterUint16Float64 {
	var i IterUint16Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Float64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Int implements an associative array of int indexed by uint16.
type MapUint16Int struct {
	length int
	root   nodeMapuint16int
}

func NewMapUint16Int() *MapUint16Int {
	var r MapUint16Int
	return &r
}

type nodeMapuint16int struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int or int)
}

// Return walking direction
func (c nodeMapuint16int) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int) children() *[2]nodeMapuint16int {
	return (*[2]nodeMapuint16int)(c.child)
}

func (c *nodeMapuint16int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int) find(key uint16) (uint, *nodeMapuint16int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int) SetP(key uint16, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int) Set(key uint16, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int) GetP(key uint16) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int) Get(key uint16) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int) Length() int {
	return t.length
}

// func (c *nodeMapuint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint16Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int struct {
	t     *MapUint16Int
	nodes []*nodeMapuint16int
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int.
func (t *MapUint16Int) Iterator() *IterUint16Int {
	var i IterUint16Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Int) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Int16 implements an associative array of int16 indexed by uint16.
type MapUint16Int16 struct {
	length int
	root   nodeMapuint16int16
}

func NewMapUint16Int16() *MapUint16Int16 {
	var r MapUint16Int16
	return &r
}

type nodeMapuint16int16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int16 or int16)
}

// Return walking direction
func (c nodeMapuint16int16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int16) children() *[2]nodeMapuint16int16 {
	return (*[2]nodeMapuint16int16)(c.child)
}

func (c *nodeMapuint16int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int16) find(key uint16) (uint, *nodeMapuint16int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int16) SetP(key uint16, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int16) Set(key uint16, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int16) GetP(key uint16) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int16) Get(key uint16) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint16Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int16 struct {
	t     *MapUint16Int16
	nodes []*nodeMapuint16int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int16.
func (t *MapUint16Int16) Iterator() *IterUint16Int16 {
	var i IterUint16Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Int16) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Int32 implements an associative array of int32 indexed by uint16.
type MapUint16Int32 struct {
	length int
	root   nodeMapuint16int32
}

func NewMapUint16Int32() *MapUint16Int32 {
	var r MapUint16Int32
	return &r
}

type nodeMapuint16int32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int32 or int32)
}

// Return walking direction
func (c nodeMapuint16int32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int32) children() *[2]nodeMapuint16int32 {
	return (*[2]nodeMapuint16int32)(c.child)
}

func (c *nodeMapuint16int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int32) find(key uint16) (uint, *nodeMapuint16int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int32) SetP(key uint16, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int32) Set(key uint16, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int32) GetP(key uint16) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int32) Get(key uint16) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint16Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int32 struct {
	t     *MapUint16Int32
	nodes []*nodeMapuint16int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int32.
func (t *MapUint16Int32) Iterator() *IterUint16Int32 {
	var i IterUint16Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Int32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Int64 implements an associative array of int64 indexed by uint16.
type MapUint16Int64 struct {
	length int
	root   nodeMapuint16int64
}

func NewMapUint16Int64() *MapUint16Int64 {
	var r MapUint16Int64
	return &r
}

type nodeMapuint16int64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int64 or int64)
}

// Return walking direction
func (c nodeMapuint16int64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int64) children() *[2]nodeMapuint16int64 {
	return (*[2]nodeMapuint16int64)(c.child)
}

func (c *nodeMapuint16int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int64) find(key uint16) (uint, *nodeMapuint16int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int64) SetP(key uint16, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int64) Set(key uint16, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int64) GetP(key uint16) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int64) Get(key uint16) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint16Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int64 struct {
	t     *MapUint16Int64
	nodes []*nodeMapuint16int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int64.
func (t *MapUint16Int64) Iterator() *IterUint16Int64 {
	var i IterUint16Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Int64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Int8 implements an associative array of int8 indexed by uint16.
type MapUint16Int8 struct {
	length int
	root   nodeMapuint16int8
}

func NewMapUint16Int8() *MapUint16Int8 {
	var r MapUint16Int8
	return &r
}

type nodeMapuint16int8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int8 or int8)
}

// Return walking direction
func (c nodeMapuint16int8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int8) children() *[2]nodeMapuint16int8 {
	return (*[2]nodeMapuint16int8)(c.child)
}

func (c *nodeMapuint16int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int8) find(key uint16) (uint, *nodeMapuint16int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int8) SetP(key uint16, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int8) Set(key uint16, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int8) GetP(key uint16) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int8) Get(key uint16) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint16Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int8 struct {
	t     *MapUint16Int8
	nodes []*nodeMapuint16int8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int8.
func (t *MapUint16Int8) Iterator() *IterUint16Int8 {
	var i IterUint16Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Int8) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Rune implements an associative array of rune indexed by uint16.
type MapUint16Rune struct {
	length int
	root   nodeMapuint16rune
}

func NewMapUint16Rune() *MapUint16Rune {
	var r MapUint16Rune
	return &r
}

type nodeMapuint16rune struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16rune or rune)
}

// Return walking direction
func (c nodeMapuint16rune) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16rune) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16rune) children() *[2]nodeMapuint16rune {
	return (*[2]nodeMapuint16rune)(c.child)
}

func (c *nodeMapuint16rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16rune) find(key uint16) (uint, *nodeMapuint16rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Rune) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Rune) SetP(key uint16, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Rune) Set(key uint16, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Rune) GetP(key uint16) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Rune) Get(key uint16) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint16Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Rune struct {
	t     *MapUint16Rune
	nodes []*nodeMapuint16rune
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Rune.
func (t *MapUint16Rune) Iterator() *IterUint16Rune {
	var i IterUint16Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Rune) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16String implements an associative array of string indexed by uint16.
type MapUint16String struct {
	length int
	root   nodeMapuint16string
}

func NewMapUint16String() *MapUint16String {
	var r MapUint16String
	return &r
}

type nodeMapuint16string struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16string or string)
}

// Return walking direction
func (c nodeMapuint16string) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16string) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16string) children() *[2]nodeMapuint16string {
	return (*[2]nodeMapuint16string)(c.child)
}

func (c *nodeMapuint16string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16string) find(key uint16) (uint, *nodeMapuint16string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16String) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16String) SetP(key uint16, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16String) Set(key uint16, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16String) GetP(key uint16) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16String) Get(key uint16) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16String) Length() int {
	return t.length
}

// func (c *nodeMapuint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint16String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16String struct {
	t     *MapUint16String
	nodes []*nodeMapuint16string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16  // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16String.
func (t *MapUint16String) Iterator() *IterUint16String {
	var i IterUint16String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16String) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uint implements an associative array of uint indexed by uint16.
type MapUint16Uint struct {
	length int
	root   nodeMapuint16uint
}

func NewMapUint16Uint() *MapUint16Uint {
	var r MapUint16Uint
	return &r
}

type nodeMapuint16uint struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint or uint)
}

// Return walking direction
func (c nodeMapuint16uint) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint) children() *[2]nodeMapuint16uint {
	return (*[2]nodeMapuint16uint)(c.child)
}

func (c *nodeMapuint16uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint) find(key uint16) (uint, *nodeMapuint16uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint) SetP(key uint16, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint) Set(key uint16, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint) GetP(key uint16) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint) Get(key uint16) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint16Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint struct {
	t     *MapUint16Uint
	nodes []*nodeMapuint16uint
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint.
func (t *MapUint16Uint) Iterator() *IterUint16Uint {
	var i IterUint16Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uint) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uint16 implements an associative array of uint16 indexed by uint16.
type MapUint16Uint16 struct {
	length int
	root   nodeMapuint16uint16
}

func NewMapUint16Uint16() *MapUint16Uint16 {
	var r MapUint16Uint16
	return &r
}

type nodeMapuint16uint16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint16uint16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint16) children() *[2]nodeMapuint16uint16 {
	return (*[2]nodeMapuint16uint16)(c.child)
}

func (c *nodeMapuint16uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint16) find(key uint16) (uint, *nodeMapuint16uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint16) SetP(key uint16, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint16) Set(key uint16, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint16) GetP(key uint16) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint16) Get(key uint16) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint16Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint16 struct {
	t     *MapUint16Uint16
	nodes []*nodeMapuint16uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16  // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint16.
func (t *MapUint16Uint16) Iterator() *IterUint16Uint16 {
	var i IterUint16Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uint16) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uint32 implements an associative array of uint32 indexed by uint16.
type MapUint16Uint32 struct {
	length int
	root   nodeMapuint16uint32
}

func NewMapUint16Uint32() *MapUint16Uint32 {
	var r MapUint16Uint32
	return &r
}

type nodeMapuint16uint32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint16uint32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint32) children() *[2]nodeMapuint16uint32 {
	return (*[2]nodeMapuint16uint32)(c.child)
}

func (c *nodeMapuint16uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint32) find(key uint16) (uint, *nodeMapuint16uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint32) SetP(key uint16, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint32) Set(key uint16, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint32) GetP(key uint16) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint32) Get(key uint16) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint16Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint32 struct {
	t     *MapUint16Uint32
	nodes []*nodeMapuint16uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16  // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint32.
func (t *MapUint16Uint32) Iterator() *IterUint16Uint32 {
	var i IterUint16Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uint32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uint64 implements an associative array of uint64 indexed by uint16.
type MapUint16Uint64 struct {
	length int
	root   nodeMapuint16uint64
}

func NewMapUint16Uint64() *MapUint16Uint64 {
	var r MapUint16Uint64
	return &r
}

type nodeMapuint16uint64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint16uint64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint64) children() *[2]nodeMapuint16uint64 {
	return (*[2]nodeMapuint16uint64)(c.child)
}

func (c *nodeMapuint16uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint64) find(key uint16) (uint, *nodeMapuint16uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint64) SetP(key uint16, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint64) Set(key uint16, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint64) GetP(key uint16) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint64) Get(key uint16) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint16Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint64 struct {
	t     *MapUint16Uint64
	nodes []*nodeMapuint16uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16  // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint64.
func (t *MapUint16Uint64) Iterator() *IterUint16Uint64 {
	var i IterUint16Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uint64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uint8 implements an associative array of uint8 indexed by uint16.
type MapUint16Uint8 struct {
	length int
	root   nodeMapuint16uint8
}

func NewMapUint16Uint8() *MapUint16Uint8 {
	var r MapUint16Uint8
	return &r
}

type nodeMapuint16uint8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint16uint8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint8) children() *[2]nodeMapuint16uint8 {
	return (*[2]nodeMapuint16uint8)(c.child)
}

func (c *nodeMapuint16uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint8) find(key uint16) (uint, *nodeMapuint16uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint8) SetP(key uint16, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint8) Set(key uint16, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint8) GetP(key uint16) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint8) Get(key uint16) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint16Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint8 struct {
	t     *MapUint16Uint8
	nodes []*nodeMapuint16uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16 // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint8.
func (t *MapUint16Uint8) Iterator() *IterUint16Uint8 {
	var i IterUint16Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uint8) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint16Uintptr implements an associative array of uintptr indexed by uint16.
type MapUint16Uintptr struct {
	length int
	root   nodeMapuint16uintptr
}

func NewMapUint16Uintptr() *MapUint16Uintptr {
	var r MapUint16Uintptr
	return &r
}

type nodeMapuint16uintptr struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint16uintptr) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uintptr) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uintptr) children() *[2]nodeMapuint16uintptr {
	return (*[2]nodeMapuint16uintptr)(c.child)
}

func (c *nodeMapuint16uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uintptr) find(key uint16) (uint, *nodeMapuint16uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uintptr) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uintptr) SetP(key uint16, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uintptr) Set(key uint16, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uintptr) GetP(key uint16) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uintptr) Get(key uint16) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint16Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uintptr struct {
	t     *MapUint16Uintptr
	nodes []*nodeMapuint16uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint16   // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uintptr.
func (t *MapUint16Uintptr) Iterator() *IterUint16Uintptr {
	var i IterUint16Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint16Uintptr) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint16Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint16Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint16Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint16uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint16uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Bool implements an associative array of bool indexed by uint8.
type MapUint8Bool struct {
	length int
	root   nodeMapuint8bool
}

func NewMapUint8Bool() *MapUint8Bool {
	var r MapUint8Bool
	return &r
}

type nodeMapuint8bool struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8bool or bool)
}

// Return walking direction
func (c nodeMapuint8bool) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8bool) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8bool) children() *[2]nodeMapuint8bool {
	return (*[2]nodeMapuint8bool)(c.child)
}

func (c *nodeMapuint8bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8bool) find(key uint8) (uint, *nodeMapuint8bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Bool) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Bool) SetP(key uint8, val *bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Bool) Set(key uint8, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Bool) GetP(key uint8) (*bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Bool) Get(key uint8) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint8Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Bool struct {
	t     *MapUint8Bool
	nodes []*nodeMapuint8bool
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Bool.
func (t *MapUint8Bool) Iterator() *IterUint8Bool {
	var i IterUint8Bool
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Bool) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8bool, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Bool) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Bool) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8bool)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8bool)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8bool)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Byte implements an associative array of byte indexed by uint8.
type MapUint8Byte struct {
	length int
	root   nodeMapuint8byte
}

func NewMapUint8Byte() *MapUint8Byte {
	var r MapUint8Byte
	return &r
}

type nodeMapuint8byte struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8byte or byte)
}

// Return walking direction
func (c nodeMapuint8byte) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8byte) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8byte) children() *[2]nodeMapuint8byte {
	return (*[2]nodeMapuint8byte)(c.child)
}

func (c *nodeMapuint8byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8byte) find(key uint8) (uint, *nodeMapuint8byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Byte) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Byte) SetP(key uint8, val *byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Byte) Set(key uint8, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Byte) GetP(key uint8) (*byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Byte) Get(key uint8) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint8Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Byte struct {
	t     *MapUint8Byte
	nodes []*nodeMapuint8byte
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Byte.
func (t *MapUint8Byte) Iterator() *IterUint8Byte {
	var i IterUint8Byte
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Byte) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8byte, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Byte) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Byte) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8byte)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8byte)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8byte)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Complex128 implements an associative array of complex128 indexed by uint8.
type MapUint8Complex128 struct {
	length int
	root   nodeMapuint8complex128
}

func NewMapUint8Complex128() *MapUint8Complex128 {
	var r MapUint8Complex128
	return &r
}

type nodeMapuint8complex128 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint8complex128) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex128) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8complex128) children() *[2]nodeMapuint8complex128 {
	return (*[2]nodeMapuint8complex128)(c.child)
}

func (c *nodeMapuint8complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8complex128) find(key uint8) (uint, *nodeMapuint8complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Complex128) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Complex128) SetP(key uint8, val *complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Complex128) Set(key uint8, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Complex128) GetP(key uint8) (*complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Complex128) Get(key uint8) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint8Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Complex128 struct {
	t     *MapUint8Complex128
	nodes []*nodeMapuint8complex128
	Found bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8       // Key found by last call to Next, Prev.
	Value *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Complex128.
func (t *MapUint8Complex128) Iterator() *IterUint8Complex128 {
	var i IterUint8Complex128
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Complex128) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8complex128, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Complex128) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Complex128) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8complex128)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8complex128)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8complex128)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Complex64 implements an associative array of complex64 indexed by uint8.
type MapUint8Complex64 struct {
	length int
	root   nodeMapuint8complex64
}

func NewMapUint8Complex64() *MapUint8Complex64 {
	var r MapUint8Complex64
	return &r
}

type nodeMapuint8complex64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint8complex64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8complex64) children() *[2]nodeMapuint8complex64 {
	return (*[2]nodeMapuint8complex64)(c.child)
}

func (c *nodeMapuint8complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8complex64) find(key uint8) (uint, *nodeMapuint8complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Complex64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Complex64) SetP(key uint8, val *complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Complex64) Set(key uint8, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Complex64) GetP(key uint8) (*complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Complex64) Get(key uint8) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint8Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Complex64 struct {
	t     *MapUint8Complex64
	nodes []*nodeMapuint8complex64
	Found bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8      // Key found by last call to Next, Prev.
	Value *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Complex64.
func (t *MapUint8Complex64) Iterator() *IterUint8Complex64 {
	var i IterUint8Complex64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Complex64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8complex64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Complex64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Complex64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8complex64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8complex64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8complex64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Error implements an associative array of error indexed by uint8.
type MapUint8Error struct {
	length int
	root   nodeMapuint8error
}

func NewMapUint8Error() *MapUint8Error {
	var r MapUint8Error
	return &r
}

type nodeMapuint8error struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8error or error)
}

// Return walking direction
func (c nodeMapuint8error) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8error) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8error) children() *[2]nodeMapuint8error {
	return (*[2]nodeMapuint8error)(c.child)
}

func (c *nodeMapuint8error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8error) find(key uint8) (uint, *nodeMapuint8error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Error) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Error) SetP(key uint8, val *error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Error) Set(key uint8, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Error) GetP(key uint8) (*error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Error) Get(key uint8) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Error) Length() int {
	return t.length
}

// func (c *nodeMapuint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint8Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Error struct {
	t     *MapUint8Error
	nodes []*nodeMapuint8error
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8  // Key found by last call to Next, Prev.
	Value *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Error.
func (t *MapUint8Error) Iterator() *IterUint8Error {
	var i IterUint8Error
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Error) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8error, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Error) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Error) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8error)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8error)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8error)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Float32 implements an associative array of float32 indexed by uint8.
type MapUint8Float32 struct {
	length int
	root   nodeMapuint8float32
}

func NewMapUint8Float32() *MapUint8Float32 {
	var r MapUint8Float32
	return &r
}

type nodeMapuint8float32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float32 or float32)
}

// Return walking direction
func (c nodeMapuint8float32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8float32) children() *[2]nodeMapuint8float32 {
	return (*[2]nodeMapuint8float32)(c.child)
}

func (c *nodeMapuint8float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8float32) find(key uint8) (uint, *nodeMapuint8float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Float32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Float32) SetP(key uint8, val *float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Float32) Set(key uint8, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Float32) GetP(key uint8) (*float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Float32) Get(key uint8) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint8Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Float32 struct {
	t     *MapUint8Float32
	nodes []*nodeMapuint8float32
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8    // Key found by last call to Next, Prev.
	Value *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Float32.
func (t *MapUint8Float32) Iterator() *IterUint8Float32 {
	var i IterUint8Float32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Float32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8float32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Float32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Float32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8float32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8float32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8float32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Float64 implements an associative array of float64 indexed by uint8.
type MapUint8Float64 struct {
	length int
	root   nodeMapuint8float64
}

func NewMapUint8Float64() *MapUint8Float64 {
	var r MapUint8Float64
	return &r
}

type nodeMapuint8float64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float64 or float64)
}

// Return walking direction
func (c nodeMapuint8float64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8float64) children() *[2]nodeMapuint8float64 {
	return (*[2]nodeMapuint8float64)(c.child)
}

func (c *nodeMapuint8float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8float64) find(key uint8) (uint, *nodeMapuint8float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Float64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Float64) SetP(key uint8, val *float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Float64) Set(key uint8, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Float64) GetP(key uint8) (*float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Float64) Get(key uint8) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint8Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Float64 struct {
	t     *MapUint8Float64
	nodes []*nodeMapuint8float64
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8    // Key found by last call to Next, Prev.
	Value *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Float64.
func (t *MapUint8Float64) Iterator() *IterUint8Float64 {
	var i IterUint8Float64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Float64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8float64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Float64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Float64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8float64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8float64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8float64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Int implements an associative array of int indexed by uint8.
type MapUint8Int struct {
	length int
	root   nodeMapuint8int
}

func NewMapUint8Int() *MapUint8Int {
	var r MapUint8Int
	return &r
}

type nodeMapuint8int struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int or int)
}

// Return walking direction
func (c nodeMapuint8int) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int) children() *[2]nodeMapuint8int {
	return (*[2]nodeMapuint8int)(c.child)
}

func (c *nodeMapuint8int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int) find(key uint8) (uint, *nodeMapuint8int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int) SetP(key uint8, val *int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int) Set(key uint8, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int) GetP(key uint8) (*int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int) Get(key uint8) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int) Length() int {
	return t.length
}

// func (c *nodeMapuint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint8Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int struct {
	t     *MapUint8Int
	nodes []*nodeMapuint8int
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int.
func (t *MapUint8Int) Iterator() *IterUint8Int {
	var i IterUint8Int
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Int) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Int) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Int) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8int)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8int)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Int16 implements an associative array of int16 indexed by uint8.
type MapUint8Int16 struct {
	length int
	root   nodeMapuint8int16
}

func NewMapUint8Int16() *MapUint8Int16 {
	var r MapUint8Int16
	return &r
}

type nodeMapuint8int16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int16 or int16)
}

// Return walking direction
func (c nodeMapuint8int16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int16) children() *[2]nodeMapuint8int16 {
	return (*[2]nodeMapuint8int16)(c.child)
}

func (c *nodeMapuint8int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int16) find(key uint8) (uint, *nodeMapuint8int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int16) SetP(key uint8, val *int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int16) Set(key uint8, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int16) GetP(key uint8) (*int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int16) Get(key uint8) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint8Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int16 struct {
	t     *MapUint8Int16
	nodes []*nodeMapuint8int16
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8  // Key found by last call to Next, Prev.
	Value *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int16.
func (t *MapUint8Int16) Iterator() *IterUint8Int16 {
	var i IterUint8Int16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Int16) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Int16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Int16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8int16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8int16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Int32 implements an associative array of int32 indexed by uint8.
type MapUint8Int32 struct {
	length int
	root   nodeMapuint8int32
}

func NewMapUint8Int32() *MapUint8Int32 {
	var r MapUint8Int32
	return &r
}

type nodeMapuint8int32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int32 or int32)
}

// Return walking direction
func (c nodeMapuint8int32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int32) children() *[2]nodeMapuint8int32 {
	return (*[2]nodeMapuint8int32)(c.child)
}

func (c *nodeMapuint8int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int32) find(key uint8) (uint, *nodeMapuint8int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int32) SetP(key uint8, val *int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int32) Set(key uint8, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int32) GetP(key uint8) (*int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int32) Get(key uint8) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint8Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int32 struct {
	t     *MapUint8Int32
	nodes []*nodeMapuint8int32
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8  // Key found by last call to Next, Prev.
	Value *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int32.
func (t *MapUint8Int32) Iterator() *IterUint8Int32 {
	var i IterUint8Int32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Int32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Int32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Int32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8int32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8int32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Int64 implements an associative array of int64 indexed by uint8.
type MapUint8Int64 struct {
	length int
	root   nodeMapuint8int64
}

func NewMapUint8Int64() *MapUint8Int64 {
	var r MapUint8Int64
	return &r
}

type nodeMapuint8int64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int64 or int64)
}

// Return walking direction
func (c nodeMapuint8int64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int64) children() *[2]nodeMapuint8int64 {
	return (*[2]nodeMapuint8int64)(c.child)
}

func (c *nodeMapuint8int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int64) find(key uint8) (uint, *nodeMapuint8int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int64) SetP(key uint8, val *int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int64) Set(key uint8, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int64) GetP(key uint8) (*int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int64) Get(key uint8) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint8Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int64 struct {
	t     *MapUint8Int64
	nodes []*nodeMapuint8int64
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8  // Key found by last call to Next, Prev.
	Value *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int64.
func (t *MapUint8Int64) Iterator() *IterUint8Int64 {
	var i IterUint8Int64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Int64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Int64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Int64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8int64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8int64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Int8 implements an associative array of int8 indexed by uint8.
type MapUint8Int8 struct {
	length int
	root   nodeMapuint8int8
}

func NewMapUint8Int8() *MapUint8Int8 {
	var r MapUint8Int8
	return &r
}

type nodeMapuint8int8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int8 or int8)
}

// Return walking direction
func (c nodeMapuint8int8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int8) children() *[2]nodeMapuint8int8 {
	return (*[2]nodeMapuint8int8)(c.child)
}

func (c *nodeMapuint8int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int8) find(key uint8) (uint, *nodeMapuint8int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int8) SetP(key uint8, val *int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int8) Set(key uint8, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int8) GetP(key uint8) (*int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int8) Get(key uint8) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint8Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int8 struct {
	t     *MapUint8Int8
	nodes []*nodeMapuint8int8
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int8.
func (t *MapUint8Int8) Iterator() *IterUint8Int8 {
	var i IterUint8Int8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Int8) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Int8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Int8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8int8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8int8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Rune implements an associative array of rune indexed by uint8.
type MapUint8Rune struct {
	length int
	root   nodeMapuint8rune
}

func NewMapUint8Rune() *MapUint8Rune {
	var r MapUint8Rune
	return &r
}

type nodeMapuint8rune struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8rune or rune)
}

// Return walking direction
func (c nodeMapuint8rune) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8rune) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8rune) children() *[2]nodeMapuint8rune {
	return (*[2]nodeMapuint8rune)(c.child)
}

func (c *nodeMapuint8rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8rune) find(key uint8) (uint, *nodeMapuint8rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Rune) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Rune) SetP(key uint8, val *rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Rune) Set(key uint8, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Rune) GetP(key uint8) (*rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Rune) Get(key uint8) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint8Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Rune struct {
	t     *MapUint8Rune
	nodes []*nodeMapuint8rune
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Rune.
func (t *MapUint8Rune) Iterator() *IterUint8Rune {
	var i IterUint8Rune
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Rune) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8rune, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Rune) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Rune) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8rune)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8rune)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8rune)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8String implements an associative array of string indexed by uint8.
type MapUint8String struct {
	length int
	root   nodeMapuint8string
}

func NewMapUint8String() *MapUint8String {
	var r MapUint8String
	return &r
}

type nodeMapuint8string struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8string or string)
}

// Return walking direction
func (c nodeMapuint8string) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8string) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8string) children() *[2]nodeMapuint8string {
	return (*[2]nodeMapuint8string)(c.child)
}

func (c *nodeMapuint8string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8string) find(key uint8) (uint, *nodeMapuint8string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8String) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8String) SetP(key uint8, val *string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8String) Set(key uint8, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8String) GetP(key uint8) (*string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8String) Get(key uint8) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8String) Length() int {
	return t.length
}

// func (c *nodeMapuint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint8String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8String struct {
	t     *MapUint8String
	nodes []*nodeMapuint8string
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8   // Key found by last call to Next, Prev.
	Value *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8String.
func (t *MapUint8String) Iterator() *IterUint8String {
	var i IterUint8String
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8String) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8string, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8String) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8String) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8string)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8string)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8string)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uint implements an associative array of uint indexed by uint8.
type MapUint8Uint struct {
	length int
	root   nodeMapuint8uint
}

func NewMapUint8Uint() *MapUint8Uint {
	var r MapUint8Uint
	return &r
}

type nodeMapuint8uint struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint or uint)
}

// Return walking direction
func (c nodeMapuint8uint) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint) children() *[2]nodeMapuint8uint {
	return (*[2]nodeMapuint8uint)(c.child)
}

func (c *nodeMapuint8uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint) find(key uint8) (uint, *nodeMapuint8uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint) SetP(key uint8, val *uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint) Set(key uint8, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint) GetP(key uint8) (*uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint) Get(key uint8) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint8Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint struct {
	t     *MapUint8Uint
	nodes []*nodeMapuint8uint
	Found bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8 // Key found by last call to Next, Prev.
	Value *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint.
func (t *MapUint8Uint) Iterator() *IterUint8Uint {
	var i IterUint8Uint
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uint) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uint) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uint) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uint)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uint)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uint16 implements an associative array of uint16 indexed by uint8.
type MapUint8Uint16 struct {
	length int
	root   nodeMapuint8uint16
}

func NewMapUint8Uint16() *MapUint8Uint16 {
	var r MapUint8Uint16
	return &r
}

type nodeMapuint8uint16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint8uint16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint16) children() *[2]nodeMapuint8uint16 {
	return (*[2]nodeMapuint8uint16)(c.child)
}

func (c *nodeMapuint8uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint16) find(key uint8) (uint, *nodeMapuint8uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint16) SetP(key uint8, val *uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint16) Set(key uint8, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint16) GetP(key uint8) (*uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint16) Get(key uint8) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint8Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint16 struct {
	t     *MapUint8Uint16
	nodes []*nodeMapuint8uint16
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8   // Key found by last call to Next, Prev.
	Value *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint16.
func (t *MapUint8Uint16) Iterator() *IterUint8Uint16 {
	var i IterUint8Uint16
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uint16) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint16, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uint16) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uint16) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint16)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uint16)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uint16)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uint32 implements an associative array of uint32 indexed by uint8.
type MapUint8Uint32 struct {
	length int
	root   nodeMapuint8uint32
}

func NewMapUint8Uint32() *MapUint8Uint32 {
	var r MapUint8Uint32
	return &r
}

type nodeMapuint8uint32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint8uint32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint32) children() *[2]nodeMapuint8uint32 {
	return (*[2]nodeMapuint8uint32)(c.child)
}

func (c *nodeMapuint8uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint32) find(key uint8) (uint, *nodeMapuint8uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint32) SetP(key uint8, val *uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint32) Set(key uint8, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint32) GetP(key uint8) (*uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint32) Get(key uint8) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint8Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint32 struct {
	t     *MapUint8Uint32
	nodes []*nodeMapuint8uint32
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8   // Key found by last call to Next, Prev.
	Value *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint32.
func (t *MapUint8Uint32) Iterator() *IterUint8Uint32 {
	var i IterUint8Uint32
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uint32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint32, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uint32) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uint32) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint32)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uint32)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uint32)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uint64 implements an associative array of uint64 indexed by uint8.
type MapUint8Uint64 struct {
	length int
	root   nodeMapuint8uint64
}

func NewMapUint8Uint64() *MapUint8Uint64 {
	var r MapUint8Uint64
	return &r
}

type nodeMapuint8uint64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint8uint64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint64) children() *[2]nodeMapuint8uint64 {
	return (*[2]nodeMapuint8uint64)(c.child)
}

func (c *nodeMapuint8uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint64) find(key uint8) (uint, *nodeMapuint8uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint64) SetP(key uint8, val *uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint64) Set(key uint8, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint64) GetP(key uint8) (*uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint64) Get(key uint8) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint8Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint64 struct {
	t     *MapUint8Uint64
	nodes []*nodeMapuint8uint64
	Found bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8   // Key found by last call to Next, Prev.
	Value *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint64.
func (t *MapUint8Uint64) Iterator() *IterUint8Uint64 {
	var i IterUint8Uint64
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uint64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint64, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uint64) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uint64) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint64)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uint64)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uint64)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uint8 implements an associative array of uint8 indexed by uint8.
type MapUint8Uint8 struct {
	length int
	root   nodeMapuint8uint8
}

func NewMapUint8Uint8() *MapUint8Uint8 {
	var r MapUint8Uint8
	return &r
}

type nodeMapuint8uint8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint8uint8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint8) children() *[2]nodeMapuint8uint8 {
	return (*[2]nodeMapuint8uint8)(c.child)
}

func (c *nodeMapuint8uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint8) find(key uint8) (uint, *nodeMapuint8uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint8) SetP(key uint8, val *uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint8) Set(key uint8, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint8) GetP(key uint8) (*uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint8) Get(key uint8) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint8Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint8 struct {
	t     *MapUint8Uint8
	nodes []*nodeMapuint8uint8
	Found bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8  // Key found by last call to Next, Prev.
	Value *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint8.
func (t *MapUint8Uint8) Iterator() *IterUint8Uint8 {
	var i IterUint8Uint8
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uint8) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint8, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uint8) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uint8) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint8)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uint8)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uint8)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}

// MapUint8Uintptr implements an associative array of uintptr indexed by uint8.
type MapUint8Uintptr struct {
	length int
	root   nodeMapuint8uintptr
}

func NewMapUint8Uintptr() *MapUint8Uintptr {
	var r MapUint8Uintptr
	return &r
}

type nodeMapuint8uintptr struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint8uintptr) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uintptr) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uintptr) children() *[2]nodeMapuint8uintptr {
	return (*[2]nodeMapuint8uintptr)(c.child)
}

func (c *nodeMapuint8uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uintptr) find(key uint8) (uint, *nodeMapuint8uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(c.children())[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uintptr) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uintptr) SetP(key uint8, val *uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uintptr) Set(key uint8, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uintptr) GetP(key uint8) (*uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uintptr) Get(key uint8) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint8Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uintptr struct {
	t     *MapUint8Uintptr
	nodes []*nodeMapuint8uintptr
	Found bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key   uint8    // Key found by last call to Next, Prev.
	Value *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uintptr.
func (t *MapUint8Uintptr) Iterator() *IterUint8Uintptr {
	var i IterUint8Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Jump advances the iterator to the specified key, independent of current state. If the exact key is found
// it returns true, otherwise false. Independent of whether the key is found or not, the next call to Prev or Next
// will advance the iterator to the next lower or higher key if there is one.
func (i *IterUint8Uintptr) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	//var crit = c.findCrit(key)
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		i.nodes = i.nodes[0 : len(i.nodes)-1]
	}
}

// Reset restores the initial state.
func (i *IterUint8Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uintptr, 0, 64)
	}
	if i.t.length > 0 {
		i.nodes = i.nodes[0:1]
		i.nodes[0] = &i.t.root
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is True unless there is no next higher key to advance to.
func (i *IterUint8Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

func (i *IterUint8Uintptr) step(dir int) {
	// Comments describe behavior with dir == 1 (iterate from left to right).
	i.Found = false
	if len(i.nodes) == 0 { // Invalid
		return
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uintptr)(next.child)[1-dir]
		i.nodes = append(i.nodes, next)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	i.Found = true
	// Go up until a left node is found. Then one to the right if there is one.
	var d = len(i.nodes)
	var last = i.nodes[d-1]
	for d > 1 {
		var previous = i.nodes[d-2]
		if &(*[2]nodeMapuint8uintptr)(previous.child)[1-dir] == last {
			// Found left node. Replace with right node.
			i.nodes[d-1] = &(*[2]nodeMapuint8uintptr)(previous.child)[dir]
			i.nodes = i.nodes[0:d]
			return
		}
		last = previous
		i.nodes[d-1] = nil // Help gc
		d--
	}
	i.nodes = i.nodes[0:0]
}
