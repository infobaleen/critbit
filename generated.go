// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package critbit

import "unsafe"

// MapIntBool implements an associative array of bool indexed by int.
type MapIntBool struct {
	length int
	root   nodeMapintbool
}

type nodeMapintbool struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbool or bool)
}

// Return walking direction
func (c nodeMapintbool) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbool) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintbool) find(key int) (uint, *nodeMapintbool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintbool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntBool) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntBool) Set(key int, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntBool) Get(key int) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntBool) Length() int {
	return t.length
}

// func (c *nodeMapintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterIntBool struct {
	t     *MapIntBool
	nodes []*nodeMapintbool
	Key   int
	Value *bool
}

// Iterator returns a new IterIntBool.
func (t *MapIntBool) Iterator() *IterIntBool {
	var i IterIntBool
	i.t = t
	return &i
}

func (i *IterIntBool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintbool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintbool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintbool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintbool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintbool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapIntByte implements an associative array of byte indexed by int.
type MapIntByte struct {
	length int
	root   nodeMapintbyte
}

type nodeMapintbyte struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbyte or byte)
}

// Return walking direction
func (c nodeMapintbyte) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbyte) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintbyte) find(key int) (uint, *nodeMapintbyte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintbyte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntByte) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntByte) Set(key int, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntByte) Get(key int) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntByte) Length() int {
	return t.length
}

// func (c *nodeMapintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterIntByte struct {
	t     *MapIntByte
	nodes []*nodeMapintbyte
	Key   int
	Value *byte
}

// Iterator returns a new IterIntByte.
func (t *MapIntByte) Iterator() *IterIntByte {
	var i IterIntByte
	i.t = t
	return &i
}

func (i *IterIntByte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintbyte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintbyte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintbyte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintbyte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintbyte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapIntComplex128 implements an associative array of complex128 indexed by int.
type MapIntComplex128 struct {
	length int
	root   nodeMapintcomplex128
}

type nodeMapintcomplex128 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapintcomplex128) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex128) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintcomplex128) find(key int) (uint, *nodeMapintcomplex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintcomplex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntComplex128) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntComplex128) Set(key int, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntComplex128) Get(key int) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex128) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterIntComplex128 struct {
	t     *MapIntComplex128
	nodes []*nodeMapintcomplex128
	Key   int
	Value *complex128
}

// Iterator returns a new IterIntComplex128.
func (t *MapIntComplex128) Iterator() *IterIntComplex128 {
	var i IterIntComplex128
	i.t = t
	return &i
}

func (i *IterIntComplex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintcomplex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintcomplex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintcomplex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintcomplex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintcomplex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapIntComplex64 implements an associative array of complex64 indexed by int.
type MapIntComplex64 struct {
	length int
	root   nodeMapintcomplex64
}

type nodeMapintcomplex64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapintcomplex64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintcomplex64) find(key int) (uint, *nodeMapintcomplex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintcomplex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntComplex64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntComplex64) Set(key int, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntComplex64) Get(key int) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex64) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterIntComplex64 struct {
	t     *MapIntComplex64
	nodes []*nodeMapintcomplex64
	Key   int
	Value *complex64
}

// Iterator returns a new IterIntComplex64.
func (t *MapIntComplex64) Iterator() *IterIntComplex64 {
	var i IterIntComplex64
	i.t = t
	return &i
}

func (i *IterIntComplex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintcomplex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintcomplex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintcomplex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintcomplex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintcomplex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapIntError implements an associative array of error indexed by int.
type MapIntError struct {
	length int
	root   nodeMapinterror
}

type nodeMapinterror struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapinterror or error)
}

// Return walking direction
func (c nodeMapinterror) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapinterror) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapinterror) find(key int) (uint, *nodeMapinterror) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapinterror)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntError) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntError) Set(key int, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntError) Get(key int) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntError) Length() int {
	return t.length
}

// func (c *nodeMapinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterIntError struct {
	t     *MapIntError
	nodes []*nodeMapinterror
	Key   int
	Value *error
}

// Iterator returns a new IterIntError.
func (t *MapIntError) Iterator() *IterIntError {
	var i IterIntError
	i.t = t
	return &i
}

func (i *IterIntError) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapinterror, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapinterror)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapinterror)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapinterror = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapinterror)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapIntFloat32 implements an associative array of float32 indexed by int.
type MapIntFloat32 struct {
	length int
	root   nodeMapintfloat32
}

type nodeMapintfloat32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat32 or float32)
}

// Return walking direction
func (c nodeMapintfloat32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintfloat32) find(key int) (uint, *nodeMapintfloat32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintfloat32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntFloat32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntFloat32) Set(key int, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntFloat32) Get(key int) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat32) Length() int {
	return t.length
}

// func (c *nodeMapintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterIntFloat32 struct {
	t     *MapIntFloat32
	nodes []*nodeMapintfloat32
	Key   int
	Value *float32
}

// Iterator returns a new IterIntFloat32.
func (t *MapIntFloat32) Iterator() *IterIntFloat32 {
	var i IterIntFloat32
	i.t = t
	return &i
}

func (i *IterIntFloat32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintfloat32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintfloat32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintfloat32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintfloat32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintfloat32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapIntFloat64 implements an associative array of float64 indexed by int.
type MapIntFloat64 struct {
	length int
	root   nodeMapintfloat64
}

type nodeMapintfloat64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat64 or float64)
}

// Return walking direction
func (c nodeMapintfloat64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintfloat64) find(key int) (uint, *nodeMapintfloat64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintfloat64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntFloat64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntFloat64) Set(key int, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntFloat64) Get(key int) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat64) Length() int {
	return t.length
}

// func (c *nodeMapintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterIntFloat64 struct {
	t     *MapIntFloat64
	nodes []*nodeMapintfloat64
	Key   int
	Value *float64
}

// Iterator returns a new IterIntFloat64.
func (t *MapIntFloat64) Iterator() *IterIntFloat64 {
	var i IterIntFloat64
	i.t = t
	return &i
}

func (i *IterIntFloat64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintfloat64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintfloat64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintfloat64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintfloat64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintfloat64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapIntInt implements an associative array of int indexed by int.
type MapIntInt struct {
	length int
	root   nodeMapintint
}

type nodeMapintint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint or int)
}

// Return walking direction
func (c nodeMapintint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint) find(key int) (uint, *nodeMapintint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntInt) Set(key int, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntInt) Get(key int) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt) Length() int {
	return t.length
}

// func (c *nodeMapintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterIntInt struct {
	t     *MapIntInt
	nodes []*nodeMapintint
	Key   int
	Value *int
}

// Iterator returns a new IterIntInt.
func (t *MapIntInt) Iterator() *IterIntInt {
	var i IterIntInt
	i.t = t
	return &i
}

func (i *IterIntInt) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapIntInt16 implements an associative array of int16 indexed by int.
type MapIntInt16 struct {
	length int
	root   nodeMapintint16
}

type nodeMapintint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint16 or int16)
}

// Return walking direction
func (c nodeMapintint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint16) find(key int) (uint, *nodeMapintint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntInt16) Set(key int, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntInt16) Get(key int) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt16) Length() int {
	return t.length
}

// func (c *nodeMapintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterIntInt16 struct {
	t     *MapIntInt16
	nodes []*nodeMapintint16
	Key   int
	Value *int16
}

// Iterator returns a new IterIntInt16.
func (t *MapIntInt16) Iterator() *IterIntInt16 {
	var i IterIntInt16
	i.t = t
	return &i
}

func (i *IterIntInt16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapIntInt32 implements an associative array of int32 indexed by int.
type MapIntInt32 struct {
	length int
	root   nodeMapintint32
}

type nodeMapintint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint32 or int32)
}

// Return walking direction
func (c nodeMapintint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint32) find(key int) (uint, *nodeMapintint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntInt32) Set(key int, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntInt32) Get(key int) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt32) Length() int {
	return t.length
}

// func (c *nodeMapintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterIntInt32 struct {
	t     *MapIntInt32
	nodes []*nodeMapintint32
	Key   int
	Value *int32
}

// Iterator returns a new IterIntInt32.
func (t *MapIntInt32) Iterator() *IterIntInt32 {
	var i IterIntInt32
	i.t = t
	return &i
}

func (i *IterIntInt32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapIntInt64 implements an associative array of int64 indexed by int.
type MapIntInt64 struct {
	length int
	root   nodeMapintint64
}

type nodeMapintint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint64 or int64)
}

// Return walking direction
func (c nodeMapintint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint64) find(key int) (uint, *nodeMapintint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntInt64) Set(key int, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntInt64) Get(key int) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt64) Length() int {
	return t.length
}

// func (c *nodeMapintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterIntInt64 struct {
	t     *MapIntInt64
	nodes []*nodeMapintint64
	Key   int
	Value *int64
}

// Iterator returns a new IterIntInt64.
func (t *MapIntInt64) Iterator() *IterIntInt64 {
	var i IterIntInt64
	i.t = t
	return &i
}

func (i *IterIntInt64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapIntInt8 implements an associative array of int8 indexed by int.
type MapIntInt8 struct {
	length int
	root   nodeMapintint8
}

type nodeMapintint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint8 or int8)
}

// Return walking direction
func (c nodeMapintint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintint8) find(key int) (uint, *nodeMapintint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntInt8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntInt8) Set(key int, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntInt8) Get(key int) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt8) Length() int {
	return t.length
}

// func (c *nodeMapintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterIntInt8 struct {
	t     *MapIntInt8
	nodes []*nodeMapintint8
	Key   int
	Value *int8
}

// Iterator returns a new IterIntInt8.
func (t *MapIntInt8) Iterator() *IterIntInt8 {
	var i IterIntInt8
	i.t = t
	return &i
}

func (i *IterIntInt8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapIntRune implements an associative array of rune indexed by int.
type MapIntRune struct {
	length int
	root   nodeMapintrune
}

type nodeMapintrune struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintrune or rune)
}

// Return walking direction
func (c nodeMapintrune) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintrune) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintrune) find(key int) (uint, *nodeMapintrune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintrune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntRune) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntRune) Set(key int, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntRune) Get(key int) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntRune) Length() int {
	return t.length
}

// func (c *nodeMapintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterIntRune struct {
	t     *MapIntRune
	nodes []*nodeMapintrune
	Key   int
	Value *rune
}

// Iterator returns a new IterIntRune.
func (t *MapIntRune) Iterator() *IterIntRune {
	var i IterIntRune
	i.t = t
	return &i
}

func (i *IterIntRune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintrune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintrune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintrune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintrune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintrune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapIntString implements an associative array of string indexed by int.
type MapIntString struct {
	length int
	root   nodeMapintstring
}

type nodeMapintstring struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintstring or string)
}

// Return walking direction
func (c nodeMapintstring) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintstring) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintstring) find(key int) (uint, *nodeMapintstring) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintstring)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntString) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntString) Set(key int, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntString) Get(key int) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntString) Length() int {
	return t.length
}

// func (c *nodeMapintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterIntString struct {
	t     *MapIntString
	nodes []*nodeMapintstring
	Key   int
	Value *string
}

// Iterator returns a new IterIntString.
func (t *MapIntString) Iterator() *IterIntString {
	var i IterIntString
	i.t = t
	return &i
}

func (i *IterIntString) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintstring, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintstring)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintstring)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintstring = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintstring)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapIntUint implements an associative array of uint indexed by int.
type MapIntUint struct {
	length int
	root   nodeMapintuint
}

type nodeMapintuint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint or uint)
}

// Return walking direction
func (c nodeMapintuint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint) find(key int) (uint, *nodeMapintuint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUint) Set(key int, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUint) Get(key int) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint) Length() int {
	return t.length
}

// func (c *nodeMapintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterIntUint struct {
	t     *MapIntUint
	nodes []*nodeMapintuint
	Key   int
	Value *uint
}

// Iterator returns a new IterIntUint.
func (t *MapIntUint) Iterator() *IterIntUint {
	var i IterIntUint
	i.t = t
	return &i
}

func (i *IterIntUint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapIntUint16 implements an associative array of uint16 indexed by int.
type MapIntUint16 struct {
	length int
	root   nodeMapintuint16
}

type nodeMapintuint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint16 or uint16)
}

// Return walking direction
func (c nodeMapintuint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint16) find(key int) (uint, *nodeMapintuint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUint16) Set(key int, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUint16) Get(key int) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint16) Length() int {
	return t.length
}

// func (c *nodeMapintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterIntUint16 struct {
	t     *MapIntUint16
	nodes []*nodeMapintuint16
	Key   int
	Value *uint16
}

// Iterator returns a new IterIntUint16.
func (t *MapIntUint16) Iterator() *IterIntUint16 {
	var i IterIntUint16
	i.t = t
	return &i
}

func (i *IterIntUint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapIntUint32 implements an associative array of uint32 indexed by int.
type MapIntUint32 struct {
	length int
	root   nodeMapintuint32
}

type nodeMapintuint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint32 or uint32)
}

// Return walking direction
func (c nodeMapintuint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint32) find(key int) (uint, *nodeMapintuint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUint32) Set(key int, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUint32) Get(key int) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint32) Length() int {
	return t.length
}

// func (c *nodeMapintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterIntUint32 struct {
	t     *MapIntUint32
	nodes []*nodeMapintuint32
	Key   int
	Value *uint32
}

// Iterator returns a new IterIntUint32.
func (t *MapIntUint32) Iterator() *IterIntUint32 {
	var i IterIntUint32
	i.t = t
	return &i
}

func (i *IterIntUint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapIntUint64 implements an associative array of uint64 indexed by int.
type MapIntUint64 struct {
	length int
	root   nodeMapintuint64
}

type nodeMapintuint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint64 or uint64)
}

// Return walking direction
func (c nodeMapintuint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint64) find(key int) (uint, *nodeMapintuint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUint64) Set(key int, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUint64) Get(key int) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint64) Length() int {
	return t.length
}

// func (c *nodeMapintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterIntUint64 struct {
	t     *MapIntUint64
	nodes []*nodeMapintuint64
	Key   int
	Value *uint64
}

// Iterator returns a new IterIntUint64.
func (t *MapIntUint64) Iterator() *IterIntUint64 {
	var i IterIntUint64
	i.t = t
	return &i
}

func (i *IterIntUint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapIntUint8 implements an associative array of uint8 indexed by int.
type MapIntUint8 struct {
	length int
	root   nodeMapintuint8
}

type nodeMapintuint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint8 or uint8)
}

// Return walking direction
func (c nodeMapintuint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuint8) find(key int) (uint, *nodeMapintuint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUint8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUint8) Set(key int, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUint8) Get(key int) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint8) Length() int {
	return t.length
}

// func (c *nodeMapintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterIntUint8 struct {
	t     *MapIntUint8
	nodes []*nodeMapintuint8
	Key   int
	Value *uint8
}

// Iterator returns a new IterIntUint8.
func (t *MapIntUint8) Iterator() *IterIntUint8 {
	var i IterIntUint8
	i.t = t
	return &i
}

func (i *IterIntUint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapIntUintptr implements an associative array of uintptr indexed by int.
type MapIntUintptr struct {
	length int
	root   nodeMapintuintptr
}

type nodeMapintuintptr struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapintuintptr) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuintptr) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapintuintptr) find(key int) (uint, *nodeMapintuintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapintuintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapIntUintptr) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapIntUintptr) Set(key int, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapIntUintptr) Get(key int) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUintptr) Length() int {
	return t.length
}

// func (c *nodeMapintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterIntUintptr struct {
	t     *MapIntUintptr
	nodes []*nodeMapintuintptr
	Key   int
	Value *uintptr
}

// Iterator returns a new IterIntUintptr.
func (t *MapIntUintptr) Iterator() *IterIntUintptr {
	var i IterIntUintptr
	i.t = t
	return &i
}

func (i *IterIntUintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapintuintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapintuintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapintuintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapintuintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapintuintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapInt64Bool implements an associative array of bool indexed by int64.
type MapInt64Bool struct {
	length int
	root   nodeMapint64bool
}

type nodeMapint64bool struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64bool or bool)
}

// Return walking direction
func (c nodeMapint64bool) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64bool) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64bool) find(key int64) (uint, *nodeMapint64bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Bool) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Bool) Set(key int64, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Bool) Get(key int64) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Bool) Length() int {
	return t.length
}

// func (c *nodeMapint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterInt64Bool struct {
	t     *MapInt64Bool
	nodes []*nodeMapint64bool
	Key   int64
	Value *bool
}

// Iterator returns a new IterInt64Bool.
func (t *MapInt64Bool) Iterator() *IterInt64Bool {
	var i IterInt64Bool
	i.t = t
	return &i
}

func (i *IterInt64Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapInt64Byte implements an associative array of byte indexed by int64.
type MapInt64Byte struct {
	length int
	root   nodeMapint64byte
}

type nodeMapint64byte struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64byte or byte)
}

// Return walking direction
func (c nodeMapint64byte) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64byte) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64byte) find(key int64) (uint, *nodeMapint64byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Byte) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Byte) Set(key int64, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Byte) Get(key int64) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Byte) Length() int {
	return t.length
}

// func (c *nodeMapint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterInt64Byte struct {
	t     *MapInt64Byte
	nodes []*nodeMapint64byte
	Key   int64
	Value *byte
}

// Iterator returns a new IterInt64Byte.
func (t *MapInt64Byte) Iterator() *IterInt64Byte {
	var i IterInt64Byte
	i.t = t
	return &i
}

func (i *IterInt64Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapInt64Complex128 implements an associative array of complex128 indexed by int64.
type MapInt64Complex128 struct {
	length int
	root   nodeMapint64complex128
}

type nodeMapint64complex128 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapint64complex128) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex128) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64complex128) find(key int64) (uint, *nodeMapint64complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Complex128) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Complex128) Set(key int64, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Complex128) Get(key int64) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterInt64Complex128 struct {
	t     *MapInt64Complex128
	nodes []*nodeMapint64complex128
	Key   int64
	Value *complex128
}

// Iterator returns a new IterInt64Complex128.
func (t *MapInt64Complex128) Iterator() *IterInt64Complex128 {
	var i IterInt64Complex128
	i.t = t
	return &i
}

func (i *IterInt64Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapInt64Complex64 implements an associative array of complex64 indexed by int64.
type MapInt64Complex64 struct {
	length int
	root   nodeMapint64complex64
}

type nodeMapint64complex64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapint64complex64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64complex64) find(key int64) (uint, *nodeMapint64complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Complex64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Complex64) Set(key int64, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Complex64) Get(key int64) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterInt64Complex64 struct {
	t     *MapInt64Complex64
	nodes []*nodeMapint64complex64
	Key   int64
	Value *complex64
}

// Iterator returns a new IterInt64Complex64.
func (t *MapInt64Complex64) Iterator() *IterInt64Complex64 {
	var i IterInt64Complex64
	i.t = t
	return &i
}

func (i *IterInt64Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapInt64Error implements an associative array of error indexed by int64.
type MapInt64Error struct {
	length int
	root   nodeMapint64error
}

type nodeMapint64error struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64error or error)
}

// Return walking direction
func (c nodeMapint64error) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64error) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64error) find(key int64) (uint, *nodeMapint64error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Error) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Error) Set(key int64, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Error) Get(key int64) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Error) Length() int {
	return t.length
}

// func (c *nodeMapint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterInt64Error struct {
	t     *MapInt64Error
	nodes []*nodeMapint64error
	Key   int64
	Value *error
}

// Iterator returns a new IterInt64Error.
func (t *MapInt64Error) Iterator() *IterInt64Error {
	var i IterInt64Error
	i.t = t
	return &i
}

func (i *IterInt64Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapInt64Float32 implements an associative array of float32 indexed by int64.
type MapInt64Float32 struct {
	length int
	root   nodeMapint64float32
}

type nodeMapint64float32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float32 or float32)
}

// Return walking direction
func (c nodeMapint64float32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64float32) find(key int64) (uint, *nodeMapint64float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Float32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Float32) Set(key int64, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Float32) Get(key int64) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float32) Length() int {
	return t.length
}

// func (c *nodeMapint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterInt64Float32 struct {
	t     *MapInt64Float32
	nodes []*nodeMapint64float32
	Key   int64
	Value *float32
}

// Iterator returns a new IterInt64Float32.
func (t *MapInt64Float32) Iterator() *IterInt64Float32 {
	var i IterInt64Float32
	i.t = t
	return &i
}

func (i *IterInt64Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapInt64Float64 implements an associative array of float64 indexed by int64.
type MapInt64Float64 struct {
	length int
	root   nodeMapint64float64
}

type nodeMapint64float64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float64 or float64)
}

// Return walking direction
func (c nodeMapint64float64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64float64) find(key int64) (uint, *nodeMapint64float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Float64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Float64) Set(key int64, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Float64) Get(key int64) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float64) Length() int {
	return t.length
}

// func (c *nodeMapint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterInt64Float64 struct {
	t     *MapInt64Float64
	nodes []*nodeMapint64float64
	Key   int64
	Value *float64
}

// Iterator returns a new IterInt64Float64.
func (t *MapInt64Float64) Iterator() *IterInt64Float64 {
	var i IterInt64Float64
	i.t = t
	return &i
}

func (i *IterInt64Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapInt64Int implements an associative array of int indexed by int64.
type MapInt64Int struct {
	length int
	root   nodeMapint64int
}

type nodeMapint64int struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int or int)
}

// Return walking direction
func (c nodeMapint64int) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int) find(key int64) (uint, *nodeMapint64int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Int) Set(key int64, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Int) Get(key int64) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int) Length() int {
	return t.length
}

// func (c *nodeMapint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterInt64Int struct {
	t     *MapInt64Int
	nodes []*nodeMapint64int
	Key   int64
	Value *int
}

// Iterator returns a new IterInt64Int.
func (t *MapInt64Int) Iterator() *IterInt64Int {
	var i IterInt64Int
	i.t = t
	return &i
}

func (i *IterInt64Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapInt64Int16 implements an associative array of int16 indexed by int64.
type MapInt64Int16 struct {
	length int
	root   nodeMapint64int16
}

type nodeMapint64int16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int16 or int16)
}

// Return walking direction
func (c nodeMapint64int16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int16) find(key int64) (uint, *nodeMapint64int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Int16) Set(key int64, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Int16) Get(key int64) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int16) Length() int {
	return t.length
}

// func (c *nodeMapint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterInt64Int16 struct {
	t     *MapInt64Int16
	nodes []*nodeMapint64int16
	Key   int64
	Value *int16
}

// Iterator returns a new IterInt64Int16.
func (t *MapInt64Int16) Iterator() *IterInt64Int16 {
	var i IterInt64Int16
	i.t = t
	return &i
}

func (i *IterInt64Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapInt64Int32 implements an associative array of int32 indexed by int64.
type MapInt64Int32 struct {
	length int
	root   nodeMapint64int32
}

type nodeMapint64int32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int32 or int32)
}

// Return walking direction
func (c nodeMapint64int32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int32) find(key int64) (uint, *nodeMapint64int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Int32) Set(key int64, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Int32) Get(key int64) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int32) Length() int {
	return t.length
}

// func (c *nodeMapint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterInt64Int32 struct {
	t     *MapInt64Int32
	nodes []*nodeMapint64int32
	Key   int64
	Value *int32
}

// Iterator returns a new IterInt64Int32.
func (t *MapInt64Int32) Iterator() *IterInt64Int32 {
	var i IterInt64Int32
	i.t = t
	return &i
}

func (i *IterInt64Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapInt64Int64 implements an associative array of int64 indexed by int64.
type MapInt64Int64 struct {
	length int
	root   nodeMapint64int64
}

type nodeMapint64int64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int64 or int64)
}

// Return walking direction
func (c nodeMapint64int64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int64) find(key int64) (uint, *nodeMapint64int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Int64) Set(key int64, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Int64) Get(key int64) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int64) Length() int {
	return t.length
}

// func (c *nodeMapint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterInt64Int64 struct {
	t     *MapInt64Int64
	nodes []*nodeMapint64int64
	Key   int64
	Value *int64
}

// Iterator returns a new IterInt64Int64.
func (t *MapInt64Int64) Iterator() *IterInt64Int64 {
	var i IterInt64Int64
	i.t = t
	return &i
}

func (i *IterInt64Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapInt64Int8 implements an associative array of int8 indexed by int64.
type MapInt64Int8 struct {
	length int
	root   nodeMapint64int8
}

type nodeMapint64int8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int8 or int8)
}

// Return walking direction
func (c nodeMapint64int8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64int8) find(key int64) (uint, *nodeMapint64int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Int8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Int8) Set(key int64, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Int8) Get(key int64) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int8) Length() int {
	return t.length
}

// func (c *nodeMapint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterInt64Int8 struct {
	t     *MapInt64Int8
	nodes []*nodeMapint64int8
	Key   int64
	Value *int8
}

// Iterator returns a new IterInt64Int8.
func (t *MapInt64Int8) Iterator() *IterInt64Int8 {
	var i IterInt64Int8
	i.t = t
	return &i
}

func (i *IterInt64Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapInt64Rune implements an associative array of rune indexed by int64.
type MapInt64Rune struct {
	length int
	root   nodeMapint64rune
}

type nodeMapint64rune struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64rune or rune)
}

// Return walking direction
func (c nodeMapint64rune) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64rune) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64rune) find(key int64) (uint, *nodeMapint64rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Rune) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Rune) Set(key int64, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Rune) Get(key int64) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Rune) Length() int {
	return t.length
}

// func (c *nodeMapint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterInt64Rune struct {
	t     *MapInt64Rune
	nodes []*nodeMapint64rune
	Key   int64
	Value *rune
}

// Iterator returns a new IterInt64Rune.
func (t *MapInt64Rune) Iterator() *IterInt64Rune {
	var i IterInt64Rune
	i.t = t
	return &i
}

func (i *IterInt64Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapInt64String implements an associative array of string indexed by int64.
type MapInt64String struct {
	length int
	root   nodeMapint64string
}

type nodeMapint64string struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64string or string)
}

// Return walking direction
func (c nodeMapint64string) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64string) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64string) find(key int64) (uint, *nodeMapint64string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64String) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64String) Set(key int64, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64String) Get(key int64) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64String) Length() int {
	return t.length
}

// func (c *nodeMapint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterInt64String struct {
	t     *MapInt64String
	nodes []*nodeMapint64string
	Key   int64
	Value *string
}

// Iterator returns a new IterInt64String.
func (t *MapInt64String) Iterator() *IterInt64String {
	var i IterInt64String
	i.t = t
	return &i
}

func (i *IterInt64String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapInt64Uint implements an associative array of uint indexed by int64.
type MapInt64Uint struct {
	length int
	root   nodeMapint64uint
}

type nodeMapint64uint struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint or uint)
}

// Return walking direction
func (c nodeMapint64uint) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint) find(key int64) (uint, *nodeMapint64uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uint) Set(key int64, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uint) Get(key int64) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint) Length() int {
	return t.length
}

// func (c *nodeMapint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterInt64Uint struct {
	t     *MapInt64Uint
	nodes []*nodeMapint64uint
	Key   int64
	Value *uint
}

// Iterator returns a new IterInt64Uint.
func (t *MapInt64Uint) Iterator() *IterInt64Uint {
	var i IterInt64Uint
	i.t = t
	return &i
}

func (i *IterInt64Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapInt64Uint16 implements an associative array of uint16 indexed by int64.
type MapInt64Uint16 struct {
	length int
	root   nodeMapint64uint16
}

type nodeMapint64uint16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapint64uint16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint16) find(key int64) (uint, *nodeMapint64uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uint16) Set(key int64, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uint16) Get(key int64) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterInt64Uint16 struct {
	t     *MapInt64Uint16
	nodes []*nodeMapint64uint16
	Key   int64
	Value *uint16
}

// Iterator returns a new IterInt64Uint16.
func (t *MapInt64Uint16) Iterator() *IterInt64Uint16 {
	var i IterInt64Uint16
	i.t = t
	return &i
}

func (i *IterInt64Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapInt64Uint32 implements an associative array of uint32 indexed by int64.
type MapInt64Uint32 struct {
	length int
	root   nodeMapint64uint32
}

type nodeMapint64uint32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapint64uint32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint32) find(key int64) (uint, *nodeMapint64uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uint32) Set(key int64, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uint32) Get(key int64) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterInt64Uint32 struct {
	t     *MapInt64Uint32
	nodes []*nodeMapint64uint32
	Key   int64
	Value *uint32
}

// Iterator returns a new IterInt64Uint32.
func (t *MapInt64Uint32) Iterator() *IterInt64Uint32 {
	var i IterInt64Uint32
	i.t = t
	return &i
}

func (i *IterInt64Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapInt64Uint64 implements an associative array of uint64 indexed by int64.
type MapInt64Uint64 struct {
	length int
	root   nodeMapint64uint64
}

type nodeMapint64uint64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapint64uint64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint64) find(key int64) (uint, *nodeMapint64uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uint64) Set(key int64, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uint64) Get(key int64) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterInt64Uint64 struct {
	t     *MapInt64Uint64
	nodes []*nodeMapint64uint64
	Key   int64
	Value *uint64
}

// Iterator returns a new IterInt64Uint64.
func (t *MapInt64Uint64) Iterator() *IterInt64Uint64 {
	var i IterInt64Uint64
	i.t = t
	return &i
}

func (i *IterInt64Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapInt64Uint8 implements an associative array of uint8 indexed by int64.
type MapInt64Uint8 struct {
	length int
	root   nodeMapint64uint8
}

type nodeMapint64uint8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapint64uint8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uint8) find(key int64) (uint, *nodeMapint64uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uint8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uint8) Set(key int64, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uint8) Get(key int64) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterInt64Uint8 struct {
	t     *MapInt64Uint8
	nodes []*nodeMapint64uint8
	Key   int64
	Value *uint8
}

// Iterator returns a new IterInt64Uint8.
func (t *MapInt64Uint8) Iterator() *IterInt64Uint8 {
	var i IterInt64Uint8
	i.t = t
	return &i
}

func (i *IterInt64Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapInt64Uintptr implements an associative array of uintptr indexed by int64.
type MapInt64Uintptr struct {
	length int
	root   nodeMapint64uintptr
}

type nodeMapint64uintptr struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint64uintptr) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uintptr) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint64uintptr) find(key int64) (uint, *nodeMapint64uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint64uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt64Uintptr) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt64Uintptr) Set(key int64, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt64Uintptr) Get(key int64) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterInt64Uintptr struct {
	t     *MapInt64Uintptr
	nodes []*nodeMapint64uintptr
	Key   int64
	Value *uintptr
}

// Iterator returns a new IterInt64Uintptr.
func (t *MapInt64Uintptr) Iterator() *IterInt64Uintptr {
	var i IterInt64Uintptr
	i.t = t
	return &i
}

func (i *IterInt64Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint64uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint64uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint64uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint64uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint64uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapInt32Bool implements an associative array of bool indexed by int32.
type MapInt32Bool struct {
	length int
	root   nodeMapint32bool
}

type nodeMapint32bool struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32bool or bool)
}

// Return walking direction
func (c nodeMapint32bool) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32bool) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32bool) find(key int32) (uint, *nodeMapint32bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Bool) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Bool) Set(key int32, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Bool) Get(key int32) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Bool) Length() int {
	return t.length
}

// func (c *nodeMapint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterInt32Bool struct {
	t     *MapInt32Bool
	nodes []*nodeMapint32bool
	Key   int32
	Value *bool
}

// Iterator returns a new IterInt32Bool.
func (t *MapInt32Bool) Iterator() *IterInt32Bool {
	var i IterInt32Bool
	i.t = t
	return &i
}

func (i *IterInt32Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapInt32Byte implements an associative array of byte indexed by int32.
type MapInt32Byte struct {
	length int
	root   nodeMapint32byte
}

type nodeMapint32byte struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32byte or byte)
}

// Return walking direction
func (c nodeMapint32byte) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32byte) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32byte) find(key int32) (uint, *nodeMapint32byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Byte) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Byte) Set(key int32, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Byte) Get(key int32) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Byte) Length() int {
	return t.length
}

// func (c *nodeMapint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterInt32Byte struct {
	t     *MapInt32Byte
	nodes []*nodeMapint32byte
	Key   int32
	Value *byte
}

// Iterator returns a new IterInt32Byte.
func (t *MapInt32Byte) Iterator() *IterInt32Byte {
	var i IterInt32Byte
	i.t = t
	return &i
}

func (i *IterInt32Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapInt32Complex128 implements an associative array of complex128 indexed by int32.
type MapInt32Complex128 struct {
	length int
	root   nodeMapint32complex128
}

type nodeMapint32complex128 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapint32complex128) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex128) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32complex128) find(key int32) (uint, *nodeMapint32complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Complex128) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Complex128) Set(key int32, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Complex128) Get(key int32) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterInt32Complex128 struct {
	t     *MapInt32Complex128
	nodes []*nodeMapint32complex128
	Key   int32
	Value *complex128
}

// Iterator returns a new IterInt32Complex128.
func (t *MapInt32Complex128) Iterator() *IterInt32Complex128 {
	var i IterInt32Complex128
	i.t = t
	return &i
}

func (i *IterInt32Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapInt32Complex64 implements an associative array of complex64 indexed by int32.
type MapInt32Complex64 struct {
	length int
	root   nodeMapint32complex64
}

type nodeMapint32complex64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapint32complex64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32complex64) find(key int32) (uint, *nodeMapint32complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Complex64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Complex64) Set(key int32, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Complex64) Get(key int32) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterInt32Complex64 struct {
	t     *MapInt32Complex64
	nodes []*nodeMapint32complex64
	Key   int32
	Value *complex64
}

// Iterator returns a new IterInt32Complex64.
func (t *MapInt32Complex64) Iterator() *IterInt32Complex64 {
	var i IterInt32Complex64
	i.t = t
	return &i
}

func (i *IterInt32Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapInt32Error implements an associative array of error indexed by int32.
type MapInt32Error struct {
	length int
	root   nodeMapint32error
}

type nodeMapint32error struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32error or error)
}

// Return walking direction
func (c nodeMapint32error) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32error) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32error) find(key int32) (uint, *nodeMapint32error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Error) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Error) Set(key int32, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Error) Get(key int32) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Error) Length() int {
	return t.length
}

// func (c *nodeMapint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterInt32Error struct {
	t     *MapInt32Error
	nodes []*nodeMapint32error
	Key   int32
	Value *error
}

// Iterator returns a new IterInt32Error.
func (t *MapInt32Error) Iterator() *IterInt32Error {
	var i IterInt32Error
	i.t = t
	return &i
}

func (i *IterInt32Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapInt32Float32 implements an associative array of float32 indexed by int32.
type MapInt32Float32 struct {
	length int
	root   nodeMapint32float32
}

type nodeMapint32float32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float32 or float32)
}

// Return walking direction
func (c nodeMapint32float32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32float32) find(key int32) (uint, *nodeMapint32float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Float32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Float32) Set(key int32, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Float32) Get(key int32) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float32) Length() int {
	return t.length
}

// func (c *nodeMapint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterInt32Float32 struct {
	t     *MapInt32Float32
	nodes []*nodeMapint32float32
	Key   int32
	Value *float32
}

// Iterator returns a new IterInt32Float32.
func (t *MapInt32Float32) Iterator() *IterInt32Float32 {
	var i IterInt32Float32
	i.t = t
	return &i
}

func (i *IterInt32Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapInt32Float64 implements an associative array of float64 indexed by int32.
type MapInt32Float64 struct {
	length int
	root   nodeMapint32float64
}

type nodeMapint32float64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float64 or float64)
}

// Return walking direction
func (c nodeMapint32float64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32float64) find(key int32) (uint, *nodeMapint32float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Float64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Float64) Set(key int32, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Float64) Get(key int32) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float64) Length() int {
	return t.length
}

// func (c *nodeMapint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterInt32Float64 struct {
	t     *MapInt32Float64
	nodes []*nodeMapint32float64
	Key   int32
	Value *float64
}

// Iterator returns a new IterInt32Float64.
func (t *MapInt32Float64) Iterator() *IterInt32Float64 {
	var i IterInt32Float64
	i.t = t
	return &i
}

func (i *IterInt32Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapInt32Int implements an associative array of int indexed by int32.
type MapInt32Int struct {
	length int
	root   nodeMapint32int
}

type nodeMapint32int struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int or int)
}

// Return walking direction
func (c nodeMapint32int) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int) find(key int32) (uint, *nodeMapint32int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Int) Set(key int32, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Int) Get(key int32) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int) Length() int {
	return t.length
}

// func (c *nodeMapint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterInt32Int struct {
	t     *MapInt32Int
	nodes []*nodeMapint32int
	Key   int32
	Value *int
}

// Iterator returns a new IterInt32Int.
func (t *MapInt32Int) Iterator() *IterInt32Int {
	var i IterInt32Int
	i.t = t
	return &i
}

func (i *IterInt32Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapInt32Int16 implements an associative array of int16 indexed by int32.
type MapInt32Int16 struct {
	length int
	root   nodeMapint32int16
}

type nodeMapint32int16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int16 or int16)
}

// Return walking direction
func (c nodeMapint32int16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int16) find(key int32) (uint, *nodeMapint32int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Int16) Set(key int32, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Int16) Get(key int32) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int16) Length() int {
	return t.length
}

// func (c *nodeMapint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterInt32Int16 struct {
	t     *MapInt32Int16
	nodes []*nodeMapint32int16
	Key   int32
	Value *int16
}

// Iterator returns a new IterInt32Int16.
func (t *MapInt32Int16) Iterator() *IterInt32Int16 {
	var i IterInt32Int16
	i.t = t
	return &i
}

func (i *IterInt32Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapInt32Int32 implements an associative array of int32 indexed by int32.
type MapInt32Int32 struct {
	length int
	root   nodeMapint32int32
}

type nodeMapint32int32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int32 or int32)
}

// Return walking direction
func (c nodeMapint32int32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int32) find(key int32) (uint, *nodeMapint32int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Int32) Set(key int32, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Int32) Get(key int32) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int32) Length() int {
	return t.length
}

// func (c *nodeMapint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterInt32Int32 struct {
	t     *MapInt32Int32
	nodes []*nodeMapint32int32
	Key   int32
	Value *int32
}

// Iterator returns a new IterInt32Int32.
func (t *MapInt32Int32) Iterator() *IterInt32Int32 {
	var i IterInt32Int32
	i.t = t
	return &i
}

func (i *IterInt32Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapInt32Int64 implements an associative array of int64 indexed by int32.
type MapInt32Int64 struct {
	length int
	root   nodeMapint32int64
}

type nodeMapint32int64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int64 or int64)
}

// Return walking direction
func (c nodeMapint32int64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int64) find(key int32) (uint, *nodeMapint32int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Int64) Set(key int32, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Int64) Get(key int32) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int64) Length() int {
	return t.length
}

// func (c *nodeMapint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterInt32Int64 struct {
	t     *MapInt32Int64
	nodes []*nodeMapint32int64
	Key   int32
	Value *int64
}

// Iterator returns a new IterInt32Int64.
func (t *MapInt32Int64) Iterator() *IterInt32Int64 {
	var i IterInt32Int64
	i.t = t
	return &i
}

func (i *IterInt32Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapInt32Int8 implements an associative array of int8 indexed by int32.
type MapInt32Int8 struct {
	length int
	root   nodeMapint32int8
}

type nodeMapint32int8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int8 or int8)
}

// Return walking direction
func (c nodeMapint32int8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32int8) find(key int32) (uint, *nodeMapint32int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Int8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Int8) Set(key int32, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Int8) Get(key int32) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int8) Length() int {
	return t.length
}

// func (c *nodeMapint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterInt32Int8 struct {
	t     *MapInt32Int8
	nodes []*nodeMapint32int8
	Key   int32
	Value *int8
}

// Iterator returns a new IterInt32Int8.
func (t *MapInt32Int8) Iterator() *IterInt32Int8 {
	var i IterInt32Int8
	i.t = t
	return &i
}

func (i *IterInt32Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapInt32Rune implements an associative array of rune indexed by int32.
type MapInt32Rune struct {
	length int
	root   nodeMapint32rune
}

type nodeMapint32rune struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32rune or rune)
}

// Return walking direction
func (c nodeMapint32rune) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32rune) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32rune) find(key int32) (uint, *nodeMapint32rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Rune) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Rune) Set(key int32, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Rune) Get(key int32) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Rune) Length() int {
	return t.length
}

// func (c *nodeMapint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterInt32Rune struct {
	t     *MapInt32Rune
	nodes []*nodeMapint32rune
	Key   int32
	Value *rune
}

// Iterator returns a new IterInt32Rune.
func (t *MapInt32Rune) Iterator() *IterInt32Rune {
	var i IterInt32Rune
	i.t = t
	return &i
}

func (i *IterInt32Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapInt32String implements an associative array of string indexed by int32.
type MapInt32String struct {
	length int
	root   nodeMapint32string
}

type nodeMapint32string struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32string or string)
}

// Return walking direction
func (c nodeMapint32string) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32string) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32string) find(key int32) (uint, *nodeMapint32string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32String) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32String) Set(key int32, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32String) Get(key int32) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32String) Length() int {
	return t.length
}

// func (c *nodeMapint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterInt32String struct {
	t     *MapInt32String
	nodes []*nodeMapint32string
	Key   int32
	Value *string
}

// Iterator returns a new IterInt32String.
func (t *MapInt32String) Iterator() *IterInt32String {
	var i IterInt32String
	i.t = t
	return &i
}

func (i *IterInt32String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapInt32Uint implements an associative array of uint indexed by int32.
type MapInt32Uint struct {
	length int
	root   nodeMapint32uint
}

type nodeMapint32uint struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint or uint)
}

// Return walking direction
func (c nodeMapint32uint) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint) find(key int32) (uint, *nodeMapint32uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uint) Set(key int32, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uint) Get(key int32) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint) Length() int {
	return t.length
}

// func (c *nodeMapint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterInt32Uint struct {
	t     *MapInt32Uint
	nodes []*nodeMapint32uint
	Key   int32
	Value *uint
}

// Iterator returns a new IterInt32Uint.
func (t *MapInt32Uint) Iterator() *IterInt32Uint {
	var i IterInt32Uint
	i.t = t
	return &i
}

func (i *IterInt32Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapInt32Uint16 implements an associative array of uint16 indexed by int32.
type MapInt32Uint16 struct {
	length int
	root   nodeMapint32uint16
}

type nodeMapint32uint16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapint32uint16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint16) find(key int32) (uint, *nodeMapint32uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uint16) Set(key int32, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uint16) Get(key int32) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterInt32Uint16 struct {
	t     *MapInt32Uint16
	nodes []*nodeMapint32uint16
	Key   int32
	Value *uint16
}

// Iterator returns a new IterInt32Uint16.
func (t *MapInt32Uint16) Iterator() *IterInt32Uint16 {
	var i IterInt32Uint16
	i.t = t
	return &i
}

func (i *IterInt32Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapInt32Uint32 implements an associative array of uint32 indexed by int32.
type MapInt32Uint32 struct {
	length int
	root   nodeMapint32uint32
}

type nodeMapint32uint32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapint32uint32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint32) find(key int32) (uint, *nodeMapint32uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uint32) Set(key int32, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uint32) Get(key int32) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterInt32Uint32 struct {
	t     *MapInt32Uint32
	nodes []*nodeMapint32uint32
	Key   int32
	Value *uint32
}

// Iterator returns a new IterInt32Uint32.
func (t *MapInt32Uint32) Iterator() *IterInt32Uint32 {
	var i IterInt32Uint32
	i.t = t
	return &i
}

func (i *IterInt32Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapInt32Uint64 implements an associative array of uint64 indexed by int32.
type MapInt32Uint64 struct {
	length int
	root   nodeMapint32uint64
}

type nodeMapint32uint64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapint32uint64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint64) find(key int32) (uint, *nodeMapint32uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uint64) Set(key int32, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uint64) Get(key int32) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterInt32Uint64 struct {
	t     *MapInt32Uint64
	nodes []*nodeMapint32uint64
	Key   int32
	Value *uint64
}

// Iterator returns a new IterInt32Uint64.
func (t *MapInt32Uint64) Iterator() *IterInt32Uint64 {
	var i IterInt32Uint64
	i.t = t
	return &i
}

func (i *IterInt32Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapInt32Uint8 implements an associative array of uint8 indexed by int32.
type MapInt32Uint8 struct {
	length int
	root   nodeMapint32uint8
}

type nodeMapint32uint8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapint32uint8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uint8) find(key int32) (uint, *nodeMapint32uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uint8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uint8) Set(key int32, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uint8) Get(key int32) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterInt32Uint8 struct {
	t     *MapInt32Uint8
	nodes []*nodeMapint32uint8
	Key   int32
	Value *uint8
}

// Iterator returns a new IterInt32Uint8.
func (t *MapInt32Uint8) Iterator() *IterInt32Uint8 {
	var i IterInt32Uint8
	i.t = t
	return &i
}

func (i *IterInt32Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapInt32Uintptr implements an associative array of uintptr indexed by int32.
type MapInt32Uintptr struct {
	length int
	root   nodeMapint32uintptr
}

type nodeMapint32uintptr struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint32uintptr) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uintptr) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint32uintptr) find(key int32) (uint, *nodeMapint32uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint32uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt32Uintptr) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt32Uintptr) Set(key int32, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt32Uintptr) Get(key int32) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterInt32Uintptr struct {
	t     *MapInt32Uintptr
	nodes []*nodeMapint32uintptr
	Key   int32
	Value *uintptr
}

// Iterator returns a new IterInt32Uintptr.
func (t *MapInt32Uintptr) Iterator() *IterInt32Uintptr {
	var i IterInt32Uintptr
	i.t = t
	return &i
}

func (i *IterInt32Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint32uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint32uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint32uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint32uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint32uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapInt16Bool implements an associative array of bool indexed by int16.
type MapInt16Bool struct {
	length int
	root   nodeMapint16bool
}

type nodeMapint16bool struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16bool or bool)
}

// Return walking direction
func (c nodeMapint16bool) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16bool) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16bool) find(key int16) (uint, *nodeMapint16bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Bool) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Bool) Set(key int16, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Bool) Get(key int16) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Bool) Length() int {
	return t.length
}

// func (c *nodeMapint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterInt16Bool struct {
	t     *MapInt16Bool
	nodes []*nodeMapint16bool
	Key   int16
	Value *bool
}

// Iterator returns a new IterInt16Bool.
func (t *MapInt16Bool) Iterator() *IterInt16Bool {
	var i IterInt16Bool
	i.t = t
	return &i
}

func (i *IterInt16Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapInt16Byte implements an associative array of byte indexed by int16.
type MapInt16Byte struct {
	length int
	root   nodeMapint16byte
}

type nodeMapint16byte struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16byte or byte)
}

// Return walking direction
func (c nodeMapint16byte) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16byte) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16byte) find(key int16) (uint, *nodeMapint16byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Byte) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Byte) Set(key int16, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Byte) Get(key int16) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Byte) Length() int {
	return t.length
}

// func (c *nodeMapint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterInt16Byte struct {
	t     *MapInt16Byte
	nodes []*nodeMapint16byte
	Key   int16
	Value *byte
}

// Iterator returns a new IterInt16Byte.
func (t *MapInt16Byte) Iterator() *IterInt16Byte {
	var i IterInt16Byte
	i.t = t
	return &i
}

func (i *IterInt16Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapInt16Complex128 implements an associative array of complex128 indexed by int16.
type MapInt16Complex128 struct {
	length int
	root   nodeMapint16complex128
}

type nodeMapint16complex128 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapint16complex128) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex128) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16complex128) find(key int16) (uint, *nodeMapint16complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Complex128) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Complex128) Set(key int16, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Complex128) Get(key int16) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterInt16Complex128 struct {
	t     *MapInt16Complex128
	nodes []*nodeMapint16complex128
	Key   int16
	Value *complex128
}

// Iterator returns a new IterInt16Complex128.
func (t *MapInt16Complex128) Iterator() *IterInt16Complex128 {
	var i IterInt16Complex128
	i.t = t
	return &i
}

func (i *IterInt16Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapInt16Complex64 implements an associative array of complex64 indexed by int16.
type MapInt16Complex64 struct {
	length int
	root   nodeMapint16complex64
}

type nodeMapint16complex64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapint16complex64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16complex64) find(key int16) (uint, *nodeMapint16complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Complex64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Complex64) Set(key int16, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Complex64) Get(key int16) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterInt16Complex64 struct {
	t     *MapInt16Complex64
	nodes []*nodeMapint16complex64
	Key   int16
	Value *complex64
}

// Iterator returns a new IterInt16Complex64.
func (t *MapInt16Complex64) Iterator() *IterInt16Complex64 {
	var i IterInt16Complex64
	i.t = t
	return &i
}

func (i *IterInt16Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapInt16Error implements an associative array of error indexed by int16.
type MapInt16Error struct {
	length int
	root   nodeMapint16error
}

type nodeMapint16error struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16error or error)
}

// Return walking direction
func (c nodeMapint16error) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16error) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16error) find(key int16) (uint, *nodeMapint16error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Error) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Error) Set(key int16, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Error) Get(key int16) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Error) Length() int {
	return t.length
}

// func (c *nodeMapint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterInt16Error struct {
	t     *MapInt16Error
	nodes []*nodeMapint16error
	Key   int16
	Value *error
}

// Iterator returns a new IterInt16Error.
func (t *MapInt16Error) Iterator() *IterInt16Error {
	var i IterInt16Error
	i.t = t
	return &i
}

func (i *IterInt16Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapInt16Float32 implements an associative array of float32 indexed by int16.
type MapInt16Float32 struct {
	length int
	root   nodeMapint16float32
}

type nodeMapint16float32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float32 or float32)
}

// Return walking direction
func (c nodeMapint16float32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16float32) find(key int16) (uint, *nodeMapint16float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Float32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Float32) Set(key int16, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Float32) Get(key int16) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float32) Length() int {
	return t.length
}

// func (c *nodeMapint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterInt16Float32 struct {
	t     *MapInt16Float32
	nodes []*nodeMapint16float32
	Key   int16
	Value *float32
}

// Iterator returns a new IterInt16Float32.
func (t *MapInt16Float32) Iterator() *IterInt16Float32 {
	var i IterInt16Float32
	i.t = t
	return &i
}

func (i *IterInt16Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapInt16Float64 implements an associative array of float64 indexed by int16.
type MapInt16Float64 struct {
	length int
	root   nodeMapint16float64
}

type nodeMapint16float64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float64 or float64)
}

// Return walking direction
func (c nodeMapint16float64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16float64) find(key int16) (uint, *nodeMapint16float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Float64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Float64) Set(key int16, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Float64) Get(key int16) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float64) Length() int {
	return t.length
}

// func (c *nodeMapint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterInt16Float64 struct {
	t     *MapInt16Float64
	nodes []*nodeMapint16float64
	Key   int16
	Value *float64
}

// Iterator returns a new IterInt16Float64.
func (t *MapInt16Float64) Iterator() *IterInt16Float64 {
	var i IterInt16Float64
	i.t = t
	return &i
}

func (i *IterInt16Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapInt16Int implements an associative array of int indexed by int16.
type MapInt16Int struct {
	length int
	root   nodeMapint16int
}

type nodeMapint16int struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int or int)
}

// Return walking direction
func (c nodeMapint16int) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int) find(key int16) (uint, *nodeMapint16int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Int) Set(key int16, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Int) Get(key int16) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int) Length() int {
	return t.length
}

// func (c *nodeMapint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterInt16Int struct {
	t     *MapInt16Int
	nodes []*nodeMapint16int
	Key   int16
	Value *int
}

// Iterator returns a new IterInt16Int.
func (t *MapInt16Int) Iterator() *IterInt16Int {
	var i IterInt16Int
	i.t = t
	return &i
}

func (i *IterInt16Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapInt16Int16 implements an associative array of int16 indexed by int16.
type MapInt16Int16 struct {
	length int
	root   nodeMapint16int16
}

type nodeMapint16int16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int16 or int16)
}

// Return walking direction
func (c nodeMapint16int16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int16) find(key int16) (uint, *nodeMapint16int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Int16) Set(key int16, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Int16) Get(key int16) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int16) Length() int {
	return t.length
}

// func (c *nodeMapint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterInt16Int16 struct {
	t     *MapInt16Int16
	nodes []*nodeMapint16int16
	Key   int16
	Value *int16
}

// Iterator returns a new IterInt16Int16.
func (t *MapInt16Int16) Iterator() *IterInt16Int16 {
	var i IterInt16Int16
	i.t = t
	return &i
}

func (i *IterInt16Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapInt16Int32 implements an associative array of int32 indexed by int16.
type MapInt16Int32 struct {
	length int
	root   nodeMapint16int32
}

type nodeMapint16int32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int32 or int32)
}

// Return walking direction
func (c nodeMapint16int32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int32) find(key int16) (uint, *nodeMapint16int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Int32) Set(key int16, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Int32) Get(key int16) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int32) Length() int {
	return t.length
}

// func (c *nodeMapint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterInt16Int32 struct {
	t     *MapInt16Int32
	nodes []*nodeMapint16int32
	Key   int16
	Value *int32
}

// Iterator returns a new IterInt16Int32.
func (t *MapInt16Int32) Iterator() *IterInt16Int32 {
	var i IterInt16Int32
	i.t = t
	return &i
}

func (i *IterInt16Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapInt16Int64 implements an associative array of int64 indexed by int16.
type MapInt16Int64 struct {
	length int
	root   nodeMapint16int64
}

type nodeMapint16int64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int64 or int64)
}

// Return walking direction
func (c nodeMapint16int64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int64) find(key int16) (uint, *nodeMapint16int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Int64) Set(key int16, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Int64) Get(key int16) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int64) Length() int {
	return t.length
}

// func (c *nodeMapint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterInt16Int64 struct {
	t     *MapInt16Int64
	nodes []*nodeMapint16int64
	Key   int16
	Value *int64
}

// Iterator returns a new IterInt16Int64.
func (t *MapInt16Int64) Iterator() *IterInt16Int64 {
	var i IterInt16Int64
	i.t = t
	return &i
}

func (i *IterInt16Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapInt16Int8 implements an associative array of int8 indexed by int16.
type MapInt16Int8 struct {
	length int
	root   nodeMapint16int8
}

type nodeMapint16int8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int8 or int8)
}

// Return walking direction
func (c nodeMapint16int8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16int8) find(key int16) (uint, *nodeMapint16int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Int8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Int8) Set(key int16, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Int8) Get(key int16) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int8) Length() int {
	return t.length
}

// func (c *nodeMapint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterInt16Int8 struct {
	t     *MapInt16Int8
	nodes []*nodeMapint16int8
	Key   int16
	Value *int8
}

// Iterator returns a new IterInt16Int8.
func (t *MapInt16Int8) Iterator() *IterInt16Int8 {
	var i IterInt16Int8
	i.t = t
	return &i
}

func (i *IterInt16Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapInt16Rune implements an associative array of rune indexed by int16.
type MapInt16Rune struct {
	length int
	root   nodeMapint16rune
}

type nodeMapint16rune struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16rune or rune)
}

// Return walking direction
func (c nodeMapint16rune) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16rune) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16rune) find(key int16) (uint, *nodeMapint16rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Rune) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Rune) Set(key int16, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Rune) Get(key int16) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Rune) Length() int {
	return t.length
}

// func (c *nodeMapint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterInt16Rune struct {
	t     *MapInt16Rune
	nodes []*nodeMapint16rune
	Key   int16
	Value *rune
}

// Iterator returns a new IterInt16Rune.
func (t *MapInt16Rune) Iterator() *IterInt16Rune {
	var i IterInt16Rune
	i.t = t
	return &i
}

func (i *IterInt16Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapInt16String implements an associative array of string indexed by int16.
type MapInt16String struct {
	length int
	root   nodeMapint16string
}

type nodeMapint16string struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16string or string)
}

// Return walking direction
func (c nodeMapint16string) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16string) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16string) find(key int16) (uint, *nodeMapint16string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16String) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16String) Set(key int16, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16String) Get(key int16) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16String) Length() int {
	return t.length
}

// func (c *nodeMapint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterInt16String struct {
	t     *MapInt16String
	nodes []*nodeMapint16string
	Key   int16
	Value *string
}

// Iterator returns a new IterInt16String.
func (t *MapInt16String) Iterator() *IterInt16String {
	var i IterInt16String
	i.t = t
	return &i
}

func (i *IterInt16String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapInt16Uint implements an associative array of uint indexed by int16.
type MapInt16Uint struct {
	length int
	root   nodeMapint16uint
}

type nodeMapint16uint struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint or uint)
}

// Return walking direction
func (c nodeMapint16uint) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint) find(key int16) (uint, *nodeMapint16uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uint) Set(key int16, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uint) Get(key int16) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint) Length() int {
	return t.length
}

// func (c *nodeMapint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterInt16Uint struct {
	t     *MapInt16Uint
	nodes []*nodeMapint16uint
	Key   int16
	Value *uint
}

// Iterator returns a new IterInt16Uint.
func (t *MapInt16Uint) Iterator() *IterInt16Uint {
	var i IterInt16Uint
	i.t = t
	return &i
}

func (i *IterInt16Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapInt16Uint16 implements an associative array of uint16 indexed by int16.
type MapInt16Uint16 struct {
	length int
	root   nodeMapint16uint16
}

type nodeMapint16uint16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapint16uint16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint16) find(key int16) (uint, *nodeMapint16uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uint16) Set(key int16, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uint16) Get(key int16) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterInt16Uint16 struct {
	t     *MapInt16Uint16
	nodes []*nodeMapint16uint16
	Key   int16
	Value *uint16
}

// Iterator returns a new IterInt16Uint16.
func (t *MapInt16Uint16) Iterator() *IterInt16Uint16 {
	var i IterInt16Uint16
	i.t = t
	return &i
}

func (i *IterInt16Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapInt16Uint32 implements an associative array of uint32 indexed by int16.
type MapInt16Uint32 struct {
	length int
	root   nodeMapint16uint32
}

type nodeMapint16uint32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapint16uint32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint32) find(key int16) (uint, *nodeMapint16uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uint32) Set(key int16, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uint32) Get(key int16) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterInt16Uint32 struct {
	t     *MapInt16Uint32
	nodes []*nodeMapint16uint32
	Key   int16
	Value *uint32
}

// Iterator returns a new IterInt16Uint32.
func (t *MapInt16Uint32) Iterator() *IterInt16Uint32 {
	var i IterInt16Uint32
	i.t = t
	return &i
}

func (i *IterInt16Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapInt16Uint64 implements an associative array of uint64 indexed by int16.
type MapInt16Uint64 struct {
	length int
	root   nodeMapint16uint64
}

type nodeMapint16uint64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapint16uint64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint64) find(key int16) (uint, *nodeMapint16uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uint64) Set(key int16, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uint64) Get(key int16) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterInt16Uint64 struct {
	t     *MapInt16Uint64
	nodes []*nodeMapint16uint64
	Key   int16
	Value *uint64
}

// Iterator returns a new IterInt16Uint64.
func (t *MapInt16Uint64) Iterator() *IterInt16Uint64 {
	var i IterInt16Uint64
	i.t = t
	return &i
}

func (i *IterInt16Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapInt16Uint8 implements an associative array of uint8 indexed by int16.
type MapInt16Uint8 struct {
	length int
	root   nodeMapint16uint8
}

type nodeMapint16uint8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapint16uint8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uint8) find(key int16) (uint, *nodeMapint16uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uint8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uint8) Set(key int16, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uint8) Get(key int16) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterInt16Uint8 struct {
	t     *MapInt16Uint8
	nodes []*nodeMapint16uint8
	Key   int16
	Value *uint8
}

// Iterator returns a new IterInt16Uint8.
func (t *MapInt16Uint8) Iterator() *IterInt16Uint8 {
	var i IterInt16Uint8
	i.t = t
	return &i
}

func (i *IterInt16Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapInt16Uintptr implements an associative array of uintptr indexed by int16.
type MapInt16Uintptr struct {
	length int
	root   nodeMapint16uintptr
}

type nodeMapint16uintptr struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint16uintptr) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uintptr) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint16uintptr) find(key int16) (uint, *nodeMapint16uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint16uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt16Uintptr) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt16Uintptr) Set(key int16, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt16Uintptr) Get(key int16) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterInt16Uintptr struct {
	t     *MapInt16Uintptr
	nodes []*nodeMapint16uintptr
	Key   int16
	Value *uintptr
}

// Iterator returns a new IterInt16Uintptr.
func (t *MapInt16Uintptr) Iterator() *IterInt16Uintptr {
	var i IterInt16Uintptr
	i.t = t
	return &i
}

func (i *IterInt16Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint16uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint16uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint16uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint16uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint16uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapInt8Bool implements an associative array of bool indexed by int8.
type MapInt8Bool struct {
	length int
	root   nodeMapint8bool
}

type nodeMapint8bool struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8bool or bool)
}

// Return walking direction
func (c nodeMapint8bool) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8bool) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8bool) find(key int8) (uint, *nodeMapint8bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Bool) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Bool) Set(key int8, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Bool) Get(key int8) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Bool) Length() int {
	return t.length
}

// func (c *nodeMapint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterInt8Bool struct {
	t     *MapInt8Bool
	nodes []*nodeMapint8bool
	Key   int8
	Value *bool
}

// Iterator returns a new IterInt8Bool.
func (t *MapInt8Bool) Iterator() *IterInt8Bool {
	var i IterInt8Bool
	i.t = t
	return &i
}

func (i *IterInt8Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapInt8Byte implements an associative array of byte indexed by int8.
type MapInt8Byte struct {
	length int
	root   nodeMapint8byte
}

type nodeMapint8byte struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8byte or byte)
}

// Return walking direction
func (c nodeMapint8byte) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8byte) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8byte) find(key int8) (uint, *nodeMapint8byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Byte) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Byte) Set(key int8, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Byte) Get(key int8) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Byte) Length() int {
	return t.length
}

// func (c *nodeMapint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterInt8Byte struct {
	t     *MapInt8Byte
	nodes []*nodeMapint8byte
	Key   int8
	Value *byte
}

// Iterator returns a new IterInt8Byte.
func (t *MapInt8Byte) Iterator() *IterInt8Byte {
	var i IterInt8Byte
	i.t = t
	return &i
}

func (i *IterInt8Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapInt8Complex128 implements an associative array of complex128 indexed by int8.
type MapInt8Complex128 struct {
	length int
	root   nodeMapint8complex128
}

type nodeMapint8complex128 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapint8complex128) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex128) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8complex128) find(key int8) (uint, *nodeMapint8complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Complex128) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Complex128) Set(key int8, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Complex128) Get(key int8) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterInt8Complex128 struct {
	t     *MapInt8Complex128
	nodes []*nodeMapint8complex128
	Key   int8
	Value *complex128
}

// Iterator returns a new IterInt8Complex128.
func (t *MapInt8Complex128) Iterator() *IterInt8Complex128 {
	var i IterInt8Complex128
	i.t = t
	return &i
}

func (i *IterInt8Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapInt8Complex64 implements an associative array of complex64 indexed by int8.
type MapInt8Complex64 struct {
	length int
	root   nodeMapint8complex64
}

type nodeMapint8complex64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapint8complex64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8complex64) find(key int8) (uint, *nodeMapint8complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Complex64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Complex64) Set(key int8, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Complex64) Get(key int8) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterInt8Complex64 struct {
	t     *MapInt8Complex64
	nodes []*nodeMapint8complex64
	Key   int8
	Value *complex64
}

// Iterator returns a new IterInt8Complex64.
func (t *MapInt8Complex64) Iterator() *IterInt8Complex64 {
	var i IterInt8Complex64
	i.t = t
	return &i
}

func (i *IterInt8Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapInt8Error implements an associative array of error indexed by int8.
type MapInt8Error struct {
	length int
	root   nodeMapint8error
}

type nodeMapint8error struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8error or error)
}

// Return walking direction
func (c nodeMapint8error) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8error) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8error) find(key int8) (uint, *nodeMapint8error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Error) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Error) Set(key int8, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Error) Get(key int8) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Error) Length() int {
	return t.length
}

// func (c *nodeMapint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterInt8Error struct {
	t     *MapInt8Error
	nodes []*nodeMapint8error
	Key   int8
	Value *error
}

// Iterator returns a new IterInt8Error.
func (t *MapInt8Error) Iterator() *IterInt8Error {
	var i IterInt8Error
	i.t = t
	return &i
}

func (i *IterInt8Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapInt8Float32 implements an associative array of float32 indexed by int8.
type MapInt8Float32 struct {
	length int
	root   nodeMapint8float32
}

type nodeMapint8float32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float32 or float32)
}

// Return walking direction
func (c nodeMapint8float32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8float32) find(key int8) (uint, *nodeMapint8float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Float32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Float32) Set(key int8, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Float32) Get(key int8) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float32) Length() int {
	return t.length
}

// func (c *nodeMapint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterInt8Float32 struct {
	t     *MapInt8Float32
	nodes []*nodeMapint8float32
	Key   int8
	Value *float32
}

// Iterator returns a new IterInt8Float32.
func (t *MapInt8Float32) Iterator() *IterInt8Float32 {
	var i IterInt8Float32
	i.t = t
	return &i
}

func (i *IterInt8Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapInt8Float64 implements an associative array of float64 indexed by int8.
type MapInt8Float64 struct {
	length int
	root   nodeMapint8float64
}

type nodeMapint8float64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float64 or float64)
}

// Return walking direction
func (c nodeMapint8float64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8float64) find(key int8) (uint, *nodeMapint8float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Float64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Float64) Set(key int8, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Float64) Get(key int8) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float64) Length() int {
	return t.length
}

// func (c *nodeMapint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterInt8Float64 struct {
	t     *MapInt8Float64
	nodes []*nodeMapint8float64
	Key   int8
	Value *float64
}

// Iterator returns a new IterInt8Float64.
func (t *MapInt8Float64) Iterator() *IterInt8Float64 {
	var i IterInt8Float64
	i.t = t
	return &i
}

func (i *IterInt8Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapInt8Int implements an associative array of int indexed by int8.
type MapInt8Int struct {
	length int
	root   nodeMapint8int
}

type nodeMapint8int struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int or int)
}

// Return walking direction
func (c nodeMapint8int) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int) find(key int8) (uint, *nodeMapint8int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Int) Set(key int8, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Int) Get(key int8) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int) Length() int {
	return t.length
}

// func (c *nodeMapint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterInt8Int struct {
	t     *MapInt8Int
	nodes []*nodeMapint8int
	Key   int8
	Value *int
}

// Iterator returns a new IterInt8Int.
func (t *MapInt8Int) Iterator() *IterInt8Int {
	var i IterInt8Int
	i.t = t
	return &i
}

func (i *IterInt8Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapInt8Int16 implements an associative array of int16 indexed by int8.
type MapInt8Int16 struct {
	length int
	root   nodeMapint8int16
}

type nodeMapint8int16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int16 or int16)
}

// Return walking direction
func (c nodeMapint8int16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int16) find(key int8) (uint, *nodeMapint8int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Int16) Set(key int8, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Int16) Get(key int8) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int16) Length() int {
	return t.length
}

// func (c *nodeMapint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterInt8Int16 struct {
	t     *MapInt8Int16
	nodes []*nodeMapint8int16
	Key   int8
	Value *int16
}

// Iterator returns a new IterInt8Int16.
func (t *MapInt8Int16) Iterator() *IterInt8Int16 {
	var i IterInt8Int16
	i.t = t
	return &i
}

func (i *IterInt8Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapInt8Int32 implements an associative array of int32 indexed by int8.
type MapInt8Int32 struct {
	length int
	root   nodeMapint8int32
}

type nodeMapint8int32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int32 or int32)
}

// Return walking direction
func (c nodeMapint8int32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int32) find(key int8) (uint, *nodeMapint8int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Int32) Set(key int8, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Int32) Get(key int8) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int32) Length() int {
	return t.length
}

// func (c *nodeMapint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterInt8Int32 struct {
	t     *MapInt8Int32
	nodes []*nodeMapint8int32
	Key   int8
	Value *int32
}

// Iterator returns a new IterInt8Int32.
func (t *MapInt8Int32) Iterator() *IterInt8Int32 {
	var i IterInt8Int32
	i.t = t
	return &i
}

func (i *IterInt8Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapInt8Int64 implements an associative array of int64 indexed by int8.
type MapInt8Int64 struct {
	length int
	root   nodeMapint8int64
}

type nodeMapint8int64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int64 or int64)
}

// Return walking direction
func (c nodeMapint8int64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int64) find(key int8) (uint, *nodeMapint8int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Int64) Set(key int8, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Int64) Get(key int8) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int64) Length() int {
	return t.length
}

// func (c *nodeMapint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterInt8Int64 struct {
	t     *MapInt8Int64
	nodes []*nodeMapint8int64
	Key   int8
	Value *int64
}

// Iterator returns a new IterInt8Int64.
func (t *MapInt8Int64) Iterator() *IterInt8Int64 {
	var i IterInt8Int64
	i.t = t
	return &i
}

func (i *IterInt8Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapInt8Int8 implements an associative array of int8 indexed by int8.
type MapInt8Int8 struct {
	length int
	root   nodeMapint8int8
}

type nodeMapint8int8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int8 or int8)
}

// Return walking direction
func (c nodeMapint8int8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8int8) find(key int8) (uint, *nodeMapint8int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Int8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Int8) Set(key int8, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Int8) Get(key int8) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int8) Length() int {
	return t.length
}

// func (c *nodeMapint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterInt8Int8 struct {
	t     *MapInt8Int8
	nodes []*nodeMapint8int8
	Key   int8
	Value *int8
}

// Iterator returns a new IterInt8Int8.
func (t *MapInt8Int8) Iterator() *IterInt8Int8 {
	var i IterInt8Int8
	i.t = t
	return &i
}

func (i *IterInt8Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapInt8Rune implements an associative array of rune indexed by int8.
type MapInt8Rune struct {
	length int
	root   nodeMapint8rune
}

type nodeMapint8rune struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8rune or rune)
}

// Return walking direction
func (c nodeMapint8rune) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8rune) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8rune) find(key int8) (uint, *nodeMapint8rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Rune) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Rune) Set(key int8, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Rune) Get(key int8) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Rune) Length() int {
	return t.length
}

// func (c *nodeMapint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterInt8Rune struct {
	t     *MapInt8Rune
	nodes []*nodeMapint8rune
	Key   int8
	Value *rune
}

// Iterator returns a new IterInt8Rune.
func (t *MapInt8Rune) Iterator() *IterInt8Rune {
	var i IterInt8Rune
	i.t = t
	return &i
}

func (i *IterInt8Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapInt8String implements an associative array of string indexed by int8.
type MapInt8String struct {
	length int
	root   nodeMapint8string
}

type nodeMapint8string struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8string or string)
}

// Return walking direction
func (c nodeMapint8string) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8string) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8string) find(key int8) (uint, *nodeMapint8string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8String) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8String) Set(key int8, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8String) Get(key int8) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8String) Length() int {
	return t.length
}

// func (c *nodeMapint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterInt8String struct {
	t     *MapInt8String
	nodes []*nodeMapint8string
	Key   int8
	Value *string
}

// Iterator returns a new IterInt8String.
func (t *MapInt8String) Iterator() *IterInt8String {
	var i IterInt8String
	i.t = t
	return &i
}

func (i *IterInt8String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapInt8Uint implements an associative array of uint indexed by int8.
type MapInt8Uint struct {
	length int
	root   nodeMapint8uint
}

type nodeMapint8uint struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint or uint)
}

// Return walking direction
func (c nodeMapint8uint) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint) find(key int8) (uint, *nodeMapint8uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uint) Set(key int8, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uint) Get(key int8) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint) Length() int {
	return t.length
}

// func (c *nodeMapint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterInt8Uint struct {
	t     *MapInt8Uint
	nodes []*nodeMapint8uint
	Key   int8
	Value *uint
}

// Iterator returns a new IterInt8Uint.
func (t *MapInt8Uint) Iterator() *IterInt8Uint {
	var i IterInt8Uint
	i.t = t
	return &i
}

func (i *IterInt8Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapInt8Uint16 implements an associative array of uint16 indexed by int8.
type MapInt8Uint16 struct {
	length int
	root   nodeMapint8uint16
}

type nodeMapint8uint16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapint8uint16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint16) find(key int8) (uint, *nodeMapint8uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uint16) Set(key int8, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uint16) Get(key int8) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterInt8Uint16 struct {
	t     *MapInt8Uint16
	nodes []*nodeMapint8uint16
	Key   int8
	Value *uint16
}

// Iterator returns a new IterInt8Uint16.
func (t *MapInt8Uint16) Iterator() *IterInt8Uint16 {
	var i IterInt8Uint16
	i.t = t
	return &i
}

func (i *IterInt8Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapInt8Uint32 implements an associative array of uint32 indexed by int8.
type MapInt8Uint32 struct {
	length int
	root   nodeMapint8uint32
}

type nodeMapint8uint32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapint8uint32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint32) find(key int8) (uint, *nodeMapint8uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uint32) Set(key int8, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uint32) Get(key int8) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterInt8Uint32 struct {
	t     *MapInt8Uint32
	nodes []*nodeMapint8uint32
	Key   int8
	Value *uint32
}

// Iterator returns a new IterInt8Uint32.
func (t *MapInt8Uint32) Iterator() *IterInt8Uint32 {
	var i IterInt8Uint32
	i.t = t
	return &i
}

func (i *IterInt8Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapInt8Uint64 implements an associative array of uint64 indexed by int8.
type MapInt8Uint64 struct {
	length int
	root   nodeMapint8uint64
}

type nodeMapint8uint64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapint8uint64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint64) find(key int8) (uint, *nodeMapint8uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uint64) Set(key int8, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uint64) Get(key int8) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterInt8Uint64 struct {
	t     *MapInt8Uint64
	nodes []*nodeMapint8uint64
	Key   int8
	Value *uint64
}

// Iterator returns a new IterInt8Uint64.
func (t *MapInt8Uint64) Iterator() *IterInt8Uint64 {
	var i IterInt8Uint64
	i.t = t
	return &i
}

func (i *IterInt8Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapInt8Uint8 implements an associative array of uint8 indexed by int8.
type MapInt8Uint8 struct {
	length int
	root   nodeMapint8uint8
}

type nodeMapint8uint8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapint8uint8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uint8) find(key int8) (uint, *nodeMapint8uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uint8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uint8) Set(key int8, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uint8) Get(key int8) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterInt8Uint8 struct {
	t     *MapInt8Uint8
	nodes []*nodeMapint8uint8
	Key   int8
	Value *uint8
}

// Iterator returns a new IterInt8Uint8.
func (t *MapInt8Uint8) Iterator() *IterInt8Uint8 {
	var i IterInt8Uint8
	i.t = t
	return &i
}

func (i *IterInt8Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapInt8Uintptr implements an associative array of uintptr indexed by int8.
type MapInt8Uintptr struct {
	length int
	root   nodeMapint8uintptr
}

type nodeMapint8uintptr struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint8uintptr) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uintptr) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapint8uintptr) find(key int8) (uint, *nodeMapint8uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapint8uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapInt8Uintptr) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapInt8Uintptr) Set(key int8, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapInt8Uintptr) Get(key int8) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterInt8Uintptr struct {
	t     *MapInt8Uintptr
	nodes []*nodeMapint8uintptr
	Key   int8
	Value *uintptr
}

// Iterator returns a new IterInt8Uintptr.
func (t *MapInt8Uintptr) Iterator() *IterInt8Uintptr {
	var i IterInt8Uintptr
	i.t = t
	return &i
}

func (i *IterInt8Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapint8uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapint8uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapint8uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapint8uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapint8uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapUintBool implements an associative array of bool indexed by uint.
type MapUintBool struct {
	length int
	root   nodeMapuintbool
}

type nodeMapuintbool struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbool or bool)
}

// Return walking direction
func (c nodeMapuintbool) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbool) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintbool) find(key uint) (uint, *nodeMapuintbool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintbool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintBool) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintBool) Set(key uint, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintBool) Get(key uint) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintBool) Length() int {
	return t.length
}

// func (c *nodeMapuintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterUintBool struct {
	t     *MapUintBool
	nodes []*nodeMapuintbool
	Key   uint
	Value *bool
}

// Iterator returns a new IterUintBool.
func (t *MapUintBool) Iterator() *IterUintBool {
	var i IterUintBool
	i.t = t
	return &i
}

func (i *IterUintBool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintbool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintbool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintbool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintbool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintbool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapUintByte implements an associative array of byte indexed by uint.
type MapUintByte struct {
	length int
	root   nodeMapuintbyte
}

type nodeMapuintbyte struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbyte or byte)
}

// Return walking direction
func (c nodeMapuintbyte) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbyte) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintbyte) find(key uint) (uint, *nodeMapuintbyte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintbyte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintByte) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintByte) Set(key uint, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintByte) Get(key uint) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintByte) Length() int {
	return t.length
}

// func (c *nodeMapuintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterUintByte struct {
	t     *MapUintByte
	nodes []*nodeMapuintbyte
	Key   uint
	Value *byte
}

// Iterator returns a new IterUintByte.
func (t *MapUintByte) Iterator() *IterUintByte {
	var i IterUintByte
	i.t = t
	return &i
}

func (i *IterUintByte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintbyte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintbyte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintbyte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintbyte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintbyte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapUintComplex128 implements an associative array of complex128 indexed by uint.
type MapUintComplex128 struct {
	length int
	root   nodeMapuintcomplex128
}

type nodeMapuintcomplex128 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapuintcomplex128) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex128) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintcomplex128) find(key uint) (uint, *nodeMapuintcomplex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintcomplex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintComplex128) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintComplex128) Set(key uint, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintComplex128) Get(key uint) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex128) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterUintComplex128 struct {
	t     *MapUintComplex128
	nodes []*nodeMapuintcomplex128
	Key   uint
	Value *complex128
}

// Iterator returns a new IterUintComplex128.
func (t *MapUintComplex128) Iterator() *IterUintComplex128 {
	var i IterUintComplex128
	i.t = t
	return &i
}

func (i *IterUintComplex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintcomplex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintcomplex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintcomplex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintcomplex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintcomplex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapUintComplex64 implements an associative array of complex64 indexed by uint.
type MapUintComplex64 struct {
	length int
	root   nodeMapuintcomplex64
}

type nodeMapuintcomplex64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapuintcomplex64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintcomplex64) find(key uint) (uint, *nodeMapuintcomplex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintcomplex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintComplex64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintComplex64) Set(key uint, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintComplex64) Get(key uint) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex64) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterUintComplex64 struct {
	t     *MapUintComplex64
	nodes []*nodeMapuintcomplex64
	Key   uint
	Value *complex64
}

// Iterator returns a new IterUintComplex64.
func (t *MapUintComplex64) Iterator() *IterUintComplex64 {
	var i IterUintComplex64
	i.t = t
	return &i
}

func (i *IterUintComplex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintcomplex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintcomplex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintcomplex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintcomplex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintcomplex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapUintError implements an associative array of error indexed by uint.
type MapUintError struct {
	length int
	root   nodeMapuinterror
}

type nodeMapuinterror struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuinterror or error)
}

// Return walking direction
func (c nodeMapuinterror) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuinterror) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuinterror) find(key uint) (uint, *nodeMapuinterror) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuinterror)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintError) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintError) Set(key uint, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintError) Get(key uint) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintError) Length() int {
	return t.length
}

// func (c *nodeMapuinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterUintError struct {
	t     *MapUintError
	nodes []*nodeMapuinterror
	Key   uint
	Value *error
}

// Iterator returns a new IterUintError.
func (t *MapUintError) Iterator() *IterUintError {
	var i IterUintError
	i.t = t
	return &i
}

func (i *IterUintError) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuinterror, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuinterror)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuinterror)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuinterror = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuinterror)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapUintFloat32 implements an associative array of float32 indexed by uint.
type MapUintFloat32 struct {
	length int
	root   nodeMapuintfloat32
}

type nodeMapuintfloat32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat32 or float32)
}

// Return walking direction
func (c nodeMapuintfloat32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintfloat32) find(key uint) (uint, *nodeMapuintfloat32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintfloat32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintFloat32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintFloat32) Set(key uint, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintFloat32) Get(key uint) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat32) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterUintFloat32 struct {
	t     *MapUintFloat32
	nodes []*nodeMapuintfloat32
	Key   uint
	Value *float32
}

// Iterator returns a new IterUintFloat32.
func (t *MapUintFloat32) Iterator() *IterUintFloat32 {
	var i IterUintFloat32
	i.t = t
	return &i
}

func (i *IterUintFloat32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintfloat32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintfloat32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintfloat32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintfloat32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintfloat32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapUintFloat64 implements an associative array of float64 indexed by uint.
type MapUintFloat64 struct {
	length int
	root   nodeMapuintfloat64
}

type nodeMapuintfloat64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat64 or float64)
}

// Return walking direction
func (c nodeMapuintfloat64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintfloat64) find(key uint) (uint, *nodeMapuintfloat64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintfloat64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintFloat64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintFloat64) Set(key uint, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintFloat64) Get(key uint) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat64) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterUintFloat64 struct {
	t     *MapUintFloat64
	nodes []*nodeMapuintfloat64
	Key   uint
	Value *float64
}

// Iterator returns a new IterUintFloat64.
func (t *MapUintFloat64) Iterator() *IterUintFloat64 {
	var i IterUintFloat64
	i.t = t
	return &i
}

func (i *IterUintFloat64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintfloat64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintfloat64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintfloat64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintfloat64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintfloat64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapUintInt implements an associative array of int indexed by uint.
type MapUintInt struct {
	length int
	root   nodeMapuintint
}

type nodeMapuintint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint or int)
}

// Return walking direction
func (c nodeMapuintint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint) find(key uint) (uint, *nodeMapuintint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintInt) Set(key uint, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintInt) Get(key uint) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt) Length() int {
	return t.length
}

// func (c *nodeMapuintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterUintInt struct {
	t     *MapUintInt
	nodes []*nodeMapuintint
	Key   uint
	Value *int
}

// Iterator returns a new IterUintInt.
func (t *MapUintInt) Iterator() *IterUintInt {
	var i IterUintInt
	i.t = t
	return &i
}

func (i *IterUintInt) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapUintInt16 implements an associative array of int16 indexed by uint.
type MapUintInt16 struct {
	length int
	root   nodeMapuintint16
}

type nodeMapuintint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint16 or int16)
}

// Return walking direction
func (c nodeMapuintint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint16) find(key uint) (uint, *nodeMapuintint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintInt16) Set(key uint, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintInt16) Get(key uint) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt16) Length() int {
	return t.length
}

// func (c *nodeMapuintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterUintInt16 struct {
	t     *MapUintInt16
	nodes []*nodeMapuintint16
	Key   uint
	Value *int16
}

// Iterator returns a new IterUintInt16.
func (t *MapUintInt16) Iterator() *IterUintInt16 {
	var i IterUintInt16
	i.t = t
	return &i
}

func (i *IterUintInt16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapUintInt32 implements an associative array of int32 indexed by uint.
type MapUintInt32 struct {
	length int
	root   nodeMapuintint32
}

type nodeMapuintint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint32 or int32)
}

// Return walking direction
func (c nodeMapuintint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint32) find(key uint) (uint, *nodeMapuintint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintInt32) Set(key uint, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintInt32) Get(key uint) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt32) Length() int {
	return t.length
}

// func (c *nodeMapuintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterUintInt32 struct {
	t     *MapUintInt32
	nodes []*nodeMapuintint32
	Key   uint
	Value *int32
}

// Iterator returns a new IterUintInt32.
func (t *MapUintInt32) Iterator() *IterUintInt32 {
	var i IterUintInt32
	i.t = t
	return &i
}

func (i *IterUintInt32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapUintInt64 implements an associative array of int64 indexed by uint.
type MapUintInt64 struct {
	length int
	root   nodeMapuintint64
}

type nodeMapuintint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint64 or int64)
}

// Return walking direction
func (c nodeMapuintint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint64) find(key uint) (uint, *nodeMapuintint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintInt64) Set(key uint, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintInt64) Get(key uint) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt64) Length() int {
	return t.length
}

// func (c *nodeMapuintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterUintInt64 struct {
	t     *MapUintInt64
	nodes []*nodeMapuintint64
	Key   uint
	Value *int64
}

// Iterator returns a new IterUintInt64.
func (t *MapUintInt64) Iterator() *IterUintInt64 {
	var i IterUintInt64
	i.t = t
	return &i
}

func (i *IterUintInt64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapUintInt8 implements an associative array of int8 indexed by uint.
type MapUintInt8 struct {
	length int
	root   nodeMapuintint8
}

type nodeMapuintint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint8 or int8)
}

// Return walking direction
func (c nodeMapuintint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintint8) find(key uint) (uint, *nodeMapuintint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintInt8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintInt8) Set(key uint, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintInt8) Get(key uint) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt8) Length() int {
	return t.length
}

// func (c *nodeMapuintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterUintInt8 struct {
	t     *MapUintInt8
	nodes []*nodeMapuintint8
	Key   uint
	Value *int8
}

// Iterator returns a new IterUintInt8.
func (t *MapUintInt8) Iterator() *IterUintInt8 {
	var i IterUintInt8
	i.t = t
	return &i
}

func (i *IterUintInt8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapUintRune implements an associative array of rune indexed by uint.
type MapUintRune struct {
	length int
	root   nodeMapuintrune
}

type nodeMapuintrune struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintrune or rune)
}

// Return walking direction
func (c nodeMapuintrune) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintrune) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintrune) find(key uint) (uint, *nodeMapuintrune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintrune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintRune) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintRune) Set(key uint, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintRune) Get(key uint) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintRune) Length() int {
	return t.length
}

// func (c *nodeMapuintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterUintRune struct {
	t     *MapUintRune
	nodes []*nodeMapuintrune
	Key   uint
	Value *rune
}

// Iterator returns a new IterUintRune.
func (t *MapUintRune) Iterator() *IterUintRune {
	var i IterUintRune
	i.t = t
	return &i
}

func (i *IterUintRune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintrune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintrune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintrune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintrune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintrune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapUintString implements an associative array of string indexed by uint.
type MapUintString struct {
	length int
	root   nodeMapuintstring
}

type nodeMapuintstring struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintstring or string)
}

// Return walking direction
func (c nodeMapuintstring) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintstring) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintstring) find(key uint) (uint, *nodeMapuintstring) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintstring)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintString) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintString) Set(key uint, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintString) Get(key uint) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintString) Length() int {
	return t.length
}

// func (c *nodeMapuintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterUintString struct {
	t     *MapUintString
	nodes []*nodeMapuintstring
	Key   uint
	Value *string
}

// Iterator returns a new IterUintString.
func (t *MapUintString) Iterator() *IterUintString {
	var i IterUintString
	i.t = t
	return &i
}

func (i *IterUintString) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintstring, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintstring)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintstring)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintstring = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintstring)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapUintUint implements an associative array of uint indexed by uint.
type MapUintUint struct {
	length int
	root   nodeMapuintuint
}

type nodeMapuintuint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint or uint)
}

// Return walking direction
func (c nodeMapuintuint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint) find(key uint) (uint, *nodeMapuintuint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUint) Set(key uint, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUint) Get(key uint) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint) Length() int {
	return t.length
}

// func (c *nodeMapuintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterUintUint struct {
	t     *MapUintUint
	nodes []*nodeMapuintuint
	Key   uint
	Value *uint
}

// Iterator returns a new IterUintUint.
func (t *MapUintUint) Iterator() *IterUintUint {
	var i IterUintUint
	i.t = t
	return &i
}

func (i *IterUintUint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapUintUint16 implements an associative array of uint16 indexed by uint.
type MapUintUint16 struct {
	length int
	root   nodeMapuintuint16
}

type nodeMapuintuint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint16 or uint16)
}

// Return walking direction
func (c nodeMapuintuint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint16) find(key uint) (uint, *nodeMapuintuint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUint16) Set(key uint, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUint16) Get(key uint) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint16) Length() int {
	return t.length
}

// func (c *nodeMapuintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterUintUint16 struct {
	t     *MapUintUint16
	nodes []*nodeMapuintuint16
	Key   uint
	Value *uint16
}

// Iterator returns a new IterUintUint16.
func (t *MapUintUint16) Iterator() *IterUintUint16 {
	var i IterUintUint16
	i.t = t
	return &i
}

func (i *IterUintUint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapUintUint32 implements an associative array of uint32 indexed by uint.
type MapUintUint32 struct {
	length int
	root   nodeMapuintuint32
}

type nodeMapuintuint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint32 or uint32)
}

// Return walking direction
func (c nodeMapuintuint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint32) find(key uint) (uint, *nodeMapuintuint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUint32) Set(key uint, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUint32) Get(key uint) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint32) Length() int {
	return t.length
}

// func (c *nodeMapuintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterUintUint32 struct {
	t     *MapUintUint32
	nodes []*nodeMapuintuint32
	Key   uint
	Value *uint32
}

// Iterator returns a new IterUintUint32.
func (t *MapUintUint32) Iterator() *IterUintUint32 {
	var i IterUintUint32
	i.t = t
	return &i
}

func (i *IterUintUint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapUintUint64 implements an associative array of uint64 indexed by uint.
type MapUintUint64 struct {
	length int
	root   nodeMapuintuint64
}

type nodeMapuintuint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint64 or uint64)
}

// Return walking direction
func (c nodeMapuintuint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint64) find(key uint) (uint, *nodeMapuintuint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUint64) Set(key uint, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUint64) Get(key uint) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint64) Length() int {
	return t.length
}

// func (c *nodeMapuintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterUintUint64 struct {
	t     *MapUintUint64
	nodes []*nodeMapuintuint64
	Key   uint
	Value *uint64
}

// Iterator returns a new IterUintUint64.
func (t *MapUintUint64) Iterator() *IterUintUint64 {
	var i IterUintUint64
	i.t = t
	return &i
}

func (i *IterUintUint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapUintUint8 implements an associative array of uint8 indexed by uint.
type MapUintUint8 struct {
	length int
	root   nodeMapuintuint8
}

type nodeMapuintuint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint8 or uint8)
}

// Return walking direction
func (c nodeMapuintuint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuint8) find(key uint) (uint, *nodeMapuintuint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUint8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUint8) Set(key uint, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUint8) Get(key uint) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint8) Length() int {
	return t.length
}

// func (c *nodeMapuintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterUintUint8 struct {
	t     *MapUintUint8
	nodes []*nodeMapuintuint8
	Key   uint
	Value *uint8
}

// Iterator returns a new IterUintUint8.
func (t *MapUintUint8) Iterator() *IterUintUint8 {
	var i IterUintUint8
	i.t = t
	return &i
}

func (i *IterUintUint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapUintUintptr implements an associative array of uintptr indexed by uint.
type MapUintUintptr struct {
	length int
	root   nodeMapuintuintptr
}

type nodeMapuintuintptr struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapuintuintptr) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuintptr) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuintuintptr) find(key uint) (uint, *nodeMapuintuintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuintuintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUintUintptr) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUintUintptr) Set(key uint, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUintUintptr) Get(key uint) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUintptr) Length() int {
	return t.length
}

// func (c *nodeMapuintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterUintUintptr struct {
	t     *MapUintUintptr
	nodes []*nodeMapuintuintptr
	Key   uint
	Value *uintptr
}

// Iterator returns a new IterUintUintptr.
func (t *MapUintUintptr) Iterator() *IterUintUintptr {
	var i IterUintUintptr
	i.t = t
	return &i
}

func (i *IterUintUintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuintuintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuintuintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuintuintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuintuintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuintuintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapUint64Bool implements an associative array of bool indexed by uint64.
type MapUint64Bool struct {
	length int
	root   nodeMapuint64bool
}

type nodeMapuint64bool struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64bool or bool)
}

// Return walking direction
func (c nodeMapuint64bool) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64bool) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64bool) find(key uint64) (uint, *nodeMapuint64bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Bool) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Bool) Set(key uint64, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Bool) Get(key uint64) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterUint64Bool struct {
	t     *MapUint64Bool
	nodes []*nodeMapuint64bool
	Key   uint64
	Value *bool
}

// Iterator returns a new IterUint64Bool.
func (t *MapUint64Bool) Iterator() *IterUint64Bool {
	var i IterUint64Bool
	i.t = t
	return &i
}

func (i *IterUint64Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapUint64Byte implements an associative array of byte indexed by uint64.
type MapUint64Byte struct {
	length int
	root   nodeMapuint64byte
}

type nodeMapuint64byte struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64byte or byte)
}

// Return walking direction
func (c nodeMapuint64byte) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64byte) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64byte) find(key uint64) (uint, *nodeMapuint64byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Byte) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Byte) Set(key uint64, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Byte) Get(key uint64) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterUint64Byte struct {
	t     *MapUint64Byte
	nodes []*nodeMapuint64byte
	Key   uint64
	Value *byte
}

// Iterator returns a new IterUint64Byte.
func (t *MapUint64Byte) Iterator() *IterUint64Byte {
	var i IterUint64Byte
	i.t = t
	return &i
}

func (i *IterUint64Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapUint64Complex128 implements an associative array of complex128 indexed by uint64.
type MapUint64Complex128 struct {
	length int
	root   nodeMapuint64complex128
}

type nodeMapuint64complex128 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint64complex128) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex128) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64complex128) find(key uint64) (uint, *nodeMapuint64complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Complex128) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Complex128) Set(key uint64, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Complex128) Get(key uint64) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterUint64Complex128 struct {
	t     *MapUint64Complex128
	nodes []*nodeMapuint64complex128
	Key   uint64
	Value *complex128
}

// Iterator returns a new IterUint64Complex128.
func (t *MapUint64Complex128) Iterator() *IterUint64Complex128 {
	var i IterUint64Complex128
	i.t = t
	return &i
}

func (i *IterUint64Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapUint64Complex64 implements an associative array of complex64 indexed by uint64.
type MapUint64Complex64 struct {
	length int
	root   nodeMapuint64complex64
}

type nodeMapuint64complex64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint64complex64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64complex64) find(key uint64) (uint, *nodeMapuint64complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Complex64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Complex64) Set(key uint64, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Complex64) Get(key uint64) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterUint64Complex64 struct {
	t     *MapUint64Complex64
	nodes []*nodeMapuint64complex64
	Key   uint64
	Value *complex64
}

// Iterator returns a new IterUint64Complex64.
func (t *MapUint64Complex64) Iterator() *IterUint64Complex64 {
	var i IterUint64Complex64
	i.t = t
	return &i
}

func (i *IterUint64Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapUint64Error implements an associative array of error indexed by uint64.
type MapUint64Error struct {
	length int
	root   nodeMapuint64error
}

type nodeMapuint64error struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64error or error)
}

// Return walking direction
func (c nodeMapuint64error) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64error) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64error) find(key uint64) (uint, *nodeMapuint64error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Error) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Error) Set(key uint64, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Error) Get(key uint64) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Error) Length() int {
	return t.length
}

// func (c *nodeMapuint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterUint64Error struct {
	t     *MapUint64Error
	nodes []*nodeMapuint64error
	Key   uint64
	Value *error
}

// Iterator returns a new IterUint64Error.
func (t *MapUint64Error) Iterator() *IterUint64Error {
	var i IterUint64Error
	i.t = t
	return &i
}

func (i *IterUint64Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapUint64Float32 implements an associative array of float32 indexed by uint64.
type MapUint64Float32 struct {
	length int
	root   nodeMapuint64float32
}

type nodeMapuint64float32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float32 or float32)
}

// Return walking direction
func (c nodeMapuint64float32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64float32) find(key uint64) (uint, *nodeMapuint64float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Float32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Float32) Set(key uint64, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Float32) Get(key uint64) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterUint64Float32 struct {
	t     *MapUint64Float32
	nodes []*nodeMapuint64float32
	Key   uint64
	Value *float32
}

// Iterator returns a new IterUint64Float32.
func (t *MapUint64Float32) Iterator() *IterUint64Float32 {
	var i IterUint64Float32
	i.t = t
	return &i
}

func (i *IterUint64Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapUint64Float64 implements an associative array of float64 indexed by uint64.
type MapUint64Float64 struct {
	length int
	root   nodeMapuint64float64
}

type nodeMapuint64float64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float64 or float64)
}

// Return walking direction
func (c nodeMapuint64float64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64float64) find(key uint64) (uint, *nodeMapuint64float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Float64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Float64) Set(key uint64, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Float64) Get(key uint64) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterUint64Float64 struct {
	t     *MapUint64Float64
	nodes []*nodeMapuint64float64
	Key   uint64
	Value *float64
}

// Iterator returns a new IterUint64Float64.
func (t *MapUint64Float64) Iterator() *IterUint64Float64 {
	var i IterUint64Float64
	i.t = t
	return &i
}

func (i *IterUint64Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapUint64Int implements an associative array of int indexed by uint64.
type MapUint64Int struct {
	length int
	root   nodeMapuint64int
}

type nodeMapuint64int struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int or int)
}

// Return walking direction
func (c nodeMapuint64int) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int) find(key uint64) (uint, *nodeMapuint64int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Int) Set(key uint64, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Int) Get(key uint64) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int) Length() int {
	return t.length
}

// func (c *nodeMapuint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterUint64Int struct {
	t     *MapUint64Int
	nodes []*nodeMapuint64int
	Key   uint64
	Value *int
}

// Iterator returns a new IterUint64Int.
func (t *MapUint64Int) Iterator() *IterUint64Int {
	var i IterUint64Int
	i.t = t
	return &i
}

func (i *IterUint64Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapUint64Int16 implements an associative array of int16 indexed by uint64.
type MapUint64Int16 struct {
	length int
	root   nodeMapuint64int16
}

type nodeMapuint64int16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int16 or int16)
}

// Return walking direction
func (c nodeMapuint64int16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int16) find(key uint64) (uint, *nodeMapuint64int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Int16) Set(key uint64, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Int16) Get(key uint64) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterUint64Int16 struct {
	t     *MapUint64Int16
	nodes []*nodeMapuint64int16
	Key   uint64
	Value *int16
}

// Iterator returns a new IterUint64Int16.
func (t *MapUint64Int16) Iterator() *IterUint64Int16 {
	var i IterUint64Int16
	i.t = t
	return &i
}

func (i *IterUint64Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapUint64Int32 implements an associative array of int32 indexed by uint64.
type MapUint64Int32 struct {
	length int
	root   nodeMapuint64int32
}

type nodeMapuint64int32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int32 or int32)
}

// Return walking direction
func (c nodeMapuint64int32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int32) find(key uint64) (uint, *nodeMapuint64int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Int32) Set(key uint64, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Int32) Get(key uint64) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterUint64Int32 struct {
	t     *MapUint64Int32
	nodes []*nodeMapuint64int32
	Key   uint64
	Value *int32
}

// Iterator returns a new IterUint64Int32.
func (t *MapUint64Int32) Iterator() *IterUint64Int32 {
	var i IterUint64Int32
	i.t = t
	return &i
}

func (i *IterUint64Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapUint64Int64 implements an associative array of int64 indexed by uint64.
type MapUint64Int64 struct {
	length int
	root   nodeMapuint64int64
}

type nodeMapuint64int64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int64 or int64)
}

// Return walking direction
func (c nodeMapuint64int64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int64) find(key uint64) (uint, *nodeMapuint64int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Int64) Set(key uint64, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Int64) Get(key uint64) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterUint64Int64 struct {
	t     *MapUint64Int64
	nodes []*nodeMapuint64int64
	Key   uint64
	Value *int64
}

// Iterator returns a new IterUint64Int64.
func (t *MapUint64Int64) Iterator() *IterUint64Int64 {
	var i IterUint64Int64
	i.t = t
	return &i
}

func (i *IterUint64Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapUint64Int8 implements an associative array of int8 indexed by uint64.
type MapUint64Int8 struct {
	length int
	root   nodeMapuint64int8
}

type nodeMapuint64int8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int8 or int8)
}

// Return walking direction
func (c nodeMapuint64int8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64int8) find(key uint64) (uint, *nodeMapuint64int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Int8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Int8) Set(key uint64, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Int8) Get(key uint64) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterUint64Int8 struct {
	t     *MapUint64Int8
	nodes []*nodeMapuint64int8
	Key   uint64
	Value *int8
}

// Iterator returns a new IterUint64Int8.
func (t *MapUint64Int8) Iterator() *IterUint64Int8 {
	var i IterUint64Int8
	i.t = t
	return &i
}

func (i *IterUint64Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapUint64Rune implements an associative array of rune indexed by uint64.
type MapUint64Rune struct {
	length int
	root   nodeMapuint64rune
}

type nodeMapuint64rune struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64rune or rune)
}

// Return walking direction
func (c nodeMapuint64rune) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64rune) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64rune) find(key uint64) (uint, *nodeMapuint64rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Rune) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Rune) Set(key uint64, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Rune) Get(key uint64) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterUint64Rune struct {
	t     *MapUint64Rune
	nodes []*nodeMapuint64rune
	Key   uint64
	Value *rune
}

// Iterator returns a new IterUint64Rune.
func (t *MapUint64Rune) Iterator() *IterUint64Rune {
	var i IterUint64Rune
	i.t = t
	return &i
}

func (i *IterUint64Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapUint64String implements an associative array of string indexed by uint64.
type MapUint64String struct {
	length int
	root   nodeMapuint64string
}

type nodeMapuint64string struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64string or string)
}

// Return walking direction
func (c nodeMapuint64string) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64string) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64string) find(key uint64) (uint, *nodeMapuint64string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64String) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64String) Set(key uint64, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64String) Get(key uint64) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64String) Length() int {
	return t.length
}

// func (c *nodeMapuint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterUint64String struct {
	t     *MapUint64String
	nodes []*nodeMapuint64string
	Key   uint64
	Value *string
}

// Iterator returns a new IterUint64String.
func (t *MapUint64String) Iterator() *IterUint64String {
	var i IterUint64String
	i.t = t
	return &i
}

func (i *IterUint64String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapUint64Uint implements an associative array of uint indexed by uint64.
type MapUint64Uint struct {
	length int
	root   nodeMapuint64uint
}

type nodeMapuint64uint struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint or uint)
}

// Return walking direction
func (c nodeMapuint64uint) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint) find(key uint64) (uint, *nodeMapuint64uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uint) Set(key uint64, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uint) Get(key uint64) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterUint64Uint struct {
	t     *MapUint64Uint
	nodes []*nodeMapuint64uint
	Key   uint64
	Value *uint
}

// Iterator returns a new IterUint64Uint.
func (t *MapUint64Uint) Iterator() *IterUint64Uint {
	var i IterUint64Uint
	i.t = t
	return &i
}

func (i *IterUint64Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapUint64Uint16 implements an associative array of uint16 indexed by uint64.
type MapUint64Uint16 struct {
	length int
	root   nodeMapuint64uint16
}

type nodeMapuint64uint16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint64uint16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint16) find(key uint64) (uint, *nodeMapuint64uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uint16) Set(key uint64, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uint16) Get(key uint64) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterUint64Uint16 struct {
	t     *MapUint64Uint16
	nodes []*nodeMapuint64uint16
	Key   uint64
	Value *uint16
}

// Iterator returns a new IterUint64Uint16.
func (t *MapUint64Uint16) Iterator() *IterUint64Uint16 {
	var i IterUint64Uint16
	i.t = t
	return &i
}

func (i *IterUint64Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapUint64Uint32 implements an associative array of uint32 indexed by uint64.
type MapUint64Uint32 struct {
	length int
	root   nodeMapuint64uint32
}

type nodeMapuint64uint32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint64uint32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint32) find(key uint64) (uint, *nodeMapuint64uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uint32) Set(key uint64, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uint32) Get(key uint64) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterUint64Uint32 struct {
	t     *MapUint64Uint32
	nodes []*nodeMapuint64uint32
	Key   uint64
	Value *uint32
}

// Iterator returns a new IterUint64Uint32.
func (t *MapUint64Uint32) Iterator() *IterUint64Uint32 {
	var i IterUint64Uint32
	i.t = t
	return &i
}

func (i *IterUint64Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapUint64Uint64 implements an associative array of uint64 indexed by uint64.
type MapUint64Uint64 struct {
	length int
	root   nodeMapuint64uint64
}

type nodeMapuint64uint64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint64uint64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint64) find(key uint64) (uint, *nodeMapuint64uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uint64) Set(key uint64, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uint64) Get(key uint64) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterUint64Uint64 struct {
	t     *MapUint64Uint64
	nodes []*nodeMapuint64uint64
	Key   uint64
	Value *uint64
}

// Iterator returns a new IterUint64Uint64.
func (t *MapUint64Uint64) Iterator() *IterUint64Uint64 {
	var i IterUint64Uint64
	i.t = t
	return &i
}

func (i *IterUint64Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapUint64Uint8 implements an associative array of uint8 indexed by uint64.
type MapUint64Uint8 struct {
	length int
	root   nodeMapuint64uint8
}

type nodeMapuint64uint8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint64uint8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uint8) find(key uint64) (uint, *nodeMapuint64uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uint8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uint8) Set(key uint64, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uint8) Get(key uint64) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterUint64Uint8 struct {
	t     *MapUint64Uint8
	nodes []*nodeMapuint64uint8
	Key   uint64
	Value *uint8
}

// Iterator returns a new IterUint64Uint8.
func (t *MapUint64Uint8) Iterator() *IterUint64Uint8 {
	var i IterUint64Uint8
	i.t = t
	return &i
}

func (i *IterUint64Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapUint64Uintptr implements an associative array of uintptr indexed by uint64.
type MapUint64Uintptr struct {
	length int
	root   nodeMapuint64uintptr
}

type nodeMapuint64uintptr struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint64uintptr) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uintptr) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint64uintptr) find(key uint64) (uint, *nodeMapuint64uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint64uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint64Uintptr) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint64Uintptr) Set(key uint64, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint64Uintptr) Get(key uint64) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterUint64Uintptr struct {
	t     *MapUint64Uintptr
	nodes []*nodeMapuint64uintptr
	Key   uint64
	Value *uintptr
}

// Iterator returns a new IterUint64Uintptr.
func (t *MapUint64Uintptr) Iterator() *IterUint64Uintptr {
	var i IterUint64Uintptr
	i.t = t
	return &i
}

func (i *IterUint64Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint64uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint64uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint64uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint64uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint64uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapUint32Bool implements an associative array of bool indexed by uint32.
type MapUint32Bool struct {
	length int
	root   nodeMapuint32bool
}

type nodeMapuint32bool struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32bool or bool)
}

// Return walking direction
func (c nodeMapuint32bool) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32bool) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32bool) find(key uint32) (uint, *nodeMapuint32bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Bool) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Bool) Set(key uint32, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Bool) Get(key uint32) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterUint32Bool struct {
	t     *MapUint32Bool
	nodes []*nodeMapuint32bool
	Key   uint32
	Value *bool
}

// Iterator returns a new IterUint32Bool.
func (t *MapUint32Bool) Iterator() *IterUint32Bool {
	var i IterUint32Bool
	i.t = t
	return &i
}

func (i *IterUint32Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapUint32Byte implements an associative array of byte indexed by uint32.
type MapUint32Byte struct {
	length int
	root   nodeMapuint32byte
}

type nodeMapuint32byte struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32byte or byte)
}

// Return walking direction
func (c nodeMapuint32byte) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32byte) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32byte) find(key uint32) (uint, *nodeMapuint32byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Byte) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Byte) Set(key uint32, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Byte) Get(key uint32) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterUint32Byte struct {
	t     *MapUint32Byte
	nodes []*nodeMapuint32byte
	Key   uint32
	Value *byte
}

// Iterator returns a new IterUint32Byte.
func (t *MapUint32Byte) Iterator() *IterUint32Byte {
	var i IterUint32Byte
	i.t = t
	return &i
}

func (i *IterUint32Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapUint32Complex128 implements an associative array of complex128 indexed by uint32.
type MapUint32Complex128 struct {
	length int
	root   nodeMapuint32complex128
}

type nodeMapuint32complex128 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint32complex128) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex128) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32complex128) find(key uint32) (uint, *nodeMapuint32complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Complex128) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Complex128) Set(key uint32, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Complex128) Get(key uint32) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterUint32Complex128 struct {
	t     *MapUint32Complex128
	nodes []*nodeMapuint32complex128
	Key   uint32
	Value *complex128
}

// Iterator returns a new IterUint32Complex128.
func (t *MapUint32Complex128) Iterator() *IterUint32Complex128 {
	var i IterUint32Complex128
	i.t = t
	return &i
}

func (i *IterUint32Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapUint32Complex64 implements an associative array of complex64 indexed by uint32.
type MapUint32Complex64 struct {
	length int
	root   nodeMapuint32complex64
}

type nodeMapuint32complex64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint32complex64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32complex64) find(key uint32) (uint, *nodeMapuint32complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Complex64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Complex64) Set(key uint32, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Complex64) Get(key uint32) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterUint32Complex64 struct {
	t     *MapUint32Complex64
	nodes []*nodeMapuint32complex64
	Key   uint32
	Value *complex64
}

// Iterator returns a new IterUint32Complex64.
func (t *MapUint32Complex64) Iterator() *IterUint32Complex64 {
	var i IterUint32Complex64
	i.t = t
	return &i
}

func (i *IterUint32Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapUint32Error implements an associative array of error indexed by uint32.
type MapUint32Error struct {
	length int
	root   nodeMapuint32error
}

type nodeMapuint32error struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32error or error)
}

// Return walking direction
func (c nodeMapuint32error) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32error) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32error) find(key uint32) (uint, *nodeMapuint32error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Error) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Error) Set(key uint32, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Error) Get(key uint32) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Error) Length() int {
	return t.length
}

// func (c *nodeMapuint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterUint32Error struct {
	t     *MapUint32Error
	nodes []*nodeMapuint32error
	Key   uint32
	Value *error
}

// Iterator returns a new IterUint32Error.
func (t *MapUint32Error) Iterator() *IterUint32Error {
	var i IterUint32Error
	i.t = t
	return &i
}

func (i *IterUint32Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapUint32Float32 implements an associative array of float32 indexed by uint32.
type MapUint32Float32 struct {
	length int
	root   nodeMapuint32float32
}

type nodeMapuint32float32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float32 or float32)
}

// Return walking direction
func (c nodeMapuint32float32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32float32) find(key uint32) (uint, *nodeMapuint32float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Float32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Float32) Set(key uint32, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Float32) Get(key uint32) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterUint32Float32 struct {
	t     *MapUint32Float32
	nodes []*nodeMapuint32float32
	Key   uint32
	Value *float32
}

// Iterator returns a new IterUint32Float32.
func (t *MapUint32Float32) Iterator() *IterUint32Float32 {
	var i IterUint32Float32
	i.t = t
	return &i
}

func (i *IterUint32Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapUint32Float64 implements an associative array of float64 indexed by uint32.
type MapUint32Float64 struct {
	length int
	root   nodeMapuint32float64
}

type nodeMapuint32float64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float64 or float64)
}

// Return walking direction
func (c nodeMapuint32float64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32float64) find(key uint32) (uint, *nodeMapuint32float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Float64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Float64) Set(key uint32, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Float64) Get(key uint32) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterUint32Float64 struct {
	t     *MapUint32Float64
	nodes []*nodeMapuint32float64
	Key   uint32
	Value *float64
}

// Iterator returns a new IterUint32Float64.
func (t *MapUint32Float64) Iterator() *IterUint32Float64 {
	var i IterUint32Float64
	i.t = t
	return &i
}

func (i *IterUint32Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapUint32Int implements an associative array of int indexed by uint32.
type MapUint32Int struct {
	length int
	root   nodeMapuint32int
}

type nodeMapuint32int struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int or int)
}

// Return walking direction
func (c nodeMapuint32int) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int) find(key uint32) (uint, *nodeMapuint32int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Int) Set(key uint32, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Int) Get(key uint32) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int) Length() int {
	return t.length
}

// func (c *nodeMapuint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterUint32Int struct {
	t     *MapUint32Int
	nodes []*nodeMapuint32int
	Key   uint32
	Value *int
}

// Iterator returns a new IterUint32Int.
func (t *MapUint32Int) Iterator() *IterUint32Int {
	var i IterUint32Int
	i.t = t
	return &i
}

func (i *IterUint32Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapUint32Int16 implements an associative array of int16 indexed by uint32.
type MapUint32Int16 struct {
	length int
	root   nodeMapuint32int16
}

type nodeMapuint32int16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int16 or int16)
}

// Return walking direction
func (c nodeMapuint32int16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int16) find(key uint32) (uint, *nodeMapuint32int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Int16) Set(key uint32, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Int16) Get(key uint32) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterUint32Int16 struct {
	t     *MapUint32Int16
	nodes []*nodeMapuint32int16
	Key   uint32
	Value *int16
}

// Iterator returns a new IterUint32Int16.
func (t *MapUint32Int16) Iterator() *IterUint32Int16 {
	var i IterUint32Int16
	i.t = t
	return &i
}

func (i *IterUint32Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapUint32Int32 implements an associative array of int32 indexed by uint32.
type MapUint32Int32 struct {
	length int
	root   nodeMapuint32int32
}

type nodeMapuint32int32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int32 or int32)
}

// Return walking direction
func (c nodeMapuint32int32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int32) find(key uint32) (uint, *nodeMapuint32int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Int32) Set(key uint32, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Int32) Get(key uint32) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterUint32Int32 struct {
	t     *MapUint32Int32
	nodes []*nodeMapuint32int32
	Key   uint32
	Value *int32
}

// Iterator returns a new IterUint32Int32.
func (t *MapUint32Int32) Iterator() *IterUint32Int32 {
	var i IterUint32Int32
	i.t = t
	return &i
}

func (i *IterUint32Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapUint32Int64 implements an associative array of int64 indexed by uint32.
type MapUint32Int64 struct {
	length int
	root   nodeMapuint32int64
}

type nodeMapuint32int64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int64 or int64)
}

// Return walking direction
func (c nodeMapuint32int64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int64) find(key uint32) (uint, *nodeMapuint32int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Int64) Set(key uint32, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Int64) Get(key uint32) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterUint32Int64 struct {
	t     *MapUint32Int64
	nodes []*nodeMapuint32int64
	Key   uint32
	Value *int64
}

// Iterator returns a new IterUint32Int64.
func (t *MapUint32Int64) Iterator() *IterUint32Int64 {
	var i IterUint32Int64
	i.t = t
	return &i
}

func (i *IterUint32Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapUint32Int8 implements an associative array of int8 indexed by uint32.
type MapUint32Int8 struct {
	length int
	root   nodeMapuint32int8
}

type nodeMapuint32int8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int8 or int8)
}

// Return walking direction
func (c nodeMapuint32int8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32int8) find(key uint32) (uint, *nodeMapuint32int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Int8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Int8) Set(key uint32, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Int8) Get(key uint32) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterUint32Int8 struct {
	t     *MapUint32Int8
	nodes []*nodeMapuint32int8
	Key   uint32
	Value *int8
}

// Iterator returns a new IterUint32Int8.
func (t *MapUint32Int8) Iterator() *IterUint32Int8 {
	var i IterUint32Int8
	i.t = t
	return &i
}

func (i *IterUint32Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapUint32Rune implements an associative array of rune indexed by uint32.
type MapUint32Rune struct {
	length int
	root   nodeMapuint32rune
}

type nodeMapuint32rune struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32rune or rune)
}

// Return walking direction
func (c nodeMapuint32rune) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32rune) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32rune) find(key uint32) (uint, *nodeMapuint32rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Rune) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Rune) Set(key uint32, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Rune) Get(key uint32) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterUint32Rune struct {
	t     *MapUint32Rune
	nodes []*nodeMapuint32rune
	Key   uint32
	Value *rune
}

// Iterator returns a new IterUint32Rune.
func (t *MapUint32Rune) Iterator() *IterUint32Rune {
	var i IterUint32Rune
	i.t = t
	return &i
}

func (i *IterUint32Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapUint32String implements an associative array of string indexed by uint32.
type MapUint32String struct {
	length int
	root   nodeMapuint32string
}

type nodeMapuint32string struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32string or string)
}

// Return walking direction
func (c nodeMapuint32string) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32string) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32string) find(key uint32) (uint, *nodeMapuint32string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32String) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32String) Set(key uint32, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32String) Get(key uint32) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32String) Length() int {
	return t.length
}

// func (c *nodeMapuint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterUint32String struct {
	t     *MapUint32String
	nodes []*nodeMapuint32string
	Key   uint32
	Value *string
}

// Iterator returns a new IterUint32String.
func (t *MapUint32String) Iterator() *IterUint32String {
	var i IterUint32String
	i.t = t
	return &i
}

func (i *IterUint32String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapUint32Uint implements an associative array of uint indexed by uint32.
type MapUint32Uint struct {
	length int
	root   nodeMapuint32uint
}

type nodeMapuint32uint struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint or uint)
}

// Return walking direction
func (c nodeMapuint32uint) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint) find(key uint32) (uint, *nodeMapuint32uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uint) Set(key uint32, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uint) Get(key uint32) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterUint32Uint struct {
	t     *MapUint32Uint
	nodes []*nodeMapuint32uint
	Key   uint32
	Value *uint
}

// Iterator returns a new IterUint32Uint.
func (t *MapUint32Uint) Iterator() *IterUint32Uint {
	var i IterUint32Uint
	i.t = t
	return &i
}

func (i *IterUint32Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapUint32Uint16 implements an associative array of uint16 indexed by uint32.
type MapUint32Uint16 struct {
	length int
	root   nodeMapuint32uint16
}

type nodeMapuint32uint16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint32uint16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint16) find(key uint32) (uint, *nodeMapuint32uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uint16) Set(key uint32, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uint16) Get(key uint32) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterUint32Uint16 struct {
	t     *MapUint32Uint16
	nodes []*nodeMapuint32uint16
	Key   uint32
	Value *uint16
}

// Iterator returns a new IterUint32Uint16.
func (t *MapUint32Uint16) Iterator() *IterUint32Uint16 {
	var i IterUint32Uint16
	i.t = t
	return &i
}

func (i *IterUint32Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapUint32Uint32 implements an associative array of uint32 indexed by uint32.
type MapUint32Uint32 struct {
	length int
	root   nodeMapuint32uint32
}

type nodeMapuint32uint32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint32uint32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint32) find(key uint32) (uint, *nodeMapuint32uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uint32) Set(key uint32, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uint32) Get(key uint32) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterUint32Uint32 struct {
	t     *MapUint32Uint32
	nodes []*nodeMapuint32uint32
	Key   uint32
	Value *uint32
}

// Iterator returns a new IterUint32Uint32.
func (t *MapUint32Uint32) Iterator() *IterUint32Uint32 {
	var i IterUint32Uint32
	i.t = t
	return &i
}

func (i *IterUint32Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapUint32Uint64 implements an associative array of uint64 indexed by uint32.
type MapUint32Uint64 struct {
	length int
	root   nodeMapuint32uint64
}

type nodeMapuint32uint64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint32uint64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint64) find(key uint32) (uint, *nodeMapuint32uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uint64) Set(key uint32, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uint64) Get(key uint32) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterUint32Uint64 struct {
	t     *MapUint32Uint64
	nodes []*nodeMapuint32uint64
	Key   uint32
	Value *uint64
}

// Iterator returns a new IterUint32Uint64.
func (t *MapUint32Uint64) Iterator() *IterUint32Uint64 {
	var i IterUint32Uint64
	i.t = t
	return &i
}

func (i *IterUint32Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapUint32Uint8 implements an associative array of uint8 indexed by uint32.
type MapUint32Uint8 struct {
	length int
	root   nodeMapuint32uint8
}

type nodeMapuint32uint8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint32uint8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uint8) find(key uint32) (uint, *nodeMapuint32uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uint8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uint8) Set(key uint32, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uint8) Get(key uint32) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterUint32Uint8 struct {
	t     *MapUint32Uint8
	nodes []*nodeMapuint32uint8
	Key   uint32
	Value *uint8
}

// Iterator returns a new IterUint32Uint8.
func (t *MapUint32Uint8) Iterator() *IterUint32Uint8 {
	var i IterUint32Uint8
	i.t = t
	return &i
}

func (i *IterUint32Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapUint32Uintptr implements an associative array of uintptr indexed by uint32.
type MapUint32Uintptr struct {
	length int
	root   nodeMapuint32uintptr
}

type nodeMapuint32uintptr struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint32uintptr) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uintptr) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint32uintptr) find(key uint32) (uint, *nodeMapuint32uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint32uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint32Uintptr) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint32Uintptr) Set(key uint32, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint32Uintptr) Get(key uint32) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterUint32Uintptr struct {
	t     *MapUint32Uintptr
	nodes []*nodeMapuint32uintptr
	Key   uint32
	Value *uintptr
}

// Iterator returns a new IterUint32Uintptr.
func (t *MapUint32Uintptr) Iterator() *IterUint32Uintptr {
	var i IterUint32Uintptr
	i.t = t
	return &i
}

func (i *IterUint32Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint32uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint32uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint32uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint32uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint32uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapUint16Bool implements an associative array of bool indexed by uint16.
type MapUint16Bool struct {
	length int
	root   nodeMapuint16bool
}

type nodeMapuint16bool struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16bool or bool)
}

// Return walking direction
func (c nodeMapuint16bool) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16bool) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16bool) find(key uint16) (uint, *nodeMapuint16bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Bool) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Bool) Set(key uint16, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Bool) Get(key uint16) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterUint16Bool struct {
	t     *MapUint16Bool
	nodes []*nodeMapuint16bool
	Key   uint16
	Value *bool
}

// Iterator returns a new IterUint16Bool.
func (t *MapUint16Bool) Iterator() *IterUint16Bool {
	var i IterUint16Bool
	i.t = t
	return &i
}

func (i *IterUint16Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapUint16Byte implements an associative array of byte indexed by uint16.
type MapUint16Byte struct {
	length int
	root   nodeMapuint16byte
}

type nodeMapuint16byte struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16byte or byte)
}

// Return walking direction
func (c nodeMapuint16byte) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16byte) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16byte) find(key uint16) (uint, *nodeMapuint16byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Byte) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Byte) Set(key uint16, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Byte) Get(key uint16) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterUint16Byte struct {
	t     *MapUint16Byte
	nodes []*nodeMapuint16byte
	Key   uint16
	Value *byte
}

// Iterator returns a new IterUint16Byte.
func (t *MapUint16Byte) Iterator() *IterUint16Byte {
	var i IterUint16Byte
	i.t = t
	return &i
}

func (i *IterUint16Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapUint16Complex128 implements an associative array of complex128 indexed by uint16.
type MapUint16Complex128 struct {
	length int
	root   nodeMapuint16complex128
}

type nodeMapuint16complex128 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint16complex128) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex128) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16complex128) find(key uint16) (uint, *nodeMapuint16complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Complex128) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Complex128) Set(key uint16, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Complex128) Get(key uint16) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterUint16Complex128 struct {
	t     *MapUint16Complex128
	nodes []*nodeMapuint16complex128
	Key   uint16
	Value *complex128
}

// Iterator returns a new IterUint16Complex128.
func (t *MapUint16Complex128) Iterator() *IterUint16Complex128 {
	var i IterUint16Complex128
	i.t = t
	return &i
}

func (i *IterUint16Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapUint16Complex64 implements an associative array of complex64 indexed by uint16.
type MapUint16Complex64 struct {
	length int
	root   nodeMapuint16complex64
}

type nodeMapuint16complex64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint16complex64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16complex64) find(key uint16) (uint, *nodeMapuint16complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Complex64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Complex64) Set(key uint16, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Complex64) Get(key uint16) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterUint16Complex64 struct {
	t     *MapUint16Complex64
	nodes []*nodeMapuint16complex64
	Key   uint16
	Value *complex64
}

// Iterator returns a new IterUint16Complex64.
func (t *MapUint16Complex64) Iterator() *IterUint16Complex64 {
	var i IterUint16Complex64
	i.t = t
	return &i
}

func (i *IterUint16Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapUint16Error implements an associative array of error indexed by uint16.
type MapUint16Error struct {
	length int
	root   nodeMapuint16error
}

type nodeMapuint16error struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16error or error)
}

// Return walking direction
func (c nodeMapuint16error) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16error) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16error) find(key uint16) (uint, *nodeMapuint16error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Error) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Error) Set(key uint16, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Error) Get(key uint16) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Error) Length() int {
	return t.length
}

// func (c *nodeMapuint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterUint16Error struct {
	t     *MapUint16Error
	nodes []*nodeMapuint16error
	Key   uint16
	Value *error
}

// Iterator returns a new IterUint16Error.
func (t *MapUint16Error) Iterator() *IterUint16Error {
	var i IterUint16Error
	i.t = t
	return &i
}

func (i *IterUint16Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapUint16Float32 implements an associative array of float32 indexed by uint16.
type MapUint16Float32 struct {
	length int
	root   nodeMapuint16float32
}

type nodeMapuint16float32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float32 or float32)
}

// Return walking direction
func (c nodeMapuint16float32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16float32) find(key uint16) (uint, *nodeMapuint16float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Float32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Float32) Set(key uint16, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Float32) Get(key uint16) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterUint16Float32 struct {
	t     *MapUint16Float32
	nodes []*nodeMapuint16float32
	Key   uint16
	Value *float32
}

// Iterator returns a new IterUint16Float32.
func (t *MapUint16Float32) Iterator() *IterUint16Float32 {
	var i IterUint16Float32
	i.t = t
	return &i
}

func (i *IterUint16Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapUint16Float64 implements an associative array of float64 indexed by uint16.
type MapUint16Float64 struct {
	length int
	root   nodeMapuint16float64
}

type nodeMapuint16float64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float64 or float64)
}

// Return walking direction
func (c nodeMapuint16float64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16float64) find(key uint16) (uint, *nodeMapuint16float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Float64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Float64) Set(key uint16, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Float64) Get(key uint16) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterUint16Float64 struct {
	t     *MapUint16Float64
	nodes []*nodeMapuint16float64
	Key   uint16
	Value *float64
}

// Iterator returns a new IterUint16Float64.
func (t *MapUint16Float64) Iterator() *IterUint16Float64 {
	var i IterUint16Float64
	i.t = t
	return &i
}

func (i *IterUint16Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapUint16Int implements an associative array of int indexed by uint16.
type MapUint16Int struct {
	length int
	root   nodeMapuint16int
}

type nodeMapuint16int struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int or int)
}

// Return walking direction
func (c nodeMapuint16int) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int) find(key uint16) (uint, *nodeMapuint16int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Int) Set(key uint16, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Int) Get(key uint16) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int) Length() int {
	return t.length
}

// func (c *nodeMapuint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterUint16Int struct {
	t     *MapUint16Int
	nodes []*nodeMapuint16int
	Key   uint16
	Value *int
}

// Iterator returns a new IterUint16Int.
func (t *MapUint16Int) Iterator() *IterUint16Int {
	var i IterUint16Int
	i.t = t
	return &i
}

func (i *IterUint16Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapUint16Int16 implements an associative array of int16 indexed by uint16.
type MapUint16Int16 struct {
	length int
	root   nodeMapuint16int16
}

type nodeMapuint16int16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int16 or int16)
}

// Return walking direction
func (c nodeMapuint16int16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int16) find(key uint16) (uint, *nodeMapuint16int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Int16) Set(key uint16, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Int16) Get(key uint16) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterUint16Int16 struct {
	t     *MapUint16Int16
	nodes []*nodeMapuint16int16
	Key   uint16
	Value *int16
}

// Iterator returns a new IterUint16Int16.
func (t *MapUint16Int16) Iterator() *IterUint16Int16 {
	var i IterUint16Int16
	i.t = t
	return &i
}

func (i *IterUint16Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapUint16Int32 implements an associative array of int32 indexed by uint16.
type MapUint16Int32 struct {
	length int
	root   nodeMapuint16int32
}

type nodeMapuint16int32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int32 or int32)
}

// Return walking direction
func (c nodeMapuint16int32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int32) find(key uint16) (uint, *nodeMapuint16int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Int32) Set(key uint16, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Int32) Get(key uint16) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterUint16Int32 struct {
	t     *MapUint16Int32
	nodes []*nodeMapuint16int32
	Key   uint16
	Value *int32
}

// Iterator returns a new IterUint16Int32.
func (t *MapUint16Int32) Iterator() *IterUint16Int32 {
	var i IterUint16Int32
	i.t = t
	return &i
}

func (i *IterUint16Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapUint16Int64 implements an associative array of int64 indexed by uint16.
type MapUint16Int64 struct {
	length int
	root   nodeMapuint16int64
}

type nodeMapuint16int64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int64 or int64)
}

// Return walking direction
func (c nodeMapuint16int64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int64) find(key uint16) (uint, *nodeMapuint16int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Int64) Set(key uint16, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Int64) Get(key uint16) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterUint16Int64 struct {
	t     *MapUint16Int64
	nodes []*nodeMapuint16int64
	Key   uint16
	Value *int64
}

// Iterator returns a new IterUint16Int64.
func (t *MapUint16Int64) Iterator() *IterUint16Int64 {
	var i IterUint16Int64
	i.t = t
	return &i
}

func (i *IterUint16Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapUint16Int8 implements an associative array of int8 indexed by uint16.
type MapUint16Int8 struct {
	length int
	root   nodeMapuint16int8
}

type nodeMapuint16int8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int8 or int8)
}

// Return walking direction
func (c nodeMapuint16int8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16int8) find(key uint16) (uint, *nodeMapuint16int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Int8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Int8) Set(key uint16, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Int8) Get(key uint16) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterUint16Int8 struct {
	t     *MapUint16Int8
	nodes []*nodeMapuint16int8
	Key   uint16
	Value *int8
}

// Iterator returns a new IterUint16Int8.
func (t *MapUint16Int8) Iterator() *IterUint16Int8 {
	var i IterUint16Int8
	i.t = t
	return &i
}

func (i *IterUint16Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapUint16Rune implements an associative array of rune indexed by uint16.
type MapUint16Rune struct {
	length int
	root   nodeMapuint16rune
}

type nodeMapuint16rune struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16rune or rune)
}

// Return walking direction
func (c nodeMapuint16rune) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16rune) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16rune) find(key uint16) (uint, *nodeMapuint16rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Rune) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Rune) Set(key uint16, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Rune) Get(key uint16) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterUint16Rune struct {
	t     *MapUint16Rune
	nodes []*nodeMapuint16rune
	Key   uint16
	Value *rune
}

// Iterator returns a new IterUint16Rune.
func (t *MapUint16Rune) Iterator() *IterUint16Rune {
	var i IterUint16Rune
	i.t = t
	return &i
}

func (i *IterUint16Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapUint16String implements an associative array of string indexed by uint16.
type MapUint16String struct {
	length int
	root   nodeMapuint16string
}

type nodeMapuint16string struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16string or string)
}

// Return walking direction
func (c nodeMapuint16string) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16string) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16string) find(key uint16) (uint, *nodeMapuint16string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16String) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16String) Set(key uint16, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16String) Get(key uint16) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16String) Length() int {
	return t.length
}

// func (c *nodeMapuint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterUint16String struct {
	t     *MapUint16String
	nodes []*nodeMapuint16string
	Key   uint16
	Value *string
}

// Iterator returns a new IterUint16String.
func (t *MapUint16String) Iterator() *IterUint16String {
	var i IterUint16String
	i.t = t
	return &i
}

func (i *IterUint16String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapUint16Uint implements an associative array of uint indexed by uint16.
type MapUint16Uint struct {
	length int
	root   nodeMapuint16uint
}

type nodeMapuint16uint struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint or uint)
}

// Return walking direction
func (c nodeMapuint16uint) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint) find(key uint16) (uint, *nodeMapuint16uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uint) Set(key uint16, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uint) Get(key uint16) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterUint16Uint struct {
	t     *MapUint16Uint
	nodes []*nodeMapuint16uint
	Key   uint16
	Value *uint
}

// Iterator returns a new IterUint16Uint.
func (t *MapUint16Uint) Iterator() *IterUint16Uint {
	var i IterUint16Uint
	i.t = t
	return &i
}

func (i *IterUint16Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapUint16Uint16 implements an associative array of uint16 indexed by uint16.
type MapUint16Uint16 struct {
	length int
	root   nodeMapuint16uint16
}

type nodeMapuint16uint16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint16uint16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint16) find(key uint16) (uint, *nodeMapuint16uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uint16) Set(key uint16, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uint16) Get(key uint16) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterUint16Uint16 struct {
	t     *MapUint16Uint16
	nodes []*nodeMapuint16uint16
	Key   uint16
	Value *uint16
}

// Iterator returns a new IterUint16Uint16.
func (t *MapUint16Uint16) Iterator() *IterUint16Uint16 {
	var i IterUint16Uint16
	i.t = t
	return &i
}

func (i *IterUint16Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapUint16Uint32 implements an associative array of uint32 indexed by uint16.
type MapUint16Uint32 struct {
	length int
	root   nodeMapuint16uint32
}

type nodeMapuint16uint32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint16uint32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint32) find(key uint16) (uint, *nodeMapuint16uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uint32) Set(key uint16, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uint32) Get(key uint16) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterUint16Uint32 struct {
	t     *MapUint16Uint32
	nodes []*nodeMapuint16uint32
	Key   uint16
	Value *uint32
}

// Iterator returns a new IterUint16Uint32.
func (t *MapUint16Uint32) Iterator() *IterUint16Uint32 {
	var i IterUint16Uint32
	i.t = t
	return &i
}

func (i *IterUint16Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapUint16Uint64 implements an associative array of uint64 indexed by uint16.
type MapUint16Uint64 struct {
	length int
	root   nodeMapuint16uint64
}

type nodeMapuint16uint64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint16uint64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint64) find(key uint16) (uint, *nodeMapuint16uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uint64) Set(key uint16, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uint64) Get(key uint16) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterUint16Uint64 struct {
	t     *MapUint16Uint64
	nodes []*nodeMapuint16uint64
	Key   uint16
	Value *uint64
}

// Iterator returns a new IterUint16Uint64.
func (t *MapUint16Uint64) Iterator() *IterUint16Uint64 {
	var i IterUint16Uint64
	i.t = t
	return &i
}

func (i *IterUint16Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapUint16Uint8 implements an associative array of uint8 indexed by uint16.
type MapUint16Uint8 struct {
	length int
	root   nodeMapuint16uint8
}

type nodeMapuint16uint8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint16uint8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uint8) find(key uint16) (uint, *nodeMapuint16uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uint8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uint8) Set(key uint16, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uint8) Get(key uint16) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterUint16Uint8 struct {
	t     *MapUint16Uint8
	nodes []*nodeMapuint16uint8
	Key   uint16
	Value *uint8
}

// Iterator returns a new IterUint16Uint8.
func (t *MapUint16Uint8) Iterator() *IterUint16Uint8 {
	var i IterUint16Uint8
	i.t = t
	return &i
}

func (i *IterUint16Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapUint16Uintptr implements an associative array of uintptr indexed by uint16.
type MapUint16Uintptr struct {
	length int
	root   nodeMapuint16uintptr
}

type nodeMapuint16uintptr struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint16uintptr) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uintptr) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint16uintptr) find(key uint16) (uint, *nodeMapuint16uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint16uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint16Uintptr) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint16Uintptr) Set(key uint16, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint16Uintptr) Get(key uint16) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterUint16Uintptr struct {
	t     *MapUint16Uintptr
	nodes []*nodeMapuint16uintptr
	Key   uint16
	Value *uintptr
}

// Iterator returns a new IterUint16Uintptr.
func (t *MapUint16Uintptr) Iterator() *IterUint16Uintptr {
	var i IterUint16Uintptr
	i.t = t
	return &i
}

func (i *IterUint16Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint16uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint16uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint16uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint16uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint16uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}

// MapUint8Bool implements an associative array of bool indexed by uint8.
type MapUint8Bool struct {
	length int
	root   nodeMapuint8bool
}

type nodeMapuint8bool struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8bool or bool)
}

// Return walking direction
func (c nodeMapuint8bool) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8bool) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8bool) find(key uint8) (uint, *nodeMapuint8bool) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8bool)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Bool) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Bool) Set(key uint8, val bool) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Bool) Get(key uint8) (bool, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero bool
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*bool)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

type IterUint8Bool struct {
	t     *MapUint8Bool
	nodes []*nodeMapuint8bool
	Key   uint8
	Value *bool
}

// Iterator returns a new IterUint8Bool.
func (t *MapUint8Bool) Iterator() *IterUint8Bool {
	var i IterUint8Bool
	i.t = t
	return &i
}

func (i *IterUint8Bool) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8bool, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8bool)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8bool)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8bool = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8bool)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*bool)(next.child)
	return true
}

// MapUint8Byte implements an associative array of byte indexed by uint8.
type MapUint8Byte struct {
	length int
	root   nodeMapuint8byte
}

type nodeMapuint8byte struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8byte or byte)
}

// Return walking direction
func (c nodeMapuint8byte) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8byte) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8byte) find(key uint8) (uint, *nodeMapuint8byte) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8byte)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Byte) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Byte) Set(key uint8, val byte) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Byte) Get(key uint8) (byte, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero byte
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*byte)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

type IterUint8Byte struct {
	t     *MapUint8Byte
	nodes []*nodeMapuint8byte
	Key   uint8
	Value *byte
}

// Iterator returns a new IterUint8Byte.
func (t *MapUint8Byte) Iterator() *IterUint8Byte {
	var i IterUint8Byte
	i.t = t
	return &i
}

func (i *IterUint8Byte) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8byte, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8byte)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8byte)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8byte = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8byte)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*byte)(next.child)
	return true
}

// MapUint8Complex128 implements an associative array of complex128 indexed by uint8.
type MapUint8Complex128 struct {
	length int
	root   nodeMapuint8complex128
}

type nodeMapuint8complex128 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint8complex128) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex128) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8complex128) find(key uint8) (uint, *nodeMapuint8complex128) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8complex128)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Complex128) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Complex128) Set(key uint8, val complex128) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Complex128) Get(key uint8) (complex128, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex128
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex128)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

type IterUint8Complex128 struct {
	t     *MapUint8Complex128
	nodes []*nodeMapuint8complex128
	Key   uint8
	Value *complex128
}

// Iterator returns a new IterUint8Complex128.
func (t *MapUint8Complex128) Iterator() *IterUint8Complex128 {
	var i IterUint8Complex128
	i.t = t
	return &i
}

func (i *IterUint8Complex128) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8complex128, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8complex128)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8complex128)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8complex128 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8complex128)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex128)(next.child)
	return true
}

// MapUint8Complex64 implements an associative array of complex64 indexed by uint8.
type MapUint8Complex64 struct {
	length int
	root   nodeMapuint8complex64
}

type nodeMapuint8complex64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint8complex64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8complex64) find(key uint8) (uint, *nodeMapuint8complex64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8complex64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Complex64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Complex64) Set(key uint8, val complex64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Complex64) Get(key uint8) (complex64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero complex64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*complex64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

type IterUint8Complex64 struct {
	t     *MapUint8Complex64
	nodes []*nodeMapuint8complex64
	Key   uint8
	Value *complex64
}

// Iterator returns a new IterUint8Complex64.
func (t *MapUint8Complex64) Iterator() *IterUint8Complex64 {
	var i IterUint8Complex64
	i.t = t
	return &i
}

func (i *IterUint8Complex64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8complex64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8complex64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8complex64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8complex64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8complex64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*complex64)(next.child)
	return true
}

// MapUint8Error implements an associative array of error indexed by uint8.
type MapUint8Error struct {
	length int
	root   nodeMapuint8error
}

type nodeMapuint8error struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8error or error)
}

// Return walking direction
func (c nodeMapuint8error) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8error) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8error) find(key uint8) (uint, *nodeMapuint8error) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8error)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Error) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Error) Set(key uint8, val error) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Error) Get(key uint8) (error, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero error
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*error)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Error) Length() int {
	return t.length
}

// func (c *nodeMapuint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

type IterUint8Error struct {
	t     *MapUint8Error
	nodes []*nodeMapuint8error
	Key   uint8
	Value *error
}

// Iterator returns a new IterUint8Error.
func (t *MapUint8Error) Iterator() *IterUint8Error {
	var i IterUint8Error
	i.t = t
	return &i
}

func (i *IterUint8Error) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8error, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8error)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8error)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8error = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8error)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*error)(next.child)
	return true
}

// MapUint8Float32 implements an associative array of float32 indexed by uint8.
type MapUint8Float32 struct {
	length int
	root   nodeMapuint8float32
}

type nodeMapuint8float32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float32 or float32)
}

// Return walking direction
func (c nodeMapuint8float32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8float32) find(key uint8) (uint, *nodeMapuint8float32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8float32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Float32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Float32) Set(key uint8, val float32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Float32) Get(key uint8) (float32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

type IterUint8Float32 struct {
	t     *MapUint8Float32
	nodes []*nodeMapuint8float32
	Key   uint8
	Value *float32
}

// Iterator returns a new IterUint8Float32.
func (t *MapUint8Float32) Iterator() *IterUint8Float32 {
	var i IterUint8Float32
	i.t = t
	return &i
}

func (i *IterUint8Float32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8float32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8float32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8float32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8float32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8float32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float32)(next.child)
	return true
}

// MapUint8Float64 implements an associative array of float64 indexed by uint8.
type MapUint8Float64 struct {
	length int
	root   nodeMapuint8float64
}

type nodeMapuint8float64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float64 or float64)
}

// Return walking direction
func (c nodeMapuint8float64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8float64) find(key uint8) (uint, *nodeMapuint8float64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8float64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Float64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Float64) Set(key uint8, val float64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Float64) Get(key uint8) (float64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero float64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*float64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

type IterUint8Float64 struct {
	t     *MapUint8Float64
	nodes []*nodeMapuint8float64
	Key   uint8
	Value *float64
}

// Iterator returns a new IterUint8Float64.
func (t *MapUint8Float64) Iterator() *IterUint8Float64 {
	var i IterUint8Float64
	i.t = t
	return &i
}

func (i *IterUint8Float64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8float64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8float64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8float64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8float64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8float64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*float64)(next.child)
	return true
}

// MapUint8Int implements an associative array of int indexed by uint8.
type MapUint8Int struct {
	length int
	root   nodeMapuint8int
}

type nodeMapuint8int struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int or int)
}

// Return walking direction
func (c nodeMapuint8int) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int) find(key uint8) (uint, *nodeMapuint8int) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8int)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Int) Set(key uint8, val int) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Int) Get(key uint8) (int, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int) Length() int {
	return t.length
}

// func (c *nodeMapuint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

type IterUint8Int struct {
	t     *MapUint8Int
	nodes []*nodeMapuint8int
	Key   uint8
	Value *int
}

// Iterator returns a new IterUint8Int.
func (t *MapUint8Int) Iterator() *IterUint8Int {
	var i IterUint8Int
	i.t = t
	return &i
}

func (i *IterUint8Int) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8int, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8int)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8int)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int)(next.child)
	return true
}

// MapUint8Int16 implements an associative array of int16 indexed by uint8.
type MapUint8Int16 struct {
	length int
	root   nodeMapuint8int16
}

type nodeMapuint8int16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int16 or int16)
}

// Return walking direction
func (c nodeMapuint8int16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int16) find(key uint8) (uint, *nodeMapuint8int16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8int16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Int16) Set(key uint8, val int16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Int16) Get(key uint8) (int16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

type IterUint8Int16 struct {
	t     *MapUint8Int16
	nodes []*nodeMapuint8int16
	Key   uint8
	Value *int16
}

// Iterator returns a new IterUint8Int16.
func (t *MapUint8Int16) Iterator() *IterUint8Int16 {
	var i IterUint8Int16
	i.t = t
	return &i
}

func (i *IterUint8Int16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8int16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8int16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8int16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int16)(next.child)
	return true
}

// MapUint8Int32 implements an associative array of int32 indexed by uint8.
type MapUint8Int32 struct {
	length int
	root   nodeMapuint8int32
}

type nodeMapuint8int32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int32 or int32)
}

// Return walking direction
func (c nodeMapuint8int32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int32) find(key uint8) (uint, *nodeMapuint8int32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8int32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Int32) Set(key uint8, val int32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Int32) Get(key uint8) (int32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

type IterUint8Int32 struct {
	t     *MapUint8Int32
	nodes []*nodeMapuint8int32
	Key   uint8
	Value *int32
}

// Iterator returns a new IterUint8Int32.
func (t *MapUint8Int32) Iterator() *IterUint8Int32 {
	var i IterUint8Int32
	i.t = t
	return &i
}

func (i *IterUint8Int32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8int32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8int32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8int32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int32)(next.child)
	return true
}

// MapUint8Int64 implements an associative array of int64 indexed by uint8.
type MapUint8Int64 struct {
	length int
	root   nodeMapuint8int64
}

type nodeMapuint8int64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int64 or int64)
}

// Return walking direction
func (c nodeMapuint8int64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int64) find(key uint8) (uint, *nodeMapuint8int64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8int64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Int64) Set(key uint8, val int64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Int64) Get(key uint8) (int64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

type IterUint8Int64 struct {
	t     *MapUint8Int64
	nodes []*nodeMapuint8int64
	Key   uint8
	Value *int64
}

// Iterator returns a new IterUint8Int64.
func (t *MapUint8Int64) Iterator() *IterUint8Int64 {
	var i IterUint8Int64
	i.t = t
	return &i
}

func (i *IterUint8Int64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8int64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8int64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8int64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int64)(next.child)
	return true
}

// MapUint8Int8 implements an associative array of int8 indexed by uint8.
type MapUint8Int8 struct {
	length int
	root   nodeMapuint8int8
}

type nodeMapuint8int8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int8 or int8)
}

// Return walking direction
func (c nodeMapuint8int8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8int8) find(key uint8) (uint, *nodeMapuint8int8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8int8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Int8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Int8) Set(key uint8, val int8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Int8) Get(key uint8) (int8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero int8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*int8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

type IterUint8Int8 struct {
	t     *MapUint8Int8
	nodes []*nodeMapuint8int8
	Key   uint8
	Value *int8
}

// Iterator returns a new IterUint8Int8.
func (t *MapUint8Int8) Iterator() *IterUint8Int8 {
	var i IterUint8Int8
	i.t = t
	return &i
}

func (i *IterUint8Int8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8int8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8int8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8int8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8int8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8int8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*int8)(next.child)
	return true
}

// MapUint8Rune implements an associative array of rune indexed by uint8.
type MapUint8Rune struct {
	length int
	root   nodeMapuint8rune
}

type nodeMapuint8rune struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8rune or rune)
}

// Return walking direction
func (c nodeMapuint8rune) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8rune) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8rune) find(key uint8) (uint, *nodeMapuint8rune) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8rune)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Rune) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Rune) Set(key uint8, val rune) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Rune) Get(key uint8) (rune, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero rune
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*rune)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

type IterUint8Rune struct {
	t     *MapUint8Rune
	nodes []*nodeMapuint8rune
	Key   uint8
	Value *rune
}

// Iterator returns a new IterUint8Rune.
func (t *MapUint8Rune) Iterator() *IterUint8Rune {
	var i IterUint8Rune
	i.t = t
	return &i
}

func (i *IterUint8Rune) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8rune, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8rune)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8rune)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8rune = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8rune)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*rune)(next.child)
	return true
}

// MapUint8String implements an associative array of string indexed by uint8.
type MapUint8String struct {
	length int
	root   nodeMapuint8string
}

type nodeMapuint8string struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8string or string)
}

// Return walking direction
func (c nodeMapuint8string) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8string) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8string) find(key uint8) (uint, *nodeMapuint8string) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8string)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8String) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8String) Set(key uint8, val string) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8String) Get(key uint8) (string, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero string
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*string)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8String) Length() int {
	return t.length
}

// func (c *nodeMapuint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

type IterUint8String struct {
	t     *MapUint8String
	nodes []*nodeMapuint8string
	Key   uint8
	Value *string
}

// Iterator returns a new IterUint8String.
func (t *MapUint8String) Iterator() *IterUint8String {
	var i IterUint8String
	i.t = t
	return &i
}

func (i *IterUint8String) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8string, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8string)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8string)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8string = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8string)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*string)(next.child)
	return true
}

// MapUint8Uint implements an associative array of uint indexed by uint8.
type MapUint8Uint struct {
	length int
	root   nodeMapuint8uint
}

type nodeMapuint8uint struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint or uint)
}

// Return walking direction
func (c nodeMapuint8uint) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint) find(key uint8) (uint, *nodeMapuint8uint) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uint)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uint) Set(key uint8, val uint) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uint) Get(key uint8) (uint, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

type IterUint8Uint struct {
	t     *MapUint8Uint
	nodes []*nodeMapuint8uint
	Key   uint8
	Value *uint
}

// Iterator returns a new IterUint8Uint.
func (t *MapUint8Uint) Iterator() *IterUint8Uint {
	var i IterUint8Uint
	i.t = t
	return &i
}

func (i *IterUint8Uint) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uint, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uint)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uint)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint)(next.child)
	return true
}

// MapUint8Uint16 implements an associative array of uint16 indexed by uint8.
type MapUint8Uint16 struct {
	length int
	root   nodeMapuint8uint16
}

type nodeMapuint8uint16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint8uint16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint16) find(key uint8) (uint, *nodeMapuint8uint16) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uint16)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uint16) Set(key uint8, val uint16) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uint16) Get(key uint8) (uint16, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint16
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint16)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

type IterUint8Uint16 struct {
	t     *MapUint8Uint16
	nodes []*nodeMapuint8uint16
	Key   uint8
	Value *uint16
}

// Iterator returns a new IterUint8Uint16.
func (t *MapUint8Uint16) Iterator() *IterUint8Uint16 {
	var i IterUint8Uint16
	i.t = t
	return &i
}

func (i *IterUint8Uint16) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uint16, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uint16)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uint16)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint16 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint16)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint16)(next.child)
	return true
}

// MapUint8Uint32 implements an associative array of uint32 indexed by uint8.
type MapUint8Uint32 struct {
	length int
	root   nodeMapuint8uint32
}

type nodeMapuint8uint32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint8uint32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint32) find(key uint8) (uint, *nodeMapuint8uint32) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uint32)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uint32) Set(key uint8, val uint32) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uint32) Get(key uint8) (uint32, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint32
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint32)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

type IterUint8Uint32 struct {
	t     *MapUint8Uint32
	nodes []*nodeMapuint8uint32
	Key   uint8
	Value *uint32
}

// Iterator returns a new IterUint8Uint32.
func (t *MapUint8Uint32) Iterator() *IterUint8Uint32 {
	var i IterUint8Uint32
	i.t = t
	return &i
}

func (i *IterUint8Uint32) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uint32, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uint32)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uint32)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint32 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint32)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint32)(next.child)
	return true
}

// MapUint8Uint64 implements an associative array of uint64 indexed by uint8.
type MapUint8Uint64 struct {
	length int
	root   nodeMapuint8uint64
}

type nodeMapuint8uint64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint8uint64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint64) find(key uint8) (uint, *nodeMapuint8uint64) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uint64)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uint64) Set(key uint8, val uint64) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uint64) Get(key uint8) (uint64, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint64
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint64)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

type IterUint8Uint64 struct {
	t     *MapUint8Uint64
	nodes []*nodeMapuint8uint64
	Key   uint8
	Value *uint64
}

// Iterator returns a new IterUint8Uint64.
func (t *MapUint8Uint64) Iterator() *IterUint8Uint64 {
	var i IterUint8Uint64
	i.t = t
	return &i
}

func (i *IterUint8Uint64) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uint64, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uint64)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uint64)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint64 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint64)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint64)(next.child)
	return true
}

// MapUint8Uint8 implements an associative array of uint8 indexed by uint8.
type MapUint8Uint8 struct {
	length int
	root   nodeMapuint8uint8
}

type nodeMapuint8uint8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint8uint8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uint8) find(key uint8) (uint, *nodeMapuint8uint8) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uint8)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uint8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uint8) Set(key uint8, val uint8) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uint8) Get(key uint8) (uint8, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uint8
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uint8)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

type IterUint8Uint8 struct {
	t     *MapUint8Uint8
	nodes []*nodeMapuint8uint8
	Key   uint8
	Value *uint8
}

// Iterator returns a new IterUint8Uint8.
func (t *MapUint8Uint8) Iterator() *IterUint8Uint8 {
	var i IterUint8Uint8
	i.t = t
	return &i
}

func (i *IterUint8Uint8) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uint8, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uint8)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uint8)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uint8 = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uint8)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uint8)(next.child)
	return true
}

// MapUint8Uintptr implements an associative array of uintptr indexed by uint8.
type MapUint8Uintptr struct {
	length int
	root   nodeMapuint8uintptr
}

type nodeMapuint8uintptr struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint8uintptr) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uintptr) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
func (c *nodeMapuint8uintptr) find(key uint8) (uint, *nodeMapuint8uintptr) {
	//fmt.Println("  Find start", key)
	var crit = c.findCrit(key)
	// Keep going deeper until !(c.crit != ^uint(0) && c.crit == crit).
	for c.crit != ^uint(0) && c.crit == crit {
		//fmt.Printf("    Go deeper. Prefix: %08b, Key: %08b, Crit: %d, Dir: %d\n", c.key, key, crit, c.dir(key))
		c = &(*[2]nodeMapuint8uintptr)(c.child)[c.dir(key)]
		crit = c.findCrit(key)
	}
	//fmt.Println("    Find end", crit, key, c.key)
	return crit, c
}

func (t *MapUint8Uintptr) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Add increases the frequency of the provided key by inc
func (t *MapUint8Uintptr) Set(key uint8, val uintptr) {
	key = t.transformKey(key)
	//fmt.Println("Set", key, val)
	//defer t.root.dbg("  ")
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(&val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(&val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(&val)
}

// Get returns the value associated with the provided key and true if the key exists.
// Otherwise 0 and false are returned
func (t *MapUint8Uintptr) Get(key uint8) (uintptr, bool) {
	key = t.transformKey(key)
	//fmt.Println("Get", key)
	var zero uintptr
	if t.length == 0 {
		return zero, false
	}
	// Find leaf node
	var crit, l = t.root.find(key)
	if crit == ^uint(0) {
		return *(*uintptr)(l.child), true
	}
	return zero, false
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", c.key, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

type IterUint8Uintptr struct {
	t     *MapUint8Uintptr
	nodes []*nodeMapuint8uintptr
	Key   uint8
	Value *uintptr
}

// Iterator returns a new IterUint8Uintptr.
func (t *MapUint8Uintptr) Iterator() *IterUint8Uintptr {
	var i IterUint8Uintptr
	i.t = t
	return &i
}

func (i *IterUint8Uintptr) Next() bool {
	if i.nodes == nil {
		// First use
		if i.t.length == 0 {
			return false
		}
		i.nodes = make([]*nodeMapuint8uintptr, 1, 64)
		i.nodes[0] = &i.t.root
	} else {
		// Go up until a left node is found
		var d = len(i.nodes)
		for &(*[2]nodeMapuint8uintptr)(i.nodes[d-2].child)[0] != i.nodes[d-1] {
			if d--; d < 2 {
				return false
			}
		}
		// Go right
		i.nodes[d-1] = &(*[2]nodeMapuint8uintptr)(i.nodes[d-2].child)[1]
		i.nodes = i.nodes[0:d]
	}
	// Go left until next leaf is found
	var next *nodeMapuint8uintptr = i.nodes[len(i.nodes)-1]
	for next.crit != ^uint(0) {
		next = &(*[2]nodeMapuint8uintptr)(next.child)[0]
		i.nodes = append(i.nodes, next)
	}
	i.Key = i.t.transformKey(next.key)
	i.Value = (*uintptr)(next.child)
	return true
}
