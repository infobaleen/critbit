// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package critbit

import "unsafe"

// MapIntBool implements an associative array of bool indexed by int.
type MapIntBool struct {
	length int
	root   nodeMapintbool
}

// NewMapIntBool returns a new map with keys of type int and values of type bool
func NewMapIntBool() *MapIntBool {
	var r MapIntBool
	return &r
}

type nodeMapintbool struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbool or bool)
}

// Return walking direction
func (c nodeMapintbool) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbool) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintbool) children() *[2]nodeMapintbool {
	return (*[2]nodeMapintbool)(c.child)
}

func (c *nodeMapintbool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintbool) find(key int) (crit uint, child, parent *nodeMapintbool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntBool) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntBool) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntBool) SetP(key int, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntBool) Set(key int, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntBool) GetP(key int) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntBool) Get(key int) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntBool) Length() int {
	return t.length
}

// func (c *nodeMapintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterIntBool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntBool struct {
	t       *MapIntBool
	nodes   []*nodeMapintbool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int   // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntBool.
func (t *MapIntBool) Iterator() *IterIntBool {
	var i IterIntBool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntBool) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntBool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintbool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntBool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntBool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntBool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntByte implements an associative array of byte indexed by int.
type MapIntByte struct {
	length int
	root   nodeMapintbyte
}

// NewMapIntByte returns a new map with keys of type int and values of type byte
func NewMapIntByte() *MapIntByte {
	var r MapIntByte
	return &r
}

type nodeMapintbyte struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintbyte or byte)
}

// Return walking direction
func (c nodeMapintbyte) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintbyte) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintbyte) children() *[2]nodeMapintbyte {
	return (*[2]nodeMapintbyte)(c.child)
}

func (c *nodeMapintbyte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintbyte) find(key int) (crit uint, child, parent *nodeMapintbyte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntByte) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntByte) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntByte) SetP(key int, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntByte) Set(key int, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntByte) GetP(key int) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntByte) Get(key int) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntByte) Length() int {
	return t.length
}

// func (c *nodeMapintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterIntByte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntByte struct {
	t       *MapIntByte
	nodes   []*nodeMapintbyte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int   // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntByte.
func (t *MapIntByte) Iterator() *IterIntByte {
	var i IterIntByte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntByte) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntByte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintbyte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntByte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntByte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntByte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntComplex128 implements an associative array of complex128 indexed by int.
type MapIntComplex128 struct {
	length int
	root   nodeMapintcomplex128
}

// NewMapIntComplex128 returns a new map with keys of type int and values of type complex128
func NewMapIntComplex128() *MapIntComplex128 {
	var r MapIntComplex128
	return &r
}

type nodeMapintcomplex128 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapintcomplex128) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex128) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintcomplex128) children() *[2]nodeMapintcomplex128 {
	return (*[2]nodeMapintcomplex128)(c.child)
}

func (c *nodeMapintcomplex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintcomplex128) find(key int) (crit uint, child, parent *nodeMapintcomplex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntComplex128) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntComplex128) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntComplex128) SetP(key int, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntComplex128) Set(key int, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntComplex128) GetP(key int) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntComplex128) Get(key int) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex128) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterIntComplex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntComplex128 struct {
	t       *MapIntComplex128
	nodes   []*nodeMapintcomplex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int         // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntComplex128.
func (t *MapIntComplex128) Iterator() *IterIntComplex128 {
	var i IterIntComplex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntComplex128) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntComplex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintcomplex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntComplex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntComplex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntComplex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntComplex64 implements an associative array of complex64 indexed by int.
type MapIntComplex64 struct {
	length int
	root   nodeMapintcomplex64
}

// NewMapIntComplex64 returns a new map with keys of type int and values of type complex64
func NewMapIntComplex64() *MapIntComplex64 {
	var r MapIntComplex64
	return &r
}

type nodeMapintcomplex64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapintcomplex64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintcomplex64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintcomplex64) children() *[2]nodeMapintcomplex64 {
	return (*[2]nodeMapintcomplex64)(c.child)
}

func (c *nodeMapintcomplex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintcomplex64) find(key int) (crit uint, child, parent *nodeMapintcomplex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntComplex64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntComplex64) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntComplex64) SetP(key int, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntComplex64) Set(key int, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntComplex64) GetP(key int) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntComplex64) Get(key int) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntComplex64) Length() int {
	return t.length
}

// func (c *nodeMapintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterIntComplex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntComplex64 struct {
	t       *MapIntComplex64
	nodes   []*nodeMapintcomplex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int        // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntComplex64.
func (t *MapIntComplex64) Iterator() *IterIntComplex64 {
	var i IterIntComplex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntComplex64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntComplex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintcomplex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntComplex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntComplex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntComplex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntError implements an associative array of error indexed by int.
type MapIntError struct {
	length int
	root   nodeMapinterror
}

// NewMapIntError returns a new map with keys of type int and values of type error
func NewMapIntError() *MapIntError {
	var r MapIntError
	return &r
}

type nodeMapinterror struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapinterror or error)
}

// Return walking direction
func (c nodeMapinterror) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapinterror) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapinterror) children() *[2]nodeMapinterror {
	return (*[2]nodeMapinterror)(c.child)
}

func (c *nodeMapinterror) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapinterror) find(key int) (crit uint, child, parent *nodeMapinterror) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntError) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntError) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntError) SetP(key int, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntError) Set(key int, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntError) GetP(key int) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntError) Get(key int) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntError) Length() int {
	return t.length
}

// func (c *nodeMapinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterIntError The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntError struct {
	t       *MapIntError
	nodes   []*nodeMapinterror
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int    // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntError.
func (t *MapIntError) Iterator() *IterIntError {
	var i IterIntError
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntError) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntError) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapinterror, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntError) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntError) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntError) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntFloat32 implements an associative array of float32 indexed by int.
type MapIntFloat32 struct {
	length int
	root   nodeMapintfloat32
}

// NewMapIntFloat32 returns a new map with keys of type int and values of type float32
func NewMapIntFloat32() *MapIntFloat32 {
	var r MapIntFloat32
	return &r
}

type nodeMapintfloat32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat32 or float32)
}

// Return walking direction
func (c nodeMapintfloat32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintfloat32) children() *[2]nodeMapintfloat32 {
	return (*[2]nodeMapintfloat32)(c.child)
}

func (c *nodeMapintfloat32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintfloat32) find(key int) (crit uint, child, parent *nodeMapintfloat32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntFloat32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntFloat32) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntFloat32) SetP(key int, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntFloat32) Set(key int, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntFloat32) GetP(key int) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntFloat32) Get(key int) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat32) Length() int {
	return t.length
}

// func (c *nodeMapintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterIntFloat32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntFloat32 struct {
	t       *MapIntFloat32
	nodes   []*nodeMapintfloat32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int      // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntFloat32.
func (t *MapIntFloat32) Iterator() *IterIntFloat32 {
	var i IterIntFloat32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntFloat32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntFloat32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintfloat32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntFloat32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntFloat32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntFloat32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntFloat64 implements an associative array of float64 indexed by int.
type MapIntFloat64 struct {
	length int
	root   nodeMapintfloat64
}

// NewMapIntFloat64 returns a new map with keys of type int and values of type float64
func NewMapIntFloat64() *MapIntFloat64 {
	var r MapIntFloat64
	return &r
}

type nodeMapintfloat64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintfloat64 or float64)
}

// Return walking direction
func (c nodeMapintfloat64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintfloat64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintfloat64) children() *[2]nodeMapintfloat64 {
	return (*[2]nodeMapintfloat64)(c.child)
}

func (c *nodeMapintfloat64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintfloat64) find(key int) (crit uint, child, parent *nodeMapintfloat64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntFloat64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntFloat64) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntFloat64) SetP(key int, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntFloat64) Set(key int, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntFloat64) GetP(key int) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntFloat64) Get(key int) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntFloat64) Length() int {
	return t.length
}

// func (c *nodeMapintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterIntFloat64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntFloat64 struct {
	t       *MapIntFloat64
	nodes   []*nodeMapintfloat64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int      // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntFloat64.
func (t *MapIntFloat64) Iterator() *IterIntFloat64 {
	var i IterIntFloat64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntFloat64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntFloat64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintfloat64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntFloat64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntFloat64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntFloat64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntInt implements an associative array of int indexed by int.
type MapIntInt struct {
	length int
	root   nodeMapintint
}

// NewMapIntInt returns a new map with keys of type int and values of type int
func NewMapIntInt() *MapIntInt {
	var r MapIntInt
	return &r
}

type nodeMapintint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint or int)
}

// Return walking direction
func (c nodeMapintint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint) children() *[2]nodeMapintint {
	return (*[2]nodeMapintint)(c.child)
}

func (c *nodeMapintint) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintint) find(key int) (crit uint, child, parent *nodeMapintint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntInt) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntInt) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt) SetP(key int, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt) Set(key int, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt) GetP(key int) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt) Get(key int) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt) Length() int {
	return t.length
}

// func (c *nodeMapintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterIntInt The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt struct {
	t       *MapIntInt
	nodes   []*nodeMapintint
	lastDir int
	Found   bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int  // Key found by last call to Next, Prev.
	Value   *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt.
func (t *MapIntInt) Iterator() *IterIntInt {
	var i IterIntInt
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntInt) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntInt) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntInt) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntInt) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntInt) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntInt16 implements an associative array of int16 indexed by int.
type MapIntInt16 struct {
	length int
	root   nodeMapintint16
}

// NewMapIntInt16 returns a new map with keys of type int and values of type int16
func NewMapIntInt16() *MapIntInt16 {
	var r MapIntInt16
	return &r
}

type nodeMapintint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint16 or int16)
}

// Return walking direction
func (c nodeMapintint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint16) children() *[2]nodeMapintint16 {
	return (*[2]nodeMapintint16)(c.child)
}

func (c *nodeMapintint16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintint16) find(key int) (crit uint, child, parent *nodeMapintint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntInt16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntInt16) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt16) SetP(key int, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt16) Set(key int, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt16) GetP(key int) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt16) Get(key int) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt16) Length() int {
	return t.length
}

// func (c *nodeMapintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterIntInt16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt16 struct {
	t       *MapIntInt16
	nodes   []*nodeMapintint16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int    // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt16.
func (t *MapIntInt16) Iterator() *IterIntInt16 {
	var i IterIntInt16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntInt16) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntInt16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntInt16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntInt16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntInt16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntInt32 implements an associative array of int32 indexed by int.
type MapIntInt32 struct {
	length int
	root   nodeMapintint32
}

// NewMapIntInt32 returns a new map with keys of type int and values of type int32
func NewMapIntInt32() *MapIntInt32 {
	var r MapIntInt32
	return &r
}

type nodeMapintint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint32 or int32)
}

// Return walking direction
func (c nodeMapintint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint32) children() *[2]nodeMapintint32 {
	return (*[2]nodeMapintint32)(c.child)
}

func (c *nodeMapintint32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintint32) find(key int) (crit uint, child, parent *nodeMapintint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntInt32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntInt32) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt32) SetP(key int, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt32) Set(key int, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt32) GetP(key int) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt32) Get(key int) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt32) Length() int {
	return t.length
}

// func (c *nodeMapintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterIntInt32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt32 struct {
	t       *MapIntInt32
	nodes   []*nodeMapintint32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int    // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt32.
func (t *MapIntInt32) Iterator() *IterIntInt32 {
	var i IterIntInt32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntInt32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntInt32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntInt32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntInt32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntInt32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntInt64 implements an associative array of int64 indexed by int.
type MapIntInt64 struct {
	length int
	root   nodeMapintint64
}

// NewMapIntInt64 returns a new map with keys of type int and values of type int64
func NewMapIntInt64() *MapIntInt64 {
	var r MapIntInt64
	return &r
}

type nodeMapintint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint64 or int64)
}

// Return walking direction
func (c nodeMapintint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint64) children() *[2]nodeMapintint64 {
	return (*[2]nodeMapintint64)(c.child)
}

func (c *nodeMapintint64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintint64) find(key int) (crit uint, child, parent *nodeMapintint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntInt64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntInt64) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt64) SetP(key int, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt64) Set(key int, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt64) GetP(key int) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt64) Get(key int) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt64) Length() int {
	return t.length
}

// func (c *nodeMapintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterIntInt64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt64 struct {
	t       *MapIntInt64
	nodes   []*nodeMapintint64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int    // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt64.
func (t *MapIntInt64) Iterator() *IterIntInt64 {
	var i IterIntInt64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntInt64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntInt64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntInt64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntInt64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntInt64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntInt8 implements an associative array of int8 indexed by int.
type MapIntInt8 struct {
	length int
	root   nodeMapintint8
}

// NewMapIntInt8 returns a new map with keys of type int and values of type int8
func NewMapIntInt8() *MapIntInt8 {
	var r MapIntInt8
	return &r
}

type nodeMapintint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintint8 or int8)
}

// Return walking direction
func (c nodeMapintint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintint8) children() *[2]nodeMapintint8 {
	return (*[2]nodeMapintint8)(c.child)
}

func (c *nodeMapintint8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintint8) find(key int) (crit uint, child, parent *nodeMapintint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntInt8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntInt8) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntInt8) SetP(key int, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntInt8) Set(key int, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntInt8) GetP(key int) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntInt8) Get(key int) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntInt8) Length() int {
	return t.length
}

// func (c *nodeMapintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterIntInt8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntInt8 struct {
	t       *MapIntInt8
	nodes   []*nodeMapintint8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int   // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntInt8.
func (t *MapIntInt8) Iterator() *IterIntInt8 {
	var i IterIntInt8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntInt8) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntInt8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntInt8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntInt8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntInt8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntRune implements an associative array of rune indexed by int.
type MapIntRune struct {
	length int
	root   nodeMapintrune
}

// NewMapIntRune returns a new map with keys of type int and values of type rune
func NewMapIntRune() *MapIntRune {
	var r MapIntRune
	return &r
}

type nodeMapintrune struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintrune or rune)
}

// Return walking direction
func (c nodeMapintrune) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintrune) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintrune) children() *[2]nodeMapintrune {
	return (*[2]nodeMapintrune)(c.child)
}

func (c *nodeMapintrune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintrune) find(key int) (crit uint, child, parent *nodeMapintrune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntRune) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntRune) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntRune) SetP(key int, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntRune) Set(key int, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntRune) GetP(key int) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntRune) Get(key int) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntRune) Length() int {
	return t.length
}

// func (c *nodeMapintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterIntRune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntRune struct {
	t       *MapIntRune
	nodes   []*nodeMapintrune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int   // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntRune.
func (t *MapIntRune) Iterator() *IterIntRune {
	var i IterIntRune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntRune) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntRune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintrune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntRune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntRune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntRune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntString implements an associative array of string indexed by int.
type MapIntString struct {
	length int
	root   nodeMapintstring
}

// NewMapIntString returns a new map with keys of type int and values of type string
func NewMapIntString() *MapIntString {
	var r MapIntString
	return &r
}

type nodeMapintstring struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintstring or string)
}

// Return walking direction
func (c nodeMapintstring) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintstring) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintstring) children() *[2]nodeMapintstring {
	return (*[2]nodeMapintstring)(c.child)
}

func (c *nodeMapintstring) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintstring) find(key int) (crit uint, child, parent *nodeMapintstring) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntString) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntString) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntString) SetP(key int, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntString) Set(key int, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntString) GetP(key int) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntString) Get(key int) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntString) Length() int {
	return t.length
}

// func (c *nodeMapintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterIntString The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntString struct {
	t       *MapIntString
	nodes   []*nodeMapintstring
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int     // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntString.
func (t *MapIntString) Iterator() *IterIntString {
	var i IterIntString
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntString) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntString) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintstring, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntString) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntString) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntString) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUint implements an associative array of uint indexed by int.
type MapIntUint struct {
	length int
	root   nodeMapintuint
}

// NewMapIntUint returns a new map with keys of type int and values of type uint
func NewMapIntUint() *MapIntUint {
	var r MapIntUint
	return &r
}

type nodeMapintuint struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint or uint)
}

// Return walking direction
func (c nodeMapintuint) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint) children() *[2]nodeMapintuint {
	return (*[2]nodeMapintuint)(c.child)
}

func (c *nodeMapintuint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuint) find(key int) (crit uint, child, parent *nodeMapintuint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUint) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUint) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint) SetP(key int, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint) Set(key int, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint) GetP(key int) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint) Get(key int) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint) Length() int {
	return t.length
}

// func (c *nodeMapintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterIntUint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint struct {
	t       *MapIntUint
	nodes   []*nodeMapintuint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int   // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint.
func (t *MapIntUint) Iterator() *IterIntUint {
	var i IterIntUint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUint) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUint16 implements an associative array of uint16 indexed by int.
type MapIntUint16 struct {
	length int
	root   nodeMapintuint16
}

// NewMapIntUint16 returns a new map with keys of type int and values of type uint16
func NewMapIntUint16() *MapIntUint16 {
	var r MapIntUint16
	return &r
}

type nodeMapintuint16 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint16 or uint16)
}

// Return walking direction
func (c nodeMapintuint16) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint16) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint16) children() *[2]nodeMapintuint16 {
	return (*[2]nodeMapintuint16)(c.child)
}

func (c *nodeMapintuint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuint16) find(key int) (crit uint, child, parent *nodeMapintuint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUint16) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUint16) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint16) SetP(key int, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint16) Set(key int, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint16) GetP(key int) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint16) Get(key int) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint16) Length() int {
	return t.length
}

// func (c *nodeMapintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterIntUint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint16 struct {
	t       *MapIntUint16
	nodes   []*nodeMapintuint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int     // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint16.
func (t *MapIntUint16) Iterator() *IterIntUint16 {
	var i IterIntUint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUint16) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUint32 implements an associative array of uint32 indexed by int.
type MapIntUint32 struct {
	length int
	root   nodeMapintuint32
}

// NewMapIntUint32 returns a new map with keys of type int and values of type uint32
func NewMapIntUint32() *MapIntUint32 {
	var r MapIntUint32
	return &r
}

type nodeMapintuint32 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint32 or uint32)
}

// Return walking direction
func (c nodeMapintuint32) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint32) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint32) children() *[2]nodeMapintuint32 {
	return (*[2]nodeMapintuint32)(c.child)
}

func (c *nodeMapintuint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuint32) find(key int) (crit uint, child, parent *nodeMapintuint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUint32) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUint32) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint32) SetP(key int, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint32) Set(key int, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint32) GetP(key int) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint32) Get(key int) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint32) Length() int {
	return t.length
}

// func (c *nodeMapintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterIntUint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint32 struct {
	t       *MapIntUint32
	nodes   []*nodeMapintuint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int     // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint32.
func (t *MapIntUint32) Iterator() *IterIntUint32 {
	var i IterIntUint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUint32) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUint64 implements an associative array of uint64 indexed by int.
type MapIntUint64 struct {
	length int
	root   nodeMapintuint64
}

// NewMapIntUint64 returns a new map with keys of type int and values of type uint64
func NewMapIntUint64() *MapIntUint64 {
	var r MapIntUint64
	return &r
}

type nodeMapintuint64 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint64 or uint64)
}

// Return walking direction
func (c nodeMapintuint64) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint64) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint64) children() *[2]nodeMapintuint64 {
	return (*[2]nodeMapintuint64)(c.child)
}

func (c *nodeMapintuint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuint64) find(key int) (crit uint, child, parent *nodeMapintuint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUint64) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUint64) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint64) SetP(key int, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint64) Set(key int, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint64) GetP(key int) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint64) Get(key int) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint64) Length() int {
	return t.length
}

// func (c *nodeMapintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterIntUint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint64 struct {
	t       *MapIntUint64
	nodes   []*nodeMapintuint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int     // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint64.
func (t *MapIntUint64) Iterator() *IterIntUint64 {
	var i IterIntUint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUint64) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUint8 implements an associative array of uint8 indexed by int.
type MapIntUint8 struct {
	length int
	root   nodeMapintuint8
}

// NewMapIntUint8 returns a new map with keys of type int and values of type uint8
func NewMapIntUint8() *MapIntUint8 {
	var r MapIntUint8
	return &r
}

type nodeMapintuint8 struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuint8 or uint8)
}

// Return walking direction
func (c nodeMapintuint8) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuint8) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuint8) children() *[2]nodeMapintuint8 {
	return (*[2]nodeMapintuint8)(c.child)
}

func (c *nodeMapintuint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuint8) find(key int) (crit uint, child, parent *nodeMapintuint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUint8) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUint8) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUint8) SetP(key int, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUint8) Set(key int, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUint8) GetP(key int) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUint8) Get(key int) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUint8) Length() int {
	return t.length
}

// func (c *nodeMapintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterIntUint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUint8 struct {
	t       *MapIntUint8
	nodes   []*nodeMapintuint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int    // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUint8.
func (t *MapIntUint8) Iterator() *IterIntUint8 {
	var i IterIntUint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUint8) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapIntUintptr implements an associative array of uintptr indexed by int.
type MapIntUintptr struct {
	length int
	root   nodeMapintuintptr
}

// NewMapIntUintptr returns a new map with keys of type int and values of type uintptr
func NewMapIntUintptr() *MapIntUintptr {
	var r MapIntUintptr
	return &r
}

type nodeMapintuintptr struct {
	key   int            // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapintuintptr) dir(key int) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapintuintptr) findCrit(key int) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapintuintptr) children() *[2]nodeMapintuintptr {
	return (*[2]nodeMapintuintptr)(c.child)
}

func (c *nodeMapintuintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapintuintptr) find(key int) (crit uint, child, parent *nodeMapintuintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapIntUintptr) transformKey(key int) int {
	var mask int = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapIntUintptr) Rem(key int) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapIntUintptr) SetP(key int, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapIntUintptr) Set(key int, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapIntUintptr) GetP(key int) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapIntUintptr) Get(key int) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapIntUintptr) Length() int {
	return t.length
}

// func (c *nodeMapintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterIntUintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterIntUintptr struct {
	t       *MapIntUintptr
	nodes   []*nodeMapintuintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int      // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterIntUintptr.
func (t *MapIntUintptr) Iterator() *IterIntUintptr {
	var i IterIntUintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterIntUintptr) Seek(key int) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterIntUintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapintuintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterIntUintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterIntUintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterIntUintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Bool implements an associative array of bool indexed by int64.
type MapInt64Bool struct {
	length int
	root   nodeMapint64bool
}

// NewMapInt64Bool returns a new map with keys of type int64 and values of type bool
func NewMapInt64Bool() *MapInt64Bool {
	var r MapInt64Bool
	return &r
}

type nodeMapint64bool struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64bool or bool)
}

// Return walking direction
func (c nodeMapint64bool) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64bool) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64bool) children() *[2]nodeMapint64bool {
	return (*[2]nodeMapint64bool)(c.child)
}

func (c *nodeMapint64bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64bool) find(key int64) (crit uint, child, parent *nodeMapint64bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Bool) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Bool) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Bool) SetP(key int64, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Bool) Set(key int64, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Bool) GetP(key int64) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Bool) Get(key int64) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Bool) Length() int {
	return t.length
}

// func (c *nodeMapint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt64Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Bool struct {
	t       *MapInt64Bool
	nodes   []*nodeMapint64bool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Bool.
func (t *MapInt64Bool) Iterator() *IterInt64Bool {
	var i IterInt64Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Bool) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Byte implements an associative array of byte indexed by int64.
type MapInt64Byte struct {
	length int
	root   nodeMapint64byte
}

// NewMapInt64Byte returns a new map with keys of type int64 and values of type byte
func NewMapInt64Byte() *MapInt64Byte {
	var r MapInt64Byte
	return &r
}

type nodeMapint64byte struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64byte or byte)
}

// Return walking direction
func (c nodeMapint64byte) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64byte) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64byte) children() *[2]nodeMapint64byte {
	return (*[2]nodeMapint64byte)(c.child)
}

func (c *nodeMapint64byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64byte) find(key int64) (crit uint, child, parent *nodeMapint64byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Byte) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Byte) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Byte) SetP(key int64, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Byte) Set(key int64, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Byte) GetP(key int64) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Byte) Get(key int64) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Byte) Length() int {
	return t.length
}

// func (c *nodeMapint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt64Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Byte struct {
	t       *MapInt64Byte
	nodes   []*nodeMapint64byte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Byte.
func (t *MapInt64Byte) Iterator() *IterInt64Byte {
	var i IterInt64Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Byte) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Complex128 implements an associative array of complex128 indexed by int64.
type MapInt64Complex128 struct {
	length int
	root   nodeMapint64complex128
}

// NewMapInt64Complex128 returns a new map with keys of type int64 and values of type complex128
func NewMapInt64Complex128() *MapInt64Complex128 {
	var r MapInt64Complex128
	return &r
}

type nodeMapint64complex128 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapint64complex128) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex128) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64complex128) children() *[2]nodeMapint64complex128 {
	return (*[2]nodeMapint64complex128)(c.child)
}

func (c *nodeMapint64complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64complex128) find(key int64) (crit uint, child, parent *nodeMapint64complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Complex128) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Complex128) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Complex128) SetP(key int64, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Complex128) Set(key int64, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Complex128) GetP(key int64) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Complex128) Get(key int64) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt64Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Complex128 struct {
	t       *MapInt64Complex128
	nodes   []*nodeMapint64complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64       // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Complex128.
func (t *MapInt64Complex128) Iterator() *IterInt64Complex128 {
	var i IterInt64Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Complex128) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Complex64 implements an associative array of complex64 indexed by int64.
type MapInt64Complex64 struct {
	length int
	root   nodeMapint64complex64
}

// NewMapInt64Complex64 returns a new map with keys of type int64 and values of type complex64
func NewMapInt64Complex64() *MapInt64Complex64 {
	var r MapInt64Complex64
	return &r
}

type nodeMapint64complex64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapint64complex64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64complex64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64complex64) children() *[2]nodeMapint64complex64 {
	return (*[2]nodeMapint64complex64)(c.child)
}

func (c *nodeMapint64complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64complex64) find(key int64) (crit uint, child, parent *nodeMapint64complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Complex64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Complex64) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Complex64) SetP(key int64, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Complex64) Set(key int64, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Complex64) GetP(key int64) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Complex64) Get(key int64) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt64Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Complex64 struct {
	t       *MapInt64Complex64
	nodes   []*nodeMapint64complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64      // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Complex64.
func (t *MapInt64Complex64) Iterator() *IterInt64Complex64 {
	var i IterInt64Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Complex64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Error implements an associative array of error indexed by int64.
type MapInt64Error struct {
	length int
	root   nodeMapint64error
}

// NewMapInt64Error returns a new map with keys of type int64 and values of type error
func NewMapInt64Error() *MapInt64Error {
	var r MapInt64Error
	return &r
}

type nodeMapint64error struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64error or error)
}

// Return walking direction
func (c nodeMapint64error) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64error) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64error) children() *[2]nodeMapint64error {
	return (*[2]nodeMapint64error)(c.child)
}

func (c *nodeMapint64error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64error) find(key int64) (crit uint, child, parent *nodeMapint64error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Error) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Error) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Error) SetP(key int64, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Error) Set(key int64, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Error) GetP(key int64) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Error) Get(key int64) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Error) Length() int {
	return t.length
}

// func (c *nodeMapint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt64Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Error struct {
	t       *MapInt64Error
	nodes   []*nodeMapint64error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64  // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Error.
func (t *MapInt64Error) Iterator() *IterInt64Error {
	var i IterInt64Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Error) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Float32 implements an associative array of float32 indexed by int64.
type MapInt64Float32 struct {
	length int
	root   nodeMapint64float32
}

// NewMapInt64Float32 returns a new map with keys of type int64 and values of type float32
func NewMapInt64Float32() *MapInt64Float32 {
	var r MapInt64Float32
	return &r
}

type nodeMapint64float32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float32 or float32)
}

// Return walking direction
func (c nodeMapint64float32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64float32) children() *[2]nodeMapint64float32 {
	return (*[2]nodeMapint64float32)(c.child)
}

func (c *nodeMapint64float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64float32) find(key int64) (crit uint, child, parent *nodeMapint64float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Float32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Float32) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Float32) SetP(key int64, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Float32) Set(key int64, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Float32) GetP(key int64) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Float32) Get(key int64) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float32) Length() int {
	return t.length
}

// func (c *nodeMapint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt64Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Float32 struct {
	t       *MapInt64Float32
	nodes   []*nodeMapint64float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64    // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Float32.
func (t *MapInt64Float32) Iterator() *IterInt64Float32 {
	var i IterInt64Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Float32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Float64 implements an associative array of float64 indexed by int64.
type MapInt64Float64 struct {
	length int
	root   nodeMapint64float64
}

// NewMapInt64Float64 returns a new map with keys of type int64 and values of type float64
func NewMapInt64Float64() *MapInt64Float64 {
	var r MapInt64Float64
	return &r
}

type nodeMapint64float64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64float64 or float64)
}

// Return walking direction
func (c nodeMapint64float64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64float64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64float64) children() *[2]nodeMapint64float64 {
	return (*[2]nodeMapint64float64)(c.child)
}

func (c *nodeMapint64float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64float64) find(key int64) (crit uint, child, parent *nodeMapint64float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Float64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Float64) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Float64) SetP(key int64, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Float64) Set(key int64, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Float64) GetP(key int64) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Float64) Get(key int64) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Float64) Length() int {
	return t.length
}

// func (c *nodeMapint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt64Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Float64 struct {
	t       *MapInt64Float64
	nodes   []*nodeMapint64float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64    // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Float64.
func (t *MapInt64Float64) Iterator() *IterInt64Float64 {
	var i IterInt64Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Float64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Int implements an associative array of int indexed by int64.
type MapInt64Int struct {
	length int
	root   nodeMapint64int
}

// NewMapInt64Int returns a new map with keys of type int64 and values of type int
func NewMapInt64Int() *MapInt64Int {
	var r MapInt64Int
	return &r
}

type nodeMapint64int struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int or int)
}

// Return walking direction
func (c nodeMapint64int) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int) children() *[2]nodeMapint64int {
	return (*[2]nodeMapint64int)(c.child)
}

func (c *nodeMapint64int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64int) find(key int64) (crit uint, child, parent *nodeMapint64int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Int) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Int) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int) SetP(key int64, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int) Set(key int64, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int) GetP(key int64) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int) Get(key int64) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int) Length() int {
	return t.length
}

// func (c *nodeMapint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt64Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int struct {
	t       *MapInt64Int
	nodes   []*nodeMapint64int
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int.
func (t *MapInt64Int) Iterator() *IterInt64Int {
	var i IterInt64Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Int) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Int16 implements an associative array of int16 indexed by int64.
type MapInt64Int16 struct {
	length int
	root   nodeMapint64int16
}

// NewMapInt64Int16 returns a new map with keys of type int64 and values of type int16
func NewMapInt64Int16() *MapInt64Int16 {
	var r MapInt64Int16
	return &r
}

type nodeMapint64int16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int16 or int16)
}

// Return walking direction
func (c nodeMapint64int16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int16) children() *[2]nodeMapint64int16 {
	return (*[2]nodeMapint64int16)(c.child)
}

func (c *nodeMapint64int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64int16) find(key int64) (crit uint, child, parent *nodeMapint64int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Int16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Int16) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int16) SetP(key int64, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int16) Set(key int64, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int16) GetP(key int64) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int16) Get(key int64) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int16) Length() int {
	return t.length
}

// func (c *nodeMapint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt64Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int16 struct {
	t       *MapInt64Int16
	nodes   []*nodeMapint64int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64  // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int16.
func (t *MapInt64Int16) Iterator() *IterInt64Int16 {
	var i IterInt64Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Int16) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Int32 implements an associative array of int32 indexed by int64.
type MapInt64Int32 struct {
	length int
	root   nodeMapint64int32
}

// NewMapInt64Int32 returns a new map with keys of type int64 and values of type int32
func NewMapInt64Int32() *MapInt64Int32 {
	var r MapInt64Int32
	return &r
}

type nodeMapint64int32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int32 or int32)
}

// Return walking direction
func (c nodeMapint64int32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int32) children() *[2]nodeMapint64int32 {
	return (*[2]nodeMapint64int32)(c.child)
}

func (c *nodeMapint64int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64int32) find(key int64) (crit uint, child, parent *nodeMapint64int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Int32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Int32) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int32) SetP(key int64, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int32) Set(key int64, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int32) GetP(key int64) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int32) Get(key int64) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int32) Length() int {
	return t.length
}

// func (c *nodeMapint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt64Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int32 struct {
	t       *MapInt64Int32
	nodes   []*nodeMapint64int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64  // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int32.
func (t *MapInt64Int32) Iterator() *IterInt64Int32 {
	var i IterInt64Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Int32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Int64 implements an associative array of int64 indexed by int64.
type MapInt64Int64 struct {
	length int
	root   nodeMapint64int64
}

// NewMapInt64Int64 returns a new map with keys of type int64 and values of type int64
func NewMapInt64Int64() *MapInt64Int64 {
	var r MapInt64Int64
	return &r
}

type nodeMapint64int64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int64 or int64)
}

// Return walking direction
func (c nodeMapint64int64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int64) children() *[2]nodeMapint64int64 {
	return (*[2]nodeMapint64int64)(c.child)
}

func (c *nodeMapint64int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64int64) find(key int64) (crit uint, child, parent *nodeMapint64int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Int64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Int64) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int64) SetP(key int64, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int64) Set(key int64, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int64) GetP(key int64) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int64) Get(key int64) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int64) Length() int {
	return t.length
}

// func (c *nodeMapint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt64Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int64 struct {
	t       *MapInt64Int64
	nodes   []*nodeMapint64int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64  // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int64.
func (t *MapInt64Int64) Iterator() *IterInt64Int64 {
	var i IterInt64Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Int64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Int8 implements an associative array of int8 indexed by int64.
type MapInt64Int8 struct {
	length int
	root   nodeMapint64int8
}

// NewMapInt64Int8 returns a new map with keys of type int64 and values of type int8
func NewMapInt64Int8() *MapInt64Int8 {
	var r MapInt64Int8
	return &r
}

type nodeMapint64int8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64int8 or int8)
}

// Return walking direction
func (c nodeMapint64int8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64int8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64int8) children() *[2]nodeMapint64int8 {
	return (*[2]nodeMapint64int8)(c.child)
}

func (c *nodeMapint64int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64int8) find(key int64) (crit uint, child, parent *nodeMapint64int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Int8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Int8) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Int8) SetP(key int64, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Int8) Set(key int64, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Int8) GetP(key int64) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Int8) Get(key int64) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Int8) Length() int {
	return t.length
}

// func (c *nodeMapint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt64Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Int8 struct {
	t       *MapInt64Int8
	nodes   []*nodeMapint64int8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Int8.
func (t *MapInt64Int8) Iterator() *IterInt64Int8 {
	var i IterInt64Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Int8) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Rune implements an associative array of rune indexed by int64.
type MapInt64Rune struct {
	length int
	root   nodeMapint64rune
}

// NewMapInt64Rune returns a new map with keys of type int64 and values of type rune
func NewMapInt64Rune() *MapInt64Rune {
	var r MapInt64Rune
	return &r
}

type nodeMapint64rune struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64rune or rune)
}

// Return walking direction
func (c nodeMapint64rune) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64rune) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64rune) children() *[2]nodeMapint64rune {
	return (*[2]nodeMapint64rune)(c.child)
}

func (c *nodeMapint64rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64rune) find(key int64) (crit uint, child, parent *nodeMapint64rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Rune) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Rune) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Rune) SetP(key int64, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Rune) Set(key int64, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Rune) GetP(key int64) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Rune) Get(key int64) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Rune) Length() int {
	return t.length
}

// func (c *nodeMapint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt64Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Rune struct {
	t       *MapInt64Rune
	nodes   []*nodeMapint64rune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Rune.
func (t *MapInt64Rune) Iterator() *IterInt64Rune {
	var i IterInt64Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Rune) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64String implements an associative array of string indexed by int64.
type MapInt64String struct {
	length int
	root   nodeMapint64string
}

// NewMapInt64String returns a new map with keys of type int64 and values of type string
func NewMapInt64String() *MapInt64String {
	var r MapInt64String
	return &r
}

type nodeMapint64string struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64string or string)
}

// Return walking direction
func (c nodeMapint64string) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64string) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64string) children() *[2]nodeMapint64string {
	return (*[2]nodeMapint64string)(c.child)
}

func (c *nodeMapint64string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64string) find(key int64) (crit uint, child, parent *nodeMapint64string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64String) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64String) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64String) SetP(key int64, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64String) Set(key int64, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64String) GetP(key int64) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64String) Get(key int64) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64String) Length() int {
	return t.length
}

// func (c *nodeMapint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt64String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64String struct {
	t       *MapInt64String
	nodes   []*nodeMapint64string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64   // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64String.
func (t *MapInt64String) Iterator() *IterInt64String {
	var i IterInt64String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64String) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uint implements an associative array of uint indexed by int64.
type MapInt64Uint struct {
	length int
	root   nodeMapint64uint
}

// NewMapInt64Uint returns a new map with keys of type int64 and values of type uint
func NewMapInt64Uint() *MapInt64Uint {
	var r MapInt64Uint
	return &r
}

type nodeMapint64uint struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint or uint)
}

// Return walking direction
func (c nodeMapint64uint) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint) children() *[2]nodeMapint64uint {
	return (*[2]nodeMapint64uint)(c.child)
}

func (c *nodeMapint64uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uint) find(key int64) (crit uint, child, parent *nodeMapint64uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uint) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uint) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint) SetP(key int64, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint) Set(key int64, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint) GetP(key int64) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint) Get(key int64) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint) Length() int {
	return t.length
}

// func (c *nodeMapint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt64Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint struct {
	t       *MapInt64Uint
	nodes   []*nodeMapint64uint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64 // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint.
func (t *MapInt64Uint) Iterator() *IterInt64Uint {
	var i IterInt64Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uint) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uint16 implements an associative array of uint16 indexed by int64.
type MapInt64Uint16 struct {
	length int
	root   nodeMapint64uint16
}

// NewMapInt64Uint16 returns a new map with keys of type int64 and values of type uint16
func NewMapInt64Uint16() *MapInt64Uint16 {
	var r MapInt64Uint16
	return &r
}

type nodeMapint64uint16 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapint64uint16) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint16) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint16) children() *[2]nodeMapint64uint16 {
	return (*[2]nodeMapint64uint16)(c.child)
}

func (c *nodeMapint64uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uint16) find(key int64) (crit uint, child, parent *nodeMapint64uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uint16) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uint16) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint16) SetP(key int64, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint16) Set(key int64, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint16) GetP(key int64) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint16) Get(key int64) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt64Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint16 struct {
	t       *MapInt64Uint16
	nodes   []*nodeMapint64uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64   // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint16.
func (t *MapInt64Uint16) Iterator() *IterInt64Uint16 {
	var i IterInt64Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uint16) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uint32 implements an associative array of uint32 indexed by int64.
type MapInt64Uint32 struct {
	length int
	root   nodeMapint64uint32
}

// NewMapInt64Uint32 returns a new map with keys of type int64 and values of type uint32
func NewMapInt64Uint32() *MapInt64Uint32 {
	var r MapInt64Uint32
	return &r
}

type nodeMapint64uint32 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapint64uint32) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint32) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint32) children() *[2]nodeMapint64uint32 {
	return (*[2]nodeMapint64uint32)(c.child)
}

func (c *nodeMapint64uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uint32) find(key int64) (crit uint, child, parent *nodeMapint64uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uint32) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uint32) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint32) SetP(key int64, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint32) Set(key int64, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint32) GetP(key int64) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint32) Get(key int64) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt64Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint32 struct {
	t       *MapInt64Uint32
	nodes   []*nodeMapint64uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64   // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint32.
func (t *MapInt64Uint32) Iterator() *IterInt64Uint32 {
	var i IterInt64Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uint32) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uint64 implements an associative array of uint64 indexed by int64.
type MapInt64Uint64 struct {
	length int
	root   nodeMapint64uint64
}

// NewMapInt64Uint64 returns a new map with keys of type int64 and values of type uint64
func NewMapInt64Uint64() *MapInt64Uint64 {
	var r MapInt64Uint64
	return &r
}

type nodeMapint64uint64 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapint64uint64) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint64) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint64) children() *[2]nodeMapint64uint64 {
	return (*[2]nodeMapint64uint64)(c.child)
}

func (c *nodeMapint64uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uint64) find(key int64) (crit uint, child, parent *nodeMapint64uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uint64) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uint64) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint64) SetP(key int64, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint64) Set(key int64, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint64) GetP(key int64) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint64) Get(key int64) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt64Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint64 struct {
	t       *MapInt64Uint64
	nodes   []*nodeMapint64uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64   // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint64.
func (t *MapInt64Uint64) Iterator() *IterInt64Uint64 {
	var i IterInt64Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uint64) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uint8 implements an associative array of uint8 indexed by int64.
type MapInt64Uint8 struct {
	length int
	root   nodeMapint64uint8
}

// NewMapInt64Uint8 returns a new map with keys of type int64 and values of type uint8
func NewMapInt64Uint8() *MapInt64Uint8 {
	var r MapInt64Uint8
	return &r
}

type nodeMapint64uint8 struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapint64uint8) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uint8) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uint8) children() *[2]nodeMapint64uint8 {
	return (*[2]nodeMapint64uint8)(c.child)
}

func (c *nodeMapint64uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uint8) find(key int64) (crit uint, child, parent *nodeMapint64uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uint8) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uint8) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uint8) SetP(key int64, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uint8) Set(key int64, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uint8) GetP(key int64) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uint8) Get(key int64) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt64Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uint8 struct {
	t       *MapInt64Uint8
	nodes   []*nodeMapint64uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64  // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uint8.
func (t *MapInt64Uint8) Iterator() *IterInt64Uint8 {
	var i IterInt64Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uint8) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt64Uintptr implements an associative array of uintptr indexed by int64.
type MapInt64Uintptr struct {
	length int
	root   nodeMapint64uintptr
}

// NewMapInt64Uintptr returns a new map with keys of type int64 and values of type uintptr
func NewMapInt64Uintptr() *MapInt64Uintptr {
	var r MapInt64Uintptr
	return &r
}

type nodeMapint64uintptr struct {
	key   int64          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint64uintptr) dir(key int64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint64uintptr) findCrit(key int64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint64uintptr) children() *[2]nodeMapint64uintptr {
	return (*[2]nodeMapint64uintptr)(c.child)
}

func (c *nodeMapint64uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint64uintptr) find(key int64) (crit uint, child, parent *nodeMapint64uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt64Uintptr) transformKey(key int64) int64 {
	var mask int64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt64Uintptr) Rem(key int64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt64Uintptr) SetP(key int64, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt64Uintptr) Set(key int64, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt64Uintptr) GetP(key int64) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt64Uintptr) Get(key int64) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt64Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt64Uintptr struct {
	t       *MapInt64Uintptr
	nodes   []*nodeMapint64uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int64    // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt64Uintptr.
func (t *MapInt64Uintptr) Iterator() *IterInt64Uintptr {
	var i IterInt64Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt64Uintptr) Seek(key int64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt64Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint64uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt64Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt64Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt64Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Bool implements an associative array of bool indexed by int32.
type MapInt32Bool struct {
	length int
	root   nodeMapint32bool
}

// NewMapInt32Bool returns a new map with keys of type int32 and values of type bool
func NewMapInt32Bool() *MapInt32Bool {
	var r MapInt32Bool
	return &r
}

type nodeMapint32bool struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32bool or bool)
}

// Return walking direction
func (c nodeMapint32bool) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32bool) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32bool) children() *[2]nodeMapint32bool {
	return (*[2]nodeMapint32bool)(c.child)
}

func (c *nodeMapint32bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32bool) find(key int32) (crit uint, child, parent *nodeMapint32bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Bool) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Bool) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Bool) SetP(key int32, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Bool) Set(key int32, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Bool) GetP(key int32) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Bool) Get(key int32) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Bool) Length() int {
	return t.length
}

// func (c *nodeMapint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt32Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Bool struct {
	t       *MapInt32Bool
	nodes   []*nodeMapint32bool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Bool.
func (t *MapInt32Bool) Iterator() *IterInt32Bool {
	var i IterInt32Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Bool) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Byte implements an associative array of byte indexed by int32.
type MapInt32Byte struct {
	length int
	root   nodeMapint32byte
}

// NewMapInt32Byte returns a new map with keys of type int32 and values of type byte
func NewMapInt32Byte() *MapInt32Byte {
	var r MapInt32Byte
	return &r
}

type nodeMapint32byte struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32byte or byte)
}

// Return walking direction
func (c nodeMapint32byte) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32byte) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32byte) children() *[2]nodeMapint32byte {
	return (*[2]nodeMapint32byte)(c.child)
}

func (c *nodeMapint32byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32byte) find(key int32) (crit uint, child, parent *nodeMapint32byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Byte) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Byte) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Byte) SetP(key int32, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Byte) Set(key int32, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Byte) GetP(key int32) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Byte) Get(key int32) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Byte) Length() int {
	return t.length
}

// func (c *nodeMapint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt32Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Byte struct {
	t       *MapInt32Byte
	nodes   []*nodeMapint32byte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Byte.
func (t *MapInt32Byte) Iterator() *IterInt32Byte {
	var i IterInt32Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Byte) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Complex128 implements an associative array of complex128 indexed by int32.
type MapInt32Complex128 struct {
	length int
	root   nodeMapint32complex128
}

// NewMapInt32Complex128 returns a new map with keys of type int32 and values of type complex128
func NewMapInt32Complex128() *MapInt32Complex128 {
	var r MapInt32Complex128
	return &r
}

type nodeMapint32complex128 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapint32complex128) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex128) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32complex128) children() *[2]nodeMapint32complex128 {
	return (*[2]nodeMapint32complex128)(c.child)
}

func (c *nodeMapint32complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32complex128) find(key int32) (crit uint, child, parent *nodeMapint32complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Complex128) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Complex128) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Complex128) SetP(key int32, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Complex128) Set(key int32, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Complex128) GetP(key int32) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Complex128) Get(key int32) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt32Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Complex128 struct {
	t       *MapInt32Complex128
	nodes   []*nodeMapint32complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32       // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Complex128.
func (t *MapInt32Complex128) Iterator() *IterInt32Complex128 {
	var i IterInt32Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Complex128) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Complex64 implements an associative array of complex64 indexed by int32.
type MapInt32Complex64 struct {
	length int
	root   nodeMapint32complex64
}

// NewMapInt32Complex64 returns a new map with keys of type int32 and values of type complex64
func NewMapInt32Complex64() *MapInt32Complex64 {
	var r MapInt32Complex64
	return &r
}

type nodeMapint32complex64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapint32complex64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32complex64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32complex64) children() *[2]nodeMapint32complex64 {
	return (*[2]nodeMapint32complex64)(c.child)
}

func (c *nodeMapint32complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32complex64) find(key int32) (crit uint, child, parent *nodeMapint32complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Complex64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Complex64) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Complex64) SetP(key int32, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Complex64) Set(key int32, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Complex64) GetP(key int32) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Complex64) Get(key int32) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt32Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Complex64 struct {
	t       *MapInt32Complex64
	nodes   []*nodeMapint32complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32      // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Complex64.
func (t *MapInt32Complex64) Iterator() *IterInt32Complex64 {
	var i IterInt32Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Complex64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Error implements an associative array of error indexed by int32.
type MapInt32Error struct {
	length int
	root   nodeMapint32error
}

// NewMapInt32Error returns a new map with keys of type int32 and values of type error
func NewMapInt32Error() *MapInt32Error {
	var r MapInt32Error
	return &r
}

type nodeMapint32error struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32error or error)
}

// Return walking direction
func (c nodeMapint32error) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32error) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32error) children() *[2]nodeMapint32error {
	return (*[2]nodeMapint32error)(c.child)
}

func (c *nodeMapint32error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32error) find(key int32) (crit uint, child, parent *nodeMapint32error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Error) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Error) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Error) SetP(key int32, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Error) Set(key int32, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Error) GetP(key int32) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Error) Get(key int32) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Error) Length() int {
	return t.length
}

// func (c *nodeMapint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt32Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Error struct {
	t       *MapInt32Error
	nodes   []*nodeMapint32error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32  // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Error.
func (t *MapInt32Error) Iterator() *IterInt32Error {
	var i IterInt32Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Error) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Float32 implements an associative array of float32 indexed by int32.
type MapInt32Float32 struct {
	length int
	root   nodeMapint32float32
}

// NewMapInt32Float32 returns a new map with keys of type int32 and values of type float32
func NewMapInt32Float32() *MapInt32Float32 {
	var r MapInt32Float32
	return &r
}

type nodeMapint32float32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float32 or float32)
}

// Return walking direction
func (c nodeMapint32float32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32float32) children() *[2]nodeMapint32float32 {
	return (*[2]nodeMapint32float32)(c.child)
}

func (c *nodeMapint32float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32float32) find(key int32) (crit uint, child, parent *nodeMapint32float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Float32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Float32) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Float32) SetP(key int32, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Float32) Set(key int32, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Float32) GetP(key int32) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Float32) Get(key int32) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float32) Length() int {
	return t.length
}

// func (c *nodeMapint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt32Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Float32 struct {
	t       *MapInt32Float32
	nodes   []*nodeMapint32float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32    // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Float32.
func (t *MapInt32Float32) Iterator() *IterInt32Float32 {
	var i IterInt32Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Float32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Float64 implements an associative array of float64 indexed by int32.
type MapInt32Float64 struct {
	length int
	root   nodeMapint32float64
}

// NewMapInt32Float64 returns a new map with keys of type int32 and values of type float64
func NewMapInt32Float64() *MapInt32Float64 {
	var r MapInt32Float64
	return &r
}

type nodeMapint32float64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32float64 or float64)
}

// Return walking direction
func (c nodeMapint32float64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32float64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32float64) children() *[2]nodeMapint32float64 {
	return (*[2]nodeMapint32float64)(c.child)
}

func (c *nodeMapint32float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32float64) find(key int32) (crit uint, child, parent *nodeMapint32float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Float64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Float64) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Float64) SetP(key int32, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Float64) Set(key int32, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Float64) GetP(key int32) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Float64) Get(key int32) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Float64) Length() int {
	return t.length
}

// func (c *nodeMapint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt32Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Float64 struct {
	t       *MapInt32Float64
	nodes   []*nodeMapint32float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32    // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Float64.
func (t *MapInt32Float64) Iterator() *IterInt32Float64 {
	var i IterInt32Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Float64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Int implements an associative array of int indexed by int32.
type MapInt32Int struct {
	length int
	root   nodeMapint32int
}

// NewMapInt32Int returns a new map with keys of type int32 and values of type int
func NewMapInt32Int() *MapInt32Int {
	var r MapInt32Int
	return &r
}

type nodeMapint32int struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int or int)
}

// Return walking direction
func (c nodeMapint32int) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int) children() *[2]nodeMapint32int {
	return (*[2]nodeMapint32int)(c.child)
}

func (c *nodeMapint32int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32int) find(key int32) (crit uint, child, parent *nodeMapint32int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Int) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Int) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int) SetP(key int32, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int) Set(key int32, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int) GetP(key int32) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int) Get(key int32) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int) Length() int {
	return t.length
}

// func (c *nodeMapint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt32Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int struct {
	t       *MapInt32Int
	nodes   []*nodeMapint32int
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int.
func (t *MapInt32Int) Iterator() *IterInt32Int {
	var i IterInt32Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Int) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Int16 implements an associative array of int16 indexed by int32.
type MapInt32Int16 struct {
	length int
	root   nodeMapint32int16
}

// NewMapInt32Int16 returns a new map with keys of type int32 and values of type int16
func NewMapInt32Int16() *MapInt32Int16 {
	var r MapInt32Int16
	return &r
}

type nodeMapint32int16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int16 or int16)
}

// Return walking direction
func (c nodeMapint32int16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int16) children() *[2]nodeMapint32int16 {
	return (*[2]nodeMapint32int16)(c.child)
}

func (c *nodeMapint32int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32int16) find(key int32) (crit uint, child, parent *nodeMapint32int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Int16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Int16) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int16) SetP(key int32, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int16) Set(key int32, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int16) GetP(key int32) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int16) Get(key int32) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int16) Length() int {
	return t.length
}

// func (c *nodeMapint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt32Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int16 struct {
	t       *MapInt32Int16
	nodes   []*nodeMapint32int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32  // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int16.
func (t *MapInt32Int16) Iterator() *IterInt32Int16 {
	var i IterInt32Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Int16) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Int32 implements an associative array of int32 indexed by int32.
type MapInt32Int32 struct {
	length int
	root   nodeMapint32int32
}

// NewMapInt32Int32 returns a new map with keys of type int32 and values of type int32
func NewMapInt32Int32() *MapInt32Int32 {
	var r MapInt32Int32
	return &r
}

type nodeMapint32int32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int32 or int32)
}

// Return walking direction
func (c nodeMapint32int32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int32) children() *[2]nodeMapint32int32 {
	return (*[2]nodeMapint32int32)(c.child)
}

func (c *nodeMapint32int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32int32) find(key int32) (crit uint, child, parent *nodeMapint32int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Int32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Int32) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int32) SetP(key int32, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int32) Set(key int32, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int32) GetP(key int32) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int32) Get(key int32) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int32) Length() int {
	return t.length
}

// func (c *nodeMapint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt32Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int32 struct {
	t       *MapInt32Int32
	nodes   []*nodeMapint32int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32  // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int32.
func (t *MapInt32Int32) Iterator() *IterInt32Int32 {
	var i IterInt32Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Int32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Int64 implements an associative array of int64 indexed by int32.
type MapInt32Int64 struct {
	length int
	root   nodeMapint32int64
}

// NewMapInt32Int64 returns a new map with keys of type int32 and values of type int64
func NewMapInt32Int64() *MapInt32Int64 {
	var r MapInt32Int64
	return &r
}

type nodeMapint32int64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int64 or int64)
}

// Return walking direction
func (c nodeMapint32int64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int64) children() *[2]nodeMapint32int64 {
	return (*[2]nodeMapint32int64)(c.child)
}

func (c *nodeMapint32int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32int64) find(key int32) (crit uint, child, parent *nodeMapint32int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Int64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Int64) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int64) SetP(key int32, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int64) Set(key int32, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int64) GetP(key int32) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int64) Get(key int32) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int64) Length() int {
	return t.length
}

// func (c *nodeMapint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt32Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int64 struct {
	t       *MapInt32Int64
	nodes   []*nodeMapint32int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32  // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int64.
func (t *MapInt32Int64) Iterator() *IterInt32Int64 {
	var i IterInt32Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Int64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Int8 implements an associative array of int8 indexed by int32.
type MapInt32Int8 struct {
	length int
	root   nodeMapint32int8
}

// NewMapInt32Int8 returns a new map with keys of type int32 and values of type int8
func NewMapInt32Int8() *MapInt32Int8 {
	var r MapInt32Int8
	return &r
}

type nodeMapint32int8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32int8 or int8)
}

// Return walking direction
func (c nodeMapint32int8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32int8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32int8) children() *[2]nodeMapint32int8 {
	return (*[2]nodeMapint32int8)(c.child)
}

func (c *nodeMapint32int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32int8) find(key int32) (crit uint, child, parent *nodeMapint32int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Int8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Int8) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Int8) SetP(key int32, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Int8) Set(key int32, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Int8) GetP(key int32) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Int8) Get(key int32) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Int8) Length() int {
	return t.length
}

// func (c *nodeMapint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt32Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Int8 struct {
	t       *MapInt32Int8
	nodes   []*nodeMapint32int8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Int8.
func (t *MapInt32Int8) Iterator() *IterInt32Int8 {
	var i IterInt32Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Int8) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Rune implements an associative array of rune indexed by int32.
type MapInt32Rune struct {
	length int
	root   nodeMapint32rune
}

// NewMapInt32Rune returns a new map with keys of type int32 and values of type rune
func NewMapInt32Rune() *MapInt32Rune {
	var r MapInt32Rune
	return &r
}

type nodeMapint32rune struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32rune or rune)
}

// Return walking direction
func (c nodeMapint32rune) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32rune) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32rune) children() *[2]nodeMapint32rune {
	return (*[2]nodeMapint32rune)(c.child)
}

func (c *nodeMapint32rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32rune) find(key int32) (crit uint, child, parent *nodeMapint32rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Rune) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Rune) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Rune) SetP(key int32, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Rune) Set(key int32, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Rune) GetP(key int32) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Rune) Get(key int32) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Rune) Length() int {
	return t.length
}

// func (c *nodeMapint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt32Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Rune struct {
	t       *MapInt32Rune
	nodes   []*nodeMapint32rune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Rune.
func (t *MapInt32Rune) Iterator() *IterInt32Rune {
	var i IterInt32Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Rune) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32String implements an associative array of string indexed by int32.
type MapInt32String struct {
	length int
	root   nodeMapint32string
}

// NewMapInt32String returns a new map with keys of type int32 and values of type string
func NewMapInt32String() *MapInt32String {
	var r MapInt32String
	return &r
}

type nodeMapint32string struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32string or string)
}

// Return walking direction
func (c nodeMapint32string) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32string) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32string) children() *[2]nodeMapint32string {
	return (*[2]nodeMapint32string)(c.child)
}

func (c *nodeMapint32string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32string) find(key int32) (crit uint, child, parent *nodeMapint32string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32String) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32String) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32String) SetP(key int32, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32String) Set(key int32, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32String) GetP(key int32) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32String) Get(key int32) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32String) Length() int {
	return t.length
}

// func (c *nodeMapint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt32String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32String struct {
	t       *MapInt32String
	nodes   []*nodeMapint32string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32   // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32String.
func (t *MapInt32String) Iterator() *IterInt32String {
	var i IterInt32String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32String) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uint implements an associative array of uint indexed by int32.
type MapInt32Uint struct {
	length int
	root   nodeMapint32uint
}

// NewMapInt32Uint returns a new map with keys of type int32 and values of type uint
func NewMapInt32Uint() *MapInt32Uint {
	var r MapInt32Uint
	return &r
}

type nodeMapint32uint struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint or uint)
}

// Return walking direction
func (c nodeMapint32uint) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint) children() *[2]nodeMapint32uint {
	return (*[2]nodeMapint32uint)(c.child)
}

func (c *nodeMapint32uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uint) find(key int32) (crit uint, child, parent *nodeMapint32uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uint) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uint) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint) SetP(key int32, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint) Set(key int32, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint) GetP(key int32) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint) Get(key int32) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint) Length() int {
	return t.length
}

// func (c *nodeMapint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt32Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint struct {
	t       *MapInt32Uint
	nodes   []*nodeMapint32uint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32 // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint.
func (t *MapInt32Uint) Iterator() *IterInt32Uint {
	var i IterInt32Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uint) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uint16 implements an associative array of uint16 indexed by int32.
type MapInt32Uint16 struct {
	length int
	root   nodeMapint32uint16
}

// NewMapInt32Uint16 returns a new map with keys of type int32 and values of type uint16
func NewMapInt32Uint16() *MapInt32Uint16 {
	var r MapInt32Uint16
	return &r
}

type nodeMapint32uint16 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapint32uint16) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint16) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint16) children() *[2]nodeMapint32uint16 {
	return (*[2]nodeMapint32uint16)(c.child)
}

func (c *nodeMapint32uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uint16) find(key int32) (crit uint, child, parent *nodeMapint32uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uint16) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uint16) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint16) SetP(key int32, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint16) Set(key int32, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint16) GetP(key int32) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint16) Get(key int32) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt32Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint16 struct {
	t       *MapInt32Uint16
	nodes   []*nodeMapint32uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32   // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint16.
func (t *MapInt32Uint16) Iterator() *IterInt32Uint16 {
	var i IterInt32Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uint16) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uint32 implements an associative array of uint32 indexed by int32.
type MapInt32Uint32 struct {
	length int
	root   nodeMapint32uint32
}

// NewMapInt32Uint32 returns a new map with keys of type int32 and values of type uint32
func NewMapInt32Uint32() *MapInt32Uint32 {
	var r MapInt32Uint32
	return &r
}

type nodeMapint32uint32 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapint32uint32) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint32) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint32) children() *[2]nodeMapint32uint32 {
	return (*[2]nodeMapint32uint32)(c.child)
}

func (c *nodeMapint32uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uint32) find(key int32) (crit uint, child, parent *nodeMapint32uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uint32) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uint32) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint32) SetP(key int32, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint32) Set(key int32, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint32) GetP(key int32) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint32) Get(key int32) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt32Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint32 struct {
	t       *MapInt32Uint32
	nodes   []*nodeMapint32uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32   // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint32.
func (t *MapInt32Uint32) Iterator() *IterInt32Uint32 {
	var i IterInt32Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uint32) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uint64 implements an associative array of uint64 indexed by int32.
type MapInt32Uint64 struct {
	length int
	root   nodeMapint32uint64
}

// NewMapInt32Uint64 returns a new map with keys of type int32 and values of type uint64
func NewMapInt32Uint64() *MapInt32Uint64 {
	var r MapInt32Uint64
	return &r
}

type nodeMapint32uint64 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapint32uint64) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint64) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint64) children() *[2]nodeMapint32uint64 {
	return (*[2]nodeMapint32uint64)(c.child)
}

func (c *nodeMapint32uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uint64) find(key int32) (crit uint, child, parent *nodeMapint32uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uint64) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uint64) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint64) SetP(key int32, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint64) Set(key int32, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint64) GetP(key int32) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint64) Get(key int32) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt32Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint64 struct {
	t       *MapInt32Uint64
	nodes   []*nodeMapint32uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32   // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint64.
func (t *MapInt32Uint64) Iterator() *IterInt32Uint64 {
	var i IterInt32Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uint64) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uint8 implements an associative array of uint8 indexed by int32.
type MapInt32Uint8 struct {
	length int
	root   nodeMapint32uint8
}

// NewMapInt32Uint8 returns a new map with keys of type int32 and values of type uint8
func NewMapInt32Uint8() *MapInt32Uint8 {
	var r MapInt32Uint8
	return &r
}

type nodeMapint32uint8 struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapint32uint8) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uint8) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uint8) children() *[2]nodeMapint32uint8 {
	return (*[2]nodeMapint32uint8)(c.child)
}

func (c *nodeMapint32uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uint8) find(key int32) (crit uint, child, parent *nodeMapint32uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uint8) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uint8) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uint8) SetP(key int32, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uint8) Set(key int32, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uint8) GetP(key int32) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uint8) Get(key int32) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt32Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uint8 struct {
	t       *MapInt32Uint8
	nodes   []*nodeMapint32uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32  // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uint8.
func (t *MapInt32Uint8) Iterator() *IterInt32Uint8 {
	var i IterInt32Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uint8) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt32Uintptr implements an associative array of uintptr indexed by int32.
type MapInt32Uintptr struct {
	length int
	root   nodeMapint32uintptr
}

// NewMapInt32Uintptr returns a new map with keys of type int32 and values of type uintptr
func NewMapInt32Uintptr() *MapInt32Uintptr {
	var r MapInt32Uintptr
	return &r
}

type nodeMapint32uintptr struct {
	key   int32          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint32uintptr) dir(key int32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint32uintptr) findCrit(key int32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint32uintptr) children() *[2]nodeMapint32uintptr {
	return (*[2]nodeMapint32uintptr)(c.child)
}

func (c *nodeMapint32uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint32uintptr) find(key int32) (crit uint, child, parent *nodeMapint32uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt32Uintptr) transformKey(key int32) int32 {
	var mask int32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt32Uintptr) Rem(key int32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt32Uintptr) SetP(key int32, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt32Uintptr) Set(key int32, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt32Uintptr) GetP(key int32) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt32Uintptr) Get(key int32) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt32Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt32Uintptr struct {
	t       *MapInt32Uintptr
	nodes   []*nodeMapint32uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int32    // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt32Uintptr.
func (t *MapInt32Uintptr) Iterator() *IterInt32Uintptr {
	var i IterInt32Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt32Uintptr) Seek(key int32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt32Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint32uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt32Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt32Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt32Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Bool implements an associative array of bool indexed by int16.
type MapInt16Bool struct {
	length int
	root   nodeMapint16bool
}

// NewMapInt16Bool returns a new map with keys of type int16 and values of type bool
func NewMapInt16Bool() *MapInt16Bool {
	var r MapInt16Bool
	return &r
}

type nodeMapint16bool struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16bool or bool)
}

// Return walking direction
func (c nodeMapint16bool) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16bool) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16bool) children() *[2]nodeMapint16bool {
	return (*[2]nodeMapint16bool)(c.child)
}

func (c *nodeMapint16bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16bool) find(key int16) (crit uint, child, parent *nodeMapint16bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Bool) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Bool) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Bool) SetP(key int16, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Bool) Set(key int16, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Bool) GetP(key int16) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Bool) Get(key int16) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Bool) Length() int {
	return t.length
}

// func (c *nodeMapint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt16Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Bool struct {
	t       *MapInt16Bool
	nodes   []*nodeMapint16bool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Bool.
func (t *MapInt16Bool) Iterator() *IterInt16Bool {
	var i IterInt16Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Bool) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Byte implements an associative array of byte indexed by int16.
type MapInt16Byte struct {
	length int
	root   nodeMapint16byte
}

// NewMapInt16Byte returns a new map with keys of type int16 and values of type byte
func NewMapInt16Byte() *MapInt16Byte {
	var r MapInt16Byte
	return &r
}

type nodeMapint16byte struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16byte or byte)
}

// Return walking direction
func (c nodeMapint16byte) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16byte) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16byte) children() *[2]nodeMapint16byte {
	return (*[2]nodeMapint16byte)(c.child)
}

func (c *nodeMapint16byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16byte) find(key int16) (crit uint, child, parent *nodeMapint16byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Byte) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Byte) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Byte) SetP(key int16, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Byte) Set(key int16, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Byte) GetP(key int16) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Byte) Get(key int16) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Byte) Length() int {
	return t.length
}

// func (c *nodeMapint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt16Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Byte struct {
	t       *MapInt16Byte
	nodes   []*nodeMapint16byte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Byte.
func (t *MapInt16Byte) Iterator() *IterInt16Byte {
	var i IterInt16Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Byte) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Complex128 implements an associative array of complex128 indexed by int16.
type MapInt16Complex128 struct {
	length int
	root   nodeMapint16complex128
}

// NewMapInt16Complex128 returns a new map with keys of type int16 and values of type complex128
func NewMapInt16Complex128() *MapInt16Complex128 {
	var r MapInt16Complex128
	return &r
}

type nodeMapint16complex128 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapint16complex128) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex128) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16complex128) children() *[2]nodeMapint16complex128 {
	return (*[2]nodeMapint16complex128)(c.child)
}

func (c *nodeMapint16complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16complex128) find(key int16) (crit uint, child, parent *nodeMapint16complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Complex128) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Complex128) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Complex128) SetP(key int16, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Complex128) Set(key int16, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Complex128) GetP(key int16) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Complex128) Get(key int16) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt16Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Complex128 struct {
	t       *MapInt16Complex128
	nodes   []*nodeMapint16complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16       // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Complex128.
func (t *MapInt16Complex128) Iterator() *IterInt16Complex128 {
	var i IterInt16Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Complex128) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Complex64 implements an associative array of complex64 indexed by int16.
type MapInt16Complex64 struct {
	length int
	root   nodeMapint16complex64
}

// NewMapInt16Complex64 returns a new map with keys of type int16 and values of type complex64
func NewMapInt16Complex64() *MapInt16Complex64 {
	var r MapInt16Complex64
	return &r
}

type nodeMapint16complex64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapint16complex64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16complex64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16complex64) children() *[2]nodeMapint16complex64 {
	return (*[2]nodeMapint16complex64)(c.child)
}

func (c *nodeMapint16complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16complex64) find(key int16) (crit uint, child, parent *nodeMapint16complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Complex64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Complex64) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Complex64) SetP(key int16, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Complex64) Set(key int16, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Complex64) GetP(key int16) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Complex64) Get(key int16) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt16Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Complex64 struct {
	t       *MapInt16Complex64
	nodes   []*nodeMapint16complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16      // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Complex64.
func (t *MapInt16Complex64) Iterator() *IterInt16Complex64 {
	var i IterInt16Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Complex64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Error implements an associative array of error indexed by int16.
type MapInt16Error struct {
	length int
	root   nodeMapint16error
}

// NewMapInt16Error returns a new map with keys of type int16 and values of type error
func NewMapInt16Error() *MapInt16Error {
	var r MapInt16Error
	return &r
}

type nodeMapint16error struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16error or error)
}

// Return walking direction
func (c nodeMapint16error) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16error) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16error) children() *[2]nodeMapint16error {
	return (*[2]nodeMapint16error)(c.child)
}

func (c *nodeMapint16error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16error) find(key int16) (crit uint, child, parent *nodeMapint16error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Error) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Error) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Error) SetP(key int16, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Error) Set(key int16, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Error) GetP(key int16) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Error) Get(key int16) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Error) Length() int {
	return t.length
}

// func (c *nodeMapint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt16Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Error struct {
	t       *MapInt16Error
	nodes   []*nodeMapint16error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16  // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Error.
func (t *MapInt16Error) Iterator() *IterInt16Error {
	var i IterInt16Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Error) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Float32 implements an associative array of float32 indexed by int16.
type MapInt16Float32 struct {
	length int
	root   nodeMapint16float32
}

// NewMapInt16Float32 returns a new map with keys of type int16 and values of type float32
func NewMapInt16Float32() *MapInt16Float32 {
	var r MapInt16Float32
	return &r
}

type nodeMapint16float32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float32 or float32)
}

// Return walking direction
func (c nodeMapint16float32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16float32) children() *[2]nodeMapint16float32 {
	return (*[2]nodeMapint16float32)(c.child)
}

func (c *nodeMapint16float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16float32) find(key int16) (crit uint, child, parent *nodeMapint16float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Float32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Float32) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Float32) SetP(key int16, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Float32) Set(key int16, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Float32) GetP(key int16) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Float32) Get(key int16) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float32) Length() int {
	return t.length
}

// func (c *nodeMapint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt16Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Float32 struct {
	t       *MapInt16Float32
	nodes   []*nodeMapint16float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16    // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Float32.
func (t *MapInt16Float32) Iterator() *IterInt16Float32 {
	var i IterInt16Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Float32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Float64 implements an associative array of float64 indexed by int16.
type MapInt16Float64 struct {
	length int
	root   nodeMapint16float64
}

// NewMapInt16Float64 returns a new map with keys of type int16 and values of type float64
func NewMapInt16Float64() *MapInt16Float64 {
	var r MapInt16Float64
	return &r
}

type nodeMapint16float64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16float64 or float64)
}

// Return walking direction
func (c nodeMapint16float64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16float64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16float64) children() *[2]nodeMapint16float64 {
	return (*[2]nodeMapint16float64)(c.child)
}

func (c *nodeMapint16float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16float64) find(key int16) (crit uint, child, parent *nodeMapint16float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Float64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Float64) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Float64) SetP(key int16, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Float64) Set(key int16, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Float64) GetP(key int16) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Float64) Get(key int16) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Float64) Length() int {
	return t.length
}

// func (c *nodeMapint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt16Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Float64 struct {
	t       *MapInt16Float64
	nodes   []*nodeMapint16float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16    // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Float64.
func (t *MapInt16Float64) Iterator() *IterInt16Float64 {
	var i IterInt16Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Float64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Int implements an associative array of int indexed by int16.
type MapInt16Int struct {
	length int
	root   nodeMapint16int
}

// NewMapInt16Int returns a new map with keys of type int16 and values of type int
func NewMapInt16Int() *MapInt16Int {
	var r MapInt16Int
	return &r
}

type nodeMapint16int struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int or int)
}

// Return walking direction
func (c nodeMapint16int) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int) children() *[2]nodeMapint16int {
	return (*[2]nodeMapint16int)(c.child)
}

func (c *nodeMapint16int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16int) find(key int16) (crit uint, child, parent *nodeMapint16int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Int) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Int) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int) SetP(key int16, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int) Set(key int16, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int) GetP(key int16) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int) Get(key int16) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int) Length() int {
	return t.length
}

// func (c *nodeMapint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt16Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int struct {
	t       *MapInt16Int
	nodes   []*nodeMapint16int
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int.
func (t *MapInt16Int) Iterator() *IterInt16Int {
	var i IterInt16Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Int) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Int16 implements an associative array of int16 indexed by int16.
type MapInt16Int16 struct {
	length int
	root   nodeMapint16int16
}

// NewMapInt16Int16 returns a new map with keys of type int16 and values of type int16
func NewMapInt16Int16() *MapInt16Int16 {
	var r MapInt16Int16
	return &r
}

type nodeMapint16int16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int16 or int16)
}

// Return walking direction
func (c nodeMapint16int16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int16) children() *[2]nodeMapint16int16 {
	return (*[2]nodeMapint16int16)(c.child)
}

func (c *nodeMapint16int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16int16) find(key int16) (crit uint, child, parent *nodeMapint16int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Int16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Int16) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int16) SetP(key int16, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int16) Set(key int16, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int16) GetP(key int16) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int16) Get(key int16) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int16) Length() int {
	return t.length
}

// func (c *nodeMapint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt16Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int16 struct {
	t       *MapInt16Int16
	nodes   []*nodeMapint16int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16  // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int16.
func (t *MapInt16Int16) Iterator() *IterInt16Int16 {
	var i IterInt16Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Int16) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Int32 implements an associative array of int32 indexed by int16.
type MapInt16Int32 struct {
	length int
	root   nodeMapint16int32
}

// NewMapInt16Int32 returns a new map with keys of type int16 and values of type int32
func NewMapInt16Int32() *MapInt16Int32 {
	var r MapInt16Int32
	return &r
}

type nodeMapint16int32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int32 or int32)
}

// Return walking direction
func (c nodeMapint16int32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int32) children() *[2]nodeMapint16int32 {
	return (*[2]nodeMapint16int32)(c.child)
}

func (c *nodeMapint16int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16int32) find(key int16) (crit uint, child, parent *nodeMapint16int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Int32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Int32) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int32) SetP(key int16, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int32) Set(key int16, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int32) GetP(key int16) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int32) Get(key int16) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int32) Length() int {
	return t.length
}

// func (c *nodeMapint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt16Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int32 struct {
	t       *MapInt16Int32
	nodes   []*nodeMapint16int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16  // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int32.
func (t *MapInt16Int32) Iterator() *IterInt16Int32 {
	var i IterInt16Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Int32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Int64 implements an associative array of int64 indexed by int16.
type MapInt16Int64 struct {
	length int
	root   nodeMapint16int64
}

// NewMapInt16Int64 returns a new map with keys of type int16 and values of type int64
func NewMapInt16Int64() *MapInt16Int64 {
	var r MapInt16Int64
	return &r
}

type nodeMapint16int64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int64 or int64)
}

// Return walking direction
func (c nodeMapint16int64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int64) children() *[2]nodeMapint16int64 {
	return (*[2]nodeMapint16int64)(c.child)
}

func (c *nodeMapint16int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16int64) find(key int16) (crit uint, child, parent *nodeMapint16int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Int64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Int64) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int64) SetP(key int16, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int64) Set(key int16, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int64) GetP(key int16) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int64) Get(key int16) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int64) Length() int {
	return t.length
}

// func (c *nodeMapint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt16Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int64 struct {
	t       *MapInt16Int64
	nodes   []*nodeMapint16int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16  // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int64.
func (t *MapInt16Int64) Iterator() *IterInt16Int64 {
	var i IterInt16Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Int64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Int8 implements an associative array of int8 indexed by int16.
type MapInt16Int8 struct {
	length int
	root   nodeMapint16int8
}

// NewMapInt16Int8 returns a new map with keys of type int16 and values of type int8
func NewMapInt16Int8() *MapInt16Int8 {
	var r MapInt16Int8
	return &r
}

type nodeMapint16int8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16int8 or int8)
}

// Return walking direction
func (c nodeMapint16int8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16int8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16int8) children() *[2]nodeMapint16int8 {
	return (*[2]nodeMapint16int8)(c.child)
}

func (c *nodeMapint16int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16int8) find(key int16) (crit uint, child, parent *nodeMapint16int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Int8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Int8) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Int8) SetP(key int16, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Int8) Set(key int16, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Int8) GetP(key int16) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Int8) Get(key int16) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Int8) Length() int {
	return t.length
}

// func (c *nodeMapint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt16Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Int8 struct {
	t       *MapInt16Int8
	nodes   []*nodeMapint16int8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Int8.
func (t *MapInt16Int8) Iterator() *IterInt16Int8 {
	var i IterInt16Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Int8) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Rune implements an associative array of rune indexed by int16.
type MapInt16Rune struct {
	length int
	root   nodeMapint16rune
}

// NewMapInt16Rune returns a new map with keys of type int16 and values of type rune
func NewMapInt16Rune() *MapInt16Rune {
	var r MapInt16Rune
	return &r
}

type nodeMapint16rune struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16rune or rune)
}

// Return walking direction
func (c nodeMapint16rune) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16rune) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16rune) children() *[2]nodeMapint16rune {
	return (*[2]nodeMapint16rune)(c.child)
}

func (c *nodeMapint16rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16rune) find(key int16) (crit uint, child, parent *nodeMapint16rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Rune) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Rune) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Rune) SetP(key int16, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Rune) Set(key int16, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Rune) GetP(key int16) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Rune) Get(key int16) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Rune) Length() int {
	return t.length
}

// func (c *nodeMapint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt16Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Rune struct {
	t       *MapInt16Rune
	nodes   []*nodeMapint16rune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Rune.
func (t *MapInt16Rune) Iterator() *IterInt16Rune {
	var i IterInt16Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Rune) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16String implements an associative array of string indexed by int16.
type MapInt16String struct {
	length int
	root   nodeMapint16string
}

// NewMapInt16String returns a new map with keys of type int16 and values of type string
func NewMapInt16String() *MapInt16String {
	var r MapInt16String
	return &r
}

type nodeMapint16string struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16string or string)
}

// Return walking direction
func (c nodeMapint16string) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16string) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16string) children() *[2]nodeMapint16string {
	return (*[2]nodeMapint16string)(c.child)
}

func (c *nodeMapint16string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16string) find(key int16) (crit uint, child, parent *nodeMapint16string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16String) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16String) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16String) SetP(key int16, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16String) Set(key int16, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16String) GetP(key int16) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16String) Get(key int16) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16String) Length() int {
	return t.length
}

// func (c *nodeMapint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt16String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16String struct {
	t       *MapInt16String
	nodes   []*nodeMapint16string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16   // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16String.
func (t *MapInt16String) Iterator() *IterInt16String {
	var i IterInt16String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16String) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uint implements an associative array of uint indexed by int16.
type MapInt16Uint struct {
	length int
	root   nodeMapint16uint
}

// NewMapInt16Uint returns a new map with keys of type int16 and values of type uint
func NewMapInt16Uint() *MapInt16Uint {
	var r MapInt16Uint
	return &r
}

type nodeMapint16uint struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint or uint)
}

// Return walking direction
func (c nodeMapint16uint) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint) children() *[2]nodeMapint16uint {
	return (*[2]nodeMapint16uint)(c.child)
}

func (c *nodeMapint16uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uint) find(key int16) (crit uint, child, parent *nodeMapint16uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uint) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uint) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint) SetP(key int16, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint) Set(key int16, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint) GetP(key int16) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint) Get(key int16) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint) Length() int {
	return t.length
}

// func (c *nodeMapint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt16Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint struct {
	t       *MapInt16Uint
	nodes   []*nodeMapint16uint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16 // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint.
func (t *MapInt16Uint) Iterator() *IterInt16Uint {
	var i IterInt16Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uint) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uint16 implements an associative array of uint16 indexed by int16.
type MapInt16Uint16 struct {
	length int
	root   nodeMapint16uint16
}

// NewMapInt16Uint16 returns a new map with keys of type int16 and values of type uint16
func NewMapInt16Uint16() *MapInt16Uint16 {
	var r MapInt16Uint16
	return &r
}

type nodeMapint16uint16 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapint16uint16) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint16) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint16) children() *[2]nodeMapint16uint16 {
	return (*[2]nodeMapint16uint16)(c.child)
}

func (c *nodeMapint16uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uint16) find(key int16) (crit uint, child, parent *nodeMapint16uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uint16) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uint16) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint16) SetP(key int16, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint16) Set(key int16, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint16) GetP(key int16) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint16) Get(key int16) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt16Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint16 struct {
	t       *MapInt16Uint16
	nodes   []*nodeMapint16uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16   // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint16.
func (t *MapInt16Uint16) Iterator() *IterInt16Uint16 {
	var i IterInt16Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uint16) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uint32 implements an associative array of uint32 indexed by int16.
type MapInt16Uint32 struct {
	length int
	root   nodeMapint16uint32
}

// NewMapInt16Uint32 returns a new map with keys of type int16 and values of type uint32
func NewMapInt16Uint32() *MapInt16Uint32 {
	var r MapInt16Uint32
	return &r
}

type nodeMapint16uint32 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapint16uint32) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint32) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint32) children() *[2]nodeMapint16uint32 {
	return (*[2]nodeMapint16uint32)(c.child)
}

func (c *nodeMapint16uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uint32) find(key int16) (crit uint, child, parent *nodeMapint16uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uint32) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uint32) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint32) SetP(key int16, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint32) Set(key int16, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint32) GetP(key int16) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint32) Get(key int16) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt16Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint32 struct {
	t       *MapInt16Uint32
	nodes   []*nodeMapint16uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16   // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint32.
func (t *MapInt16Uint32) Iterator() *IterInt16Uint32 {
	var i IterInt16Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uint32) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uint64 implements an associative array of uint64 indexed by int16.
type MapInt16Uint64 struct {
	length int
	root   nodeMapint16uint64
}

// NewMapInt16Uint64 returns a new map with keys of type int16 and values of type uint64
func NewMapInt16Uint64() *MapInt16Uint64 {
	var r MapInt16Uint64
	return &r
}

type nodeMapint16uint64 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapint16uint64) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint64) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint64) children() *[2]nodeMapint16uint64 {
	return (*[2]nodeMapint16uint64)(c.child)
}

func (c *nodeMapint16uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uint64) find(key int16) (crit uint, child, parent *nodeMapint16uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uint64) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uint64) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint64) SetP(key int16, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint64) Set(key int16, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint64) GetP(key int16) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint64) Get(key int16) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt16Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint64 struct {
	t       *MapInt16Uint64
	nodes   []*nodeMapint16uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16   // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint64.
func (t *MapInt16Uint64) Iterator() *IterInt16Uint64 {
	var i IterInt16Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uint64) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uint8 implements an associative array of uint8 indexed by int16.
type MapInt16Uint8 struct {
	length int
	root   nodeMapint16uint8
}

// NewMapInt16Uint8 returns a new map with keys of type int16 and values of type uint8
func NewMapInt16Uint8() *MapInt16Uint8 {
	var r MapInt16Uint8
	return &r
}

type nodeMapint16uint8 struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapint16uint8) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uint8) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uint8) children() *[2]nodeMapint16uint8 {
	return (*[2]nodeMapint16uint8)(c.child)
}

func (c *nodeMapint16uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uint8) find(key int16) (crit uint, child, parent *nodeMapint16uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uint8) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uint8) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uint8) SetP(key int16, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uint8) Set(key int16, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uint8) GetP(key int16) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uint8) Get(key int16) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt16Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uint8 struct {
	t       *MapInt16Uint8
	nodes   []*nodeMapint16uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16  // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uint8.
func (t *MapInt16Uint8) Iterator() *IterInt16Uint8 {
	var i IterInt16Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uint8) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt16Uintptr implements an associative array of uintptr indexed by int16.
type MapInt16Uintptr struct {
	length int
	root   nodeMapint16uintptr
}

// NewMapInt16Uintptr returns a new map with keys of type int16 and values of type uintptr
func NewMapInt16Uintptr() *MapInt16Uintptr {
	var r MapInt16Uintptr
	return &r
}

type nodeMapint16uintptr struct {
	key   int16          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint16uintptr) dir(key int16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint16uintptr) findCrit(key int16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint16uintptr) children() *[2]nodeMapint16uintptr {
	return (*[2]nodeMapint16uintptr)(c.child)
}

func (c *nodeMapint16uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint16uintptr) find(key int16) (crit uint, child, parent *nodeMapint16uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt16Uintptr) transformKey(key int16) int16 {
	var mask int16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt16Uintptr) Rem(key int16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt16Uintptr) SetP(key int16, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt16Uintptr) Set(key int16, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt16Uintptr) GetP(key int16) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt16Uintptr) Get(key int16) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt16Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt16Uintptr struct {
	t       *MapInt16Uintptr
	nodes   []*nodeMapint16uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int16    // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt16Uintptr.
func (t *MapInt16Uintptr) Iterator() *IterInt16Uintptr {
	var i IterInt16Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt16Uintptr) Seek(key int16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt16Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint16uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt16Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt16Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt16Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Bool implements an associative array of bool indexed by int8.
type MapInt8Bool struct {
	length int
	root   nodeMapint8bool
}

// NewMapInt8Bool returns a new map with keys of type int8 and values of type bool
func NewMapInt8Bool() *MapInt8Bool {
	var r MapInt8Bool
	return &r
}

type nodeMapint8bool struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8bool or bool)
}

// Return walking direction
func (c nodeMapint8bool) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8bool) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8bool) children() *[2]nodeMapint8bool {
	return (*[2]nodeMapint8bool)(c.child)
}

func (c *nodeMapint8bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8bool) find(key int8) (crit uint, child, parent *nodeMapint8bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Bool) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Bool) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Bool) SetP(key int8, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Bool) Set(key int8, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Bool) GetP(key int8) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Bool) Get(key int8) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Bool) Length() int {
	return t.length
}

// func (c *nodeMapint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterInt8Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Bool struct {
	t       *MapInt8Bool
	nodes   []*nodeMapint8bool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8  // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Bool.
func (t *MapInt8Bool) Iterator() *IterInt8Bool {
	var i IterInt8Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Bool) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Byte implements an associative array of byte indexed by int8.
type MapInt8Byte struct {
	length int
	root   nodeMapint8byte
}

// NewMapInt8Byte returns a new map with keys of type int8 and values of type byte
func NewMapInt8Byte() *MapInt8Byte {
	var r MapInt8Byte
	return &r
}

type nodeMapint8byte struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8byte or byte)
}

// Return walking direction
func (c nodeMapint8byte) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8byte) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8byte) children() *[2]nodeMapint8byte {
	return (*[2]nodeMapint8byte)(c.child)
}

func (c *nodeMapint8byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8byte) find(key int8) (crit uint, child, parent *nodeMapint8byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Byte) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Byte) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Byte) SetP(key int8, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Byte) Set(key int8, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Byte) GetP(key int8) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Byte) Get(key int8) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Byte) Length() int {
	return t.length
}

// func (c *nodeMapint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterInt8Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Byte struct {
	t       *MapInt8Byte
	nodes   []*nodeMapint8byte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8  // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Byte.
func (t *MapInt8Byte) Iterator() *IterInt8Byte {
	var i IterInt8Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Byte) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Complex128 implements an associative array of complex128 indexed by int8.
type MapInt8Complex128 struct {
	length int
	root   nodeMapint8complex128
}

// NewMapInt8Complex128 returns a new map with keys of type int8 and values of type complex128
func NewMapInt8Complex128() *MapInt8Complex128 {
	var r MapInt8Complex128
	return &r
}

type nodeMapint8complex128 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapint8complex128) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex128) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8complex128) children() *[2]nodeMapint8complex128 {
	return (*[2]nodeMapint8complex128)(c.child)
}

func (c *nodeMapint8complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8complex128) find(key int8) (crit uint, child, parent *nodeMapint8complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Complex128) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Complex128) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Complex128) SetP(key int8, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Complex128) Set(key int8, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Complex128) GetP(key int8) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Complex128) Get(key int8) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterInt8Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Complex128 struct {
	t       *MapInt8Complex128
	nodes   []*nodeMapint8complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8        // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Complex128.
func (t *MapInt8Complex128) Iterator() *IterInt8Complex128 {
	var i IterInt8Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Complex128) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Complex64 implements an associative array of complex64 indexed by int8.
type MapInt8Complex64 struct {
	length int
	root   nodeMapint8complex64
}

// NewMapInt8Complex64 returns a new map with keys of type int8 and values of type complex64
func NewMapInt8Complex64() *MapInt8Complex64 {
	var r MapInt8Complex64
	return &r
}

type nodeMapint8complex64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapint8complex64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8complex64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8complex64) children() *[2]nodeMapint8complex64 {
	return (*[2]nodeMapint8complex64)(c.child)
}

func (c *nodeMapint8complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8complex64) find(key int8) (crit uint, child, parent *nodeMapint8complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Complex64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Complex64) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Complex64) SetP(key int8, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Complex64) Set(key int8, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Complex64) GetP(key int8) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Complex64) Get(key int8) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterInt8Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Complex64 struct {
	t       *MapInt8Complex64
	nodes   []*nodeMapint8complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8       // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Complex64.
func (t *MapInt8Complex64) Iterator() *IterInt8Complex64 {
	var i IterInt8Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Complex64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Error implements an associative array of error indexed by int8.
type MapInt8Error struct {
	length int
	root   nodeMapint8error
}

// NewMapInt8Error returns a new map with keys of type int8 and values of type error
func NewMapInt8Error() *MapInt8Error {
	var r MapInt8Error
	return &r
}

type nodeMapint8error struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8error or error)
}

// Return walking direction
func (c nodeMapint8error) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8error) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8error) children() *[2]nodeMapint8error {
	return (*[2]nodeMapint8error)(c.child)
}

func (c *nodeMapint8error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8error) find(key int8) (crit uint, child, parent *nodeMapint8error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Error) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Error) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Error) SetP(key int8, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Error) Set(key int8, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Error) GetP(key int8) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Error) Get(key int8) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Error) Length() int {
	return t.length
}

// func (c *nodeMapint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterInt8Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Error struct {
	t       *MapInt8Error
	nodes   []*nodeMapint8error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8   // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Error.
func (t *MapInt8Error) Iterator() *IterInt8Error {
	var i IterInt8Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Error) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Float32 implements an associative array of float32 indexed by int8.
type MapInt8Float32 struct {
	length int
	root   nodeMapint8float32
}

// NewMapInt8Float32 returns a new map with keys of type int8 and values of type float32
func NewMapInt8Float32() *MapInt8Float32 {
	var r MapInt8Float32
	return &r
}

type nodeMapint8float32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float32 or float32)
}

// Return walking direction
func (c nodeMapint8float32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8float32) children() *[2]nodeMapint8float32 {
	return (*[2]nodeMapint8float32)(c.child)
}

func (c *nodeMapint8float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8float32) find(key int8) (crit uint, child, parent *nodeMapint8float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Float32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Float32) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Float32) SetP(key int8, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Float32) Set(key int8, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Float32) GetP(key int8) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Float32) Get(key int8) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float32) Length() int {
	return t.length
}

// func (c *nodeMapint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterInt8Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Float32 struct {
	t       *MapInt8Float32
	nodes   []*nodeMapint8float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8     // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Float32.
func (t *MapInt8Float32) Iterator() *IterInt8Float32 {
	var i IterInt8Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Float32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Float64 implements an associative array of float64 indexed by int8.
type MapInt8Float64 struct {
	length int
	root   nodeMapint8float64
}

// NewMapInt8Float64 returns a new map with keys of type int8 and values of type float64
func NewMapInt8Float64() *MapInt8Float64 {
	var r MapInt8Float64
	return &r
}

type nodeMapint8float64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8float64 or float64)
}

// Return walking direction
func (c nodeMapint8float64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8float64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8float64) children() *[2]nodeMapint8float64 {
	return (*[2]nodeMapint8float64)(c.child)
}

func (c *nodeMapint8float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8float64) find(key int8) (crit uint, child, parent *nodeMapint8float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Float64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Float64) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Float64) SetP(key int8, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Float64) Set(key int8, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Float64) GetP(key int8) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Float64) Get(key int8) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Float64) Length() int {
	return t.length
}

// func (c *nodeMapint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterInt8Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Float64 struct {
	t       *MapInt8Float64
	nodes   []*nodeMapint8float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8     // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Float64.
func (t *MapInt8Float64) Iterator() *IterInt8Float64 {
	var i IterInt8Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Float64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Int implements an associative array of int indexed by int8.
type MapInt8Int struct {
	length int
	root   nodeMapint8int
}

// NewMapInt8Int returns a new map with keys of type int8 and values of type int
func NewMapInt8Int() *MapInt8Int {
	var r MapInt8Int
	return &r
}

type nodeMapint8int struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int or int)
}

// Return walking direction
func (c nodeMapint8int) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int) children() *[2]nodeMapint8int {
	return (*[2]nodeMapint8int)(c.child)
}

func (c *nodeMapint8int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8int) find(key int8) (crit uint, child, parent *nodeMapint8int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Int) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Int) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int) SetP(key int8, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int) Set(key int8, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int) GetP(key int8) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int) Get(key int8) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int) Length() int {
	return t.length
}

// func (c *nodeMapint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterInt8Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int struct {
	t       *MapInt8Int
	nodes   []*nodeMapint8int
	lastDir int
	Found   bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8 // Key found by last call to Next, Prev.
	Value   *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int.
func (t *MapInt8Int) Iterator() *IterInt8Int {
	var i IterInt8Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Int) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Int16 implements an associative array of int16 indexed by int8.
type MapInt8Int16 struct {
	length int
	root   nodeMapint8int16
}

// NewMapInt8Int16 returns a new map with keys of type int8 and values of type int16
func NewMapInt8Int16() *MapInt8Int16 {
	var r MapInt8Int16
	return &r
}

type nodeMapint8int16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int16 or int16)
}

// Return walking direction
func (c nodeMapint8int16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int16) children() *[2]nodeMapint8int16 {
	return (*[2]nodeMapint8int16)(c.child)
}

func (c *nodeMapint8int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8int16) find(key int8) (crit uint, child, parent *nodeMapint8int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Int16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Int16) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int16) SetP(key int8, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int16) Set(key int8, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int16) GetP(key int8) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int16) Get(key int8) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int16) Length() int {
	return t.length
}

// func (c *nodeMapint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterInt8Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int16 struct {
	t       *MapInt8Int16
	nodes   []*nodeMapint8int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8   // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int16.
func (t *MapInt8Int16) Iterator() *IterInt8Int16 {
	var i IterInt8Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Int16) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Int32 implements an associative array of int32 indexed by int8.
type MapInt8Int32 struct {
	length int
	root   nodeMapint8int32
}

// NewMapInt8Int32 returns a new map with keys of type int8 and values of type int32
func NewMapInt8Int32() *MapInt8Int32 {
	var r MapInt8Int32
	return &r
}

type nodeMapint8int32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int32 or int32)
}

// Return walking direction
func (c nodeMapint8int32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int32) children() *[2]nodeMapint8int32 {
	return (*[2]nodeMapint8int32)(c.child)
}

func (c *nodeMapint8int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8int32) find(key int8) (crit uint, child, parent *nodeMapint8int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Int32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Int32) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int32) SetP(key int8, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int32) Set(key int8, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int32) GetP(key int8) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int32) Get(key int8) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int32) Length() int {
	return t.length
}

// func (c *nodeMapint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterInt8Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int32 struct {
	t       *MapInt8Int32
	nodes   []*nodeMapint8int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8   // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int32.
func (t *MapInt8Int32) Iterator() *IterInt8Int32 {
	var i IterInt8Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Int32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Int64 implements an associative array of int64 indexed by int8.
type MapInt8Int64 struct {
	length int
	root   nodeMapint8int64
}

// NewMapInt8Int64 returns a new map with keys of type int8 and values of type int64
func NewMapInt8Int64() *MapInt8Int64 {
	var r MapInt8Int64
	return &r
}

type nodeMapint8int64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int64 or int64)
}

// Return walking direction
func (c nodeMapint8int64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int64) children() *[2]nodeMapint8int64 {
	return (*[2]nodeMapint8int64)(c.child)
}

func (c *nodeMapint8int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8int64) find(key int8) (crit uint, child, parent *nodeMapint8int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Int64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Int64) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int64) SetP(key int8, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int64) Set(key int8, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int64) GetP(key int8) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int64) Get(key int8) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int64) Length() int {
	return t.length
}

// func (c *nodeMapint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterInt8Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int64 struct {
	t       *MapInt8Int64
	nodes   []*nodeMapint8int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8   // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int64.
func (t *MapInt8Int64) Iterator() *IterInt8Int64 {
	var i IterInt8Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Int64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Int8 implements an associative array of int8 indexed by int8.
type MapInt8Int8 struct {
	length int
	root   nodeMapint8int8
}

// NewMapInt8Int8 returns a new map with keys of type int8 and values of type int8
func NewMapInt8Int8() *MapInt8Int8 {
	var r MapInt8Int8
	return &r
}

type nodeMapint8int8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8int8 or int8)
}

// Return walking direction
func (c nodeMapint8int8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8int8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8int8) children() *[2]nodeMapint8int8 {
	return (*[2]nodeMapint8int8)(c.child)
}

func (c *nodeMapint8int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8int8) find(key int8) (crit uint, child, parent *nodeMapint8int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Int8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Int8) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Int8) SetP(key int8, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Int8) Set(key int8, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Int8) GetP(key int8) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Int8) Get(key int8) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Int8) Length() int {
	return t.length
}

// func (c *nodeMapint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterInt8Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Int8 struct {
	t       *MapInt8Int8
	nodes   []*nodeMapint8int8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8  // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Int8.
func (t *MapInt8Int8) Iterator() *IterInt8Int8 {
	var i IterInt8Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Int8) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Rune implements an associative array of rune indexed by int8.
type MapInt8Rune struct {
	length int
	root   nodeMapint8rune
}

// NewMapInt8Rune returns a new map with keys of type int8 and values of type rune
func NewMapInt8Rune() *MapInt8Rune {
	var r MapInt8Rune
	return &r
}

type nodeMapint8rune struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8rune or rune)
}

// Return walking direction
func (c nodeMapint8rune) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8rune) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8rune) children() *[2]nodeMapint8rune {
	return (*[2]nodeMapint8rune)(c.child)
}

func (c *nodeMapint8rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8rune) find(key int8) (crit uint, child, parent *nodeMapint8rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Rune) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Rune) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Rune) SetP(key int8, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Rune) Set(key int8, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Rune) GetP(key int8) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Rune) Get(key int8) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Rune) Length() int {
	return t.length
}

// func (c *nodeMapint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterInt8Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Rune struct {
	t       *MapInt8Rune
	nodes   []*nodeMapint8rune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8  // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Rune.
func (t *MapInt8Rune) Iterator() *IterInt8Rune {
	var i IterInt8Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Rune) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8String implements an associative array of string indexed by int8.
type MapInt8String struct {
	length int
	root   nodeMapint8string
}

// NewMapInt8String returns a new map with keys of type int8 and values of type string
func NewMapInt8String() *MapInt8String {
	var r MapInt8String
	return &r
}

type nodeMapint8string struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8string or string)
}

// Return walking direction
func (c nodeMapint8string) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8string) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8string) children() *[2]nodeMapint8string {
	return (*[2]nodeMapint8string)(c.child)
}

func (c *nodeMapint8string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8string) find(key int8) (crit uint, child, parent *nodeMapint8string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8String) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8String) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8String) SetP(key int8, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8String) Set(key int8, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8String) GetP(key int8) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8String) Get(key int8) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8String) Length() int {
	return t.length
}

// func (c *nodeMapint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterInt8String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8String struct {
	t       *MapInt8String
	nodes   []*nodeMapint8string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8    // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8String.
func (t *MapInt8String) Iterator() *IterInt8String {
	var i IterInt8String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8String) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uint implements an associative array of uint indexed by int8.
type MapInt8Uint struct {
	length int
	root   nodeMapint8uint
}

// NewMapInt8Uint returns a new map with keys of type int8 and values of type uint
func NewMapInt8Uint() *MapInt8Uint {
	var r MapInt8Uint
	return &r
}

type nodeMapint8uint struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint or uint)
}

// Return walking direction
func (c nodeMapint8uint) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint) children() *[2]nodeMapint8uint {
	return (*[2]nodeMapint8uint)(c.child)
}

func (c *nodeMapint8uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uint) find(key int8) (crit uint, child, parent *nodeMapint8uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uint) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uint) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint) SetP(key int8, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint) Set(key int8, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint) GetP(key int8) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint) Get(key int8) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint) Length() int {
	return t.length
}

// func (c *nodeMapint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterInt8Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint struct {
	t       *MapInt8Uint
	nodes   []*nodeMapint8uint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8  // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint.
func (t *MapInt8Uint) Iterator() *IterInt8Uint {
	var i IterInt8Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uint) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uint16 implements an associative array of uint16 indexed by int8.
type MapInt8Uint16 struct {
	length int
	root   nodeMapint8uint16
}

// NewMapInt8Uint16 returns a new map with keys of type int8 and values of type uint16
func NewMapInt8Uint16() *MapInt8Uint16 {
	var r MapInt8Uint16
	return &r
}

type nodeMapint8uint16 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapint8uint16) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint16) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint16) children() *[2]nodeMapint8uint16 {
	return (*[2]nodeMapint8uint16)(c.child)
}

func (c *nodeMapint8uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uint16) find(key int8) (crit uint, child, parent *nodeMapint8uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uint16) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uint16) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint16) SetP(key int8, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint16) Set(key int8, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint16) GetP(key int8) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint16) Get(key int8) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterInt8Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint16 struct {
	t       *MapInt8Uint16
	nodes   []*nodeMapint8uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8    // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint16.
func (t *MapInt8Uint16) Iterator() *IterInt8Uint16 {
	var i IterInt8Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uint16) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uint32 implements an associative array of uint32 indexed by int8.
type MapInt8Uint32 struct {
	length int
	root   nodeMapint8uint32
}

// NewMapInt8Uint32 returns a new map with keys of type int8 and values of type uint32
func NewMapInt8Uint32() *MapInt8Uint32 {
	var r MapInt8Uint32
	return &r
}

type nodeMapint8uint32 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapint8uint32) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint32) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint32) children() *[2]nodeMapint8uint32 {
	return (*[2]nodeMapint8uint32)(c.child)
}

func (c *nodeMapint8uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uint32) find(key int8) (crit uint, child, parent *nodeMapint8uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uint32) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uint32) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint32) SetP(key int8, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint32) Set(key int8, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint32) GetP(key int8) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint32) Get(key int8) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterInt8Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint32 struct {
	t       *MapInt8Uint32
	nodes   []*nodeMapint8uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8    // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint32.
func (t *MapInt8Uint32) Iterator() *IterInt8Uint32 {
	var i IterInt8Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uint32) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uint64 implements an associative array of uint64 indexed by int8.
type MapInt8Uint64 struct {
	length int
	root   nodeMapint8uint64
}

// NewMapInt8Uint64 returns a new map with keys of type int8 and values of type uint64
func NewMapInt8Uint64() *MapInt8Uint64 {
	var r MapInt8Uint64
	return &r
}

type nodeMapint8uint64 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapint8uint64) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint64) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint64) children() *[2]nodeMapint8uint64 {
	return (*[2]nodeMapint8uint64)(c.child)
}

func (c *nodeMapint8uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uint64) find(key int8) (crit uint, child, parent *nodeMapint8uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uint64) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uint64) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint64) SetP(key int8, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint64) Set(key int8, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint64) GetP(key int8) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint64) Get(key int8) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterInt8Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint64 struct {
	t       *MapInt8Uint64
	nodes   []*nodeMapint8uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8    // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint64.
func (t *MapInt8Uint64) Iterator() *IterInt8Uint64 {
	var i IterInt8Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uint64) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uint8 implements an associative array of uint8 indexed by int8.
type MapInt8Uint8 struct {
	length int
	root   nodeMapint8uint8
}

// NewMapInt8Uint8 returns a new map with keys of type int8 and values of type uint8
func NewMapInt8Uint8() *MapInt8Uint8 {
	var r MapInt8Uint8
	return &r
}

type nodeMapint8uint8 struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapint8uint8) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uint8) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uint8) children() *[2]nodeMapint8uint8 {
	return (*[2]nodeMapint8uint8)(c.child)
}

func (c *nodeMapint8uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uint8) find(key int8) (crit uint, child, parent *nodeMapint8uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uint8) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uint8) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uint8) SetP(key int8, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uint8) Set(key int8, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uint8) GetP(key int8) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uint8) Get(key int8) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterInt8Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uint8 struct {
	t       *MapInt8Uint8
	nodes   []*nodeMapint8uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8   // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uint8.
func (t *MapInt8Uint8) Iterator() *IterInt8Uint8 {
	var i IterInt8Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uint8) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapInt8Uintptr implements an associative array of uintptr indexed by int8.
type MapInt8Uintptr struct {
	length int
	root   nodeMapint8uintptr
}

// NewMapInt8Uintptr returns a new map with keys of type int8 and values of type uintptr
func NewMapInt8Uintptr() *MapInt8Uintptr {
	var r MapInt8Uintptr
	return &r
}

type nodeMapint8uintptr struct {
	key   int8           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapint8uintptr) dir(key int8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapint8uintptr) findCrit(key int8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapint8uintptr) children() *[2]nodeMapint8uintptr {
	return (*[2]nodeMapint8uintptr)(c.child)
}

func (c *nodeMapint8uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapint8uintptr) find(key int8) (crit uint, child, parent *nodeMapint8uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapInt8Uintptr) transformKey(key int8) int8 {
	var mask int8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapInt8Uintptr) Rem(key int8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapInt8Uintptr) SetP(key int8, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapInt8Uintptr) Set(key int8, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapInt8Uintptr) GetP(key int8) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapInt8Uintptr) Get(key int8) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapInt8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterInt8Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterInt8Uintptr struct {
	t       *MapInt8Uintptr
	nodes   []*nodeMapint8uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     int8     // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterInt8Uintptr.
func (t *MapInt8Uintptr) Iterator() *IterInt8Uintptr {
	var i IterInt8Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterInt8Uintptr) Seek(key int8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterInt8Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapint8uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterInt8Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterInt8Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterInt8Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintBool implements an associative array of bool indexed by uint.
type MapUintBool struct {
	length int
	root   nodeMapuintbool
}

// NewMapUintBool returns a new map with keys of type uint and values of type bool
func NewMapUintBool() *MapUintBool {
	var r MapUintBool
	return &r
}

type nodeMapuintbool struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbool or bool)
}

// Return walking direction
func (c nodeMapuintbool) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbool) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintbool) children() *[2]nodeMapuintbool {
	return (*[2]nodeMapuintbool)(c.child)
}

func (c *nodeMapuintbool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintbool) find(key uint) (crit uint, child, parent *nodeMapuintbool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintBool) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintBool) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintBool) SetP(key uint, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintBool) Set(key uint, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintBool) GetP(key uint) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintBool) Get(key uint) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintBool) Length() int {
	return t.length
}

// func (c *nodeMapuintbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUintBool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintBool struct {
	t       *MapUintBool
	nodes   []*nodeMapuintbool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint  // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintBool.
func (t *MapUintBool) Iterator() *IterUintBool {
	var i IterUintBool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintBool) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintBool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintbool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintBool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintBool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintBool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintByte implements an associative array of byte indexed by uint.
type MapUintByte struct {
	length int
	root   nodeMapuintbyte
}

// NewMapUintByte returns a new map with keys of type uint and values of type byte
func NewMapUintByte() *MapUintByte {
	var r MapUintByte
	return &r
}

type nodeMapuintbyte struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintbyte or byte)
}

// Return walking direction
func (c nodeMapuintbyte) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintbyte) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintbyte) children() *[2]nodeMapuintbyte {
	return (*[2]nodeMapuintbyte)(c.child)
}

func (c *nodeMapuintbyte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintbyte) find(key uint) (crit uint, child, parent *nodeMapuintbyte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintByte) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintByte) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintByte) SetP(key uint, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintByte) Set(key uint, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintByte) GetP(key uint) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintByte) Get(key uint) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintByte) Length() int {
	return t.length
}

// func (c *nodeMapuintbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUintByte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintByte struct {
	t       *MapUintByte
	nodes   []*nodeMapuintbyte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint  // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintByte.
func (t *MapUintByte) Iterator() *IterUintByte {
	var i IterUintByte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintByte) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintByte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintbyte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintByte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintByte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintByte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintComplex128 implements an associative array of complex128 indexed by uint.
type MapUintComplex128 struct {
	length int
	root   nodeMapuintcomplex128
}

// NewMapUintComplex128 returns a new map with keys of type uint and values of type complex128
func NewMapUintComplex128() *MapUintComplex128 {
	var r MapUintComplex128
	return &r
}

type nodeMapuintcomplex128 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapuintcomplex128) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex128) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintcomplex128) children() *[2]nodeMapuintcomplex128 {
	return (*[2]nodeMapuintcomplex128)(c.child)
}

func (c *nodeMapuintcomplex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintcomplex128) find(key uint) (crit uint, child, parent *nodeMapuintcomplex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintComplex128) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintComplex128) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintComplex128) SetP(key uint, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintComplex128) Set(key uint, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintComplex128) GetP(key uint) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintComplex128) Get(key uint) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex128) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUintComplex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintComplex128 struct {
	t       *MapUintComplex128
	nodes   []*nodeMapuintcomplex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint        // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintComplex128.
func (t *MapUintComplex128) Iterator() *IterUintComplex128 {
	var i IterUintComplex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintComplex128) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintComplex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintcomplex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintComplex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintComplex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintComplex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintComplex64 implements an associative array of complex64 indexed by uint.
type MapUintComplex64 struct {
	length int
	root   nodeMapuintcomplex64
}

// NewMapUintComplex64 returns a new map with keys of type uint and values of type complex64
func NewMapUintComplex64() *MapUintComplex64 {
	var r MapUintComplex64
	return &r
}

type nodeMapuintcomplex64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapuintcomplex64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintcomplex64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintcomplex64) children() *[2]nodeMapuintcomplex64 {
	return (*[2]nodeMapuintcomplex64)(c.child)
}

func (c *nodeMapuintcomplex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintcomplex64) find(key uint) (crit uint, child, parent *nodeMapuintcomplex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintComplex64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintComplex64) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintComplex64) SetP(key uint, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintComplex64) Set(key uint, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintComplex64) GetP(key uint) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintComplex64) Get(key uint) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintComplex64) Length() int {
	return t.length
}

// func (c *nodeMapuintcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUintComplex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintComplex64 struct {
	t       *MapUintComplex64
	nodes   []*nodeMapuintcomplex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint       // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintComplex64.
func (t *MapUintComplex64) Iterator() *IterUintComplex64 {
	var i IterUintComplex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintComplex64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintComplex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintcomplex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintComplex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintComplex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintComplex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintError implements an associative array of error indexed by uint.
type MapUintError struct {
	length int
	root   nodeMapuinterror
}

// NewMapUintError returns a new map with keys of type uint and values of type error
func NewMapUintError() *MapUintError {
	var r MapUintError
	return &r
}

type nodeMapuinterror struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuinterror or error)
}

// Return walking direction
func (c nodeMapuinterror) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuinterror) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuinterror) children() *[2]nodeMapuinterror {
	return (*[2]nodeMapuinterror)(c.child)
}

func (c *nodeMapuinterror) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuinterror) find(key uint) (crit uint, child, parent *nodeMapuinterror) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintError) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintError) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintError) SetP(key uint, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuinterror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintError) Set(key uint, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintError) GetP(key uint) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintError) Get(key uint) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintError) Length() int {
	return t.length
}

// func (c *nodeMapuinterror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuinterror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUintError The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintError struct {
	t       *MapUintError
	nodes   []*nodeMapuinterror
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint   // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintError.
func (t *MapUintError) Iterator() *IterUintError {
	var i IterUintError
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintError) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintError) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuinterror, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintError) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintError) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintError) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintFloat32 implements an associative array of float32 indexed by uint.
type MapUintFloat32 struct {
	length int
	root   nodeMapuintfloat32
}

// NewMapUintFloat32 returns a new map with keys of type uint and values of type float32
func NewMapUintFloat32() *MapUintFloat32 {
	var r MapUintFloat32
	return &r
}

type nodeMapuintfloat32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat32 or float32)
}

// Return walking direction
func (c nodeMapuintfloat32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintfloat32) children() *[2]nodeMapuintfloat32 {
	return (*[2]nodeMapuintfloat32)(c.child)
}

func (c *nodeMapuintfloat32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintfloat32) find(key uint) (crit uint, child, parent *nodeMapuintfloat32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintFloat32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintFloat32) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintFloat32) SetP(key uint, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintFloat32) Set(key uint, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintFloat32) GetP(key uint) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintFloat32) Get(key uint) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat32) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUintFloat32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintFloat32 struct {
	t       *MapUintFloat32
	nodes   []*nodeMapuintfloat32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint     // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintFloat32.
func (t *MapUintFloat32) Iterator() *IterUintFloat32 {
	var i IterUintFloat32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintFloat32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintFloat32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintfloat32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintFloat32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintFloat32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintFloat32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintFloat64 implements an associative array of float64 indexed by uint.
type MapUintFloat64 struct {
	length int
	root   nodeMapuintfloat64
}

// NewMapUintFloat64 returns a new map with keys of type uint and values of type float64
func NewMapUintFloat64() *MapUintFloat64 {
	var r MapUintFloat64
	return &r
}

type nodeMapuintfloat64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintfloat64 or float64)
}

// Return walking direction
func (c nodeMapuintfloat64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintfloat64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintfloat64) children() *[2]nodeMapuintfloat64 {
	return (*[2]nodeMapuintfloat64)(c.child)
}

func (c *nodeMapuintfloat64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintfloat64) find(key uint) (crit uint, child, parent *nodeMapuintfloat64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintFloat64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintFloat64) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintFloat64) SetP(key uint, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintFloat64) Set(key uint, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintFloat64) GetP(key uint) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintFloat64) Get(key uint) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintFloat64) Length() int {
	return t.length
}

// func (c *nodeMapuintfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUintFloat64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintFloat64 struct {
	t       *MapUintFloat64
	nodes   []*nodeMapuintfloat64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint     // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintFloat64.
func (t *MapUintFloat64) Iterator() *IterUintFloat64 {
	var i IterUintFloat64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintFloat64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintFloat64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintfloat64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintFloat64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintFloat64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintFloat64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintInt implements an associative array of int indexed by uint.
type MapUintInt struct {
	length int
	root   nodeMapuintint
}

// NewMapUintInt returns a new map with keys of type uint and values of type int
func NewMapUintInt() *MapUintInt {
	var r MapUintInt
	return &r
}

type nodeMapuintint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint or int)
}

// Return walking direction
func (c nodeMapuintint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint) children() *[2]nodeMapuintint {
	return (*[2]nodeMapuintint)(c.child)
}

func (c *nodeMapuintint) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintint) find(key uint) (crit uint, child, parent *nodeMapuintint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintInt) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintInt) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt) SetP(key uint, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt) Set(key uint, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt) GetP(key uint) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt) Get(key uint) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt) Length() int {
	return t.length
}

// func (c *nodeMapuintint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUintInt The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt struct {
	t       *MapUintInt
	nodes   []*nodeMapuintint
	lastDir int
	Found   bool // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint // Key found by last call to Next, Prev.
	Value   *int // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt.
func (t *MapUintInt) Iterator() *IterUintInt {
	var i IterUintInt
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintInt) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintInt) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintInt) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintInt) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintInt) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintInt16 implements an associative array of int16 indexed by uint.
type MapUintInt16 struct {
	length int
	root   nodeMapuintint16
}

// NewMapUintInt16 returns a new map with keys of type uint and values of type int16
func NewMapUintInt16() *MapUintInt16 {
	var r MapUintInt16
	return &r
}

type nodeMapuintint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint16 or int16)
}

// Return walking direction
func (c nodeMapuintint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint16) children() *[2]nodeMapuintint16 {
	return (*[2]nodeMapuintint16)(c.child)
}

func (c *nodeMapuintint16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintint16) find(key uint) (crit uint, child, parent *nodeMapuintint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintInt16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintInt16) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt16) SetP(key uint, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt16) Set(key uint, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt16) GetP(key uint) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt16) Get(key uint) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt16) Length() int {
	return t.length
}

// func (c *nodeMapuintint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUintInt16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt16 struct {
	t       *MapUintInt16
	nodes   []*nodeMapuintint16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint   // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt16.
func (t *MapUintInt16) Iterator() *IterUintInt16 {
	var i IterUintInt16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintInt16) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintInt16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintInt16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintInt16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintInt16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintInt32 implements an associative array of int32 indexed by uint.
type MapUintInt32 struct {
	length int
	root   nodeMapuintint32
}

// NewMapUintInt32 returns a new map with keys of type uint and values of type int32
func NewMapUintInt32() *MapUintInt32 {
	var r MapUintInt32
	return &r
}

type nodeMapuintint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint32 or int32)
}

// Return walking direction
func (c nodeMapuintint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint32) children() *[2]nodeMapuintint32 {
	return (*[2]nodeMapuintint32)(c.child)
}

func (c *nodeMapuintint32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintint32) find(key uint) (crit uint, child, parent *nodeMapuintint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintInt32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintInt32) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt32) SetP(key uint, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt32) Set(key uint, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt32) GetP(key uint) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt32) Get(key uint) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt32) Length() int {
	return t.length
}

// func (c *nodeMapuintint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUintInt32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt32 struct {
	t       *MapUintInt32
	nodes   []*nodeMapuintint32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint   // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt32.
func (t *MapUintInt32) Iterator() *IterUintInt32 {
	var i IterUintInt32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintInt32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintInt32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintInt32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintInt32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintInt32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintInt64 implements an associative array of int64 indexed by uint.
type MapUintInt64 struct {
	length int
	root   nodeMapuintint64
}

// NewMapUintInt64 returns a new map with keys of type uint and values of type int64
func NewMapUintInt64() *MapUintInt64 {
	var r MapUintInt64
	return &r
}

type nodeMapuintint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint64 or int64)
}

// Return walking direction
func (c nodeMapuintint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint64) children() *[2]nodeMapuintint64 {
	return (*[2]nodeMapuintint64)(c.child)
}

func (c *nodeMapuintint64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintint64) find(key uint) (crit uint, child, parent *nodeMapuintint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintInt64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintInt64) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt64) SetP(key uint, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt64) Set(key uint, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt64) GetP(key uint) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt64) Get(key uint) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt64) Length() int {
	return t.length
}

// func (c *nodeMapuintint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUintInt64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt64 struct {
	t       *MapUintInt64
	nodes   []*nodeMapuintint64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint   // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt64.
func (t *MapUintInt64) Iterator() *IterUintInt64 {
	var i IterUintInt64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintInt64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintInt64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintInt64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintInt64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintInt64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintInt8 implements an associative array of int8 indexed by uint.
type MapUintInt8 struct {
	length int
	root   nodeMapuintint8
}

// NewMapUintInt8 returns a new map with keys of type uint and values of type int8
func NewMapUintInt8() *MapUintInt8 {
	var r MapUintInt8
	return &r
}

type nodeMapuintint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintint8 or int8)
}

// Return walking direction
func (c nodeMapuintint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintint8) children() *[2]nodeMapuintint8 {
	return (*[2]nodeMapuintint8)(c.child)
}

func (c *nodeMapuintint8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintint8) find(key uint) (crit uint, child, parent *nodeMapuintint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintInt8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintInt8) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintInt8) SetP(key uint, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintInt8) Set(key uint, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintInt8) GetP(key uint) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintInt8) Get(key uint) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintInt8) Length() int {
	return t.length
}

// func (c *nodeMapuintint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUintInt8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintInt8 struct {
	t       *MapUintInt8
	nodes   []*nodeMapuintint8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint  // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintInt8.
func (t *MapUintInt8) Iterator() *IterUintInt8 {
	var i IterUintInt8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintInt8) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintInt8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintInt8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintInt8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintInt8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintRune implements an associative array of rune indexed by uint.
type MapUintRune struct {
	length int
	root   nodeMapuintrune
}

// NewMapUintRune returns a new map with keys of type uint and values of type rune
func NewMapUintRune() *MapUintRune {
	var r MapUintRune
	return &r
}

type nodeMapuintrune struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintrune or rune)
}

// Return walking direction
func (c nodeMapuintrune) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintrune) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintrune) children() *[2]nodeMapuintrune {
	return (*[2]nodeMapuintrune)(c.child)
}

func (c *nodeMapuintrune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintrune) find(key uint) (crit uint, child, parent *nodeMapuintrune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintRune) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintRune) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintRune) SetP(key uint, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintRune) Set(key uint, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintRune) GetP(key uint) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintRune) Get(key uint) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintRune) Length() int {
	return t.length
}

// func (c *nodeMapuintrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUintRune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintRune struct {
	t       *MapUintRune
	nodes   []*nodeMapuintrune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint  // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintRune.
func (t *MapUintRune) Iterator() *IterUintRune {
	var i IterUintRune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintRune) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintRune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintrune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintRune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintRune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintRune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintString implements an associative array of string indexed by uint.
type MapUintString struct {
	length int
	root   nodeMapuintstring
}

// NewMapUintString returns a new map with keys of type uint and values of type string
func NewMapUintString() *MapUintString {
	var r MapUintString
	return &r
}

type nodeMapuintstring struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintstring or string)
}

// Return walking direction
func (c nodeMapuintstring) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintstring) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintstring) children() *[2]nodeMapuintstring {
	return (*[2]nodeMapuintstring)(c.child)
}

func (c *nodeMapuintstring) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintstring) find(key uint) (crit uint, child, parent *nodeMapuintstring) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintString) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintString) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintString) SetP(key uint, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintString) Set(key uint, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintString) GetP(key uint) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintString) Get(key uint) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintString) Length() int {
	return t.length
}

// func (c *nodeMapuintstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUintString The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintString struct {
	t       *MapUintString
	nodes   []*nodeMapuintstring
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint    // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintString.
func (t *MapUintString) Iterator() *IterUintString {
	var i IterUintString
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintString) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintString) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintstring, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintString) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintString) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintString) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUint implements an associative array of uint indexed by uint.
type MapUintUint struct {
	length int
	root   nodeMapuintuint
}

// NewMapUintUint returns a new map with keys of type uint and values of type uint
func NewMapUintUint() *MapUintUint {
	var r MapUintUint
	return &r
}

type nodeMapuintuint struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint or uint)
}

// Return walking direction
func (c nodeMapuintuint) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint) children() *[2]nodeMapuintuint {
	return (*[2]nodeMapuintuint)(c.child)
}

func (c *nodeMapuintuint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuint) find(key uint) (crit uint, child, parent *nodeMapuintuint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUint) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUint) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint) SetP(key uint, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint) Set(key uint, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint) GetP(key uint) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint) Get(key uint) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint) Length() int {
	return t.length
}

// func (c *nodeMapuintuint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUintUint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint struct {
	t       *MapUintUint
	nodes   []*nodeMapuintuint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint  // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint.
func (t *MapUintUint) Iterator() *IterUintUint {
	var i IterUintUint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUint) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUint16 implements an associative array of uint16 indexed by uint.
type MapUintUint16 struct {
	length int
	root   nodeMapuintuint16
}

// NewMapUintUint16 returns a new map with keys of type uint and values of type uint16
func NewMapUintUint16() *MapUintUint16 {
	var r MapUintUint16
	return &r
}

type nodeMapuintuint16 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint16 or uint16)
}

// Return walking direction
func (c nodeMapuintuint16) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint16) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint16) children() *[2]nodeMapuintuint16 {
	return (*[2]nodeMapuintuint16)(c.child)
}

func (c *nodeMapuintuint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuint16) find(key uint) (crit uint, child, parent *nodeMapuintuint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUint16) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUint16) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint16) SetP(key uint, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint16) Set(key uint, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint16) GetP(key uint) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint16) Get(key uint) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint16) Length() int {
	return t.length
}

// func (c *nodeMapuintuint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUintUint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint16 struct {
	t       *MapUintUint16
	nodes   []*nodeMapuintuint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint    // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint16.
func (t *MapUintUint16) Iterator() *IterUintUint16 {
	var i IterUintUint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUint16) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUint32 implements an associative array of uint32 indexed by uint.
type MapUintUint32 struct {
	length int
	root   nodeMapuintuint32
}

// NewMapUintUint32 returns a new map with keys of type uint and values of type uint32
func NewMapUintUint32() *MapUintUint32 {
	var r MapUintUint32
	return &r
}

type nodeMapuintuint32 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint32 or uint32)
}

// Return walking direction
func (c nodeMapuintuint32) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint32) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint32) children() *[2]nodeMapuintuint32 {
	return (*[2]nodeMapuintuint32)(c.child)
}

func (c *nodeMapuintuint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuint32) find(key uint) (crit uint, child, parent *nodeMapuintuint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUint32) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUint32) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint32) SetP(key uint, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint32) Set(key uint, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint32) GetP(key uint) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint32) Get(key uint) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint32) Length() int {
	return t.length
}

// func (c *nodeMapuintuint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUintUint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint32 struct {
	t       *MapUintUint32
	nodes   []*nodeMapuintuint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint    // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint32.
func (t *MapUintUint32) Iterator() *IterUintUint32 {
	var i IterUintUint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUint32) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUint64 implements an associative array of uint64 indexed by uint.
type MapUintUint64 struct {
	length int
	root   nodeMapuintuint64
}

// NewMapUintUint64 returns a new map with keys of type uint and values of type uint64
func NewMapUintUint64() *MapUintUint64 {
	var r MapUintUint64
	return &r
}

type nodeMapuintuint64 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint64 or uint64)
}

// Return walking direction
func (c nodeMapuintuint64) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint64) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint64) children() *[2]nodeMapuintuint64 {
	return (*[2]nodeMapuintuint64)(c.child)
}

func (c *nodeMapuintuint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuint64) find(key uint) (crit uint, child, parent *nodeMapuintuint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUint64) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUint64) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint64) SetP(key uint, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint64) Set(key uint, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint64) GetP(key uint) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint64) Get(key uint) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint64) Length() int {
	return t.length
}

// func (c *nodeMapuintuint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUintUint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint64 struct {
	t       *MapUintUint64
	nodes   []*nodeMapuintuint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint    // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint64.
func (t *MapUintUint64) Iterator() *IterUintUint64 {
	var i IterUintUint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUint64) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUint8 implements an associative array of uint8 indexed by uint.
type MapUintUint8 struct {
	length int
	root   nodeMapuintuint8
}

// NewMapUintUint8 returns a new map with keys of type uint and values of type uint8
func NewMapUintUint8() *MapUintUint8 {
	var r MapUintUint8
	return &r
}

type nodeMapuintuint8 struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuint8 or uint8)
}

// Return walking direction
func (c nodeMapuintuint8) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuint8) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuint8) children() *[2]nodeMapuintuint8 {
	return (*[2]nodeMapuintuint8)(c.child)
}

func (c *nodeMapuintuint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuint8) find(key uint) (crit uint, child, parent *nodeMapuintuint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUint8) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUint8) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUint8) SetP(key uint, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUint8) Set(key uint, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUint8) GetP(key uint) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUint8) Get(key uint) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUint8) Length() int {
	return t.length
}

// func (c *nodeMapuintuint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUintUint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUint8 struct {
	t       *MapUintUint8
	nodes   []*nodeMapuintuint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint   // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUint8.
func (t *MapUintUint8) Iterator() *IterUintUint8 {
	var i IterUintUint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUint8) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintUintptr implements an associative array of uintptr indexed by uint.
type MapUintUintptr struct {
	length int
	root   nodeMapuintuintptr
}

// NewMapUintUintptr returns a new map with keys of type uint and values of type uintptr
func NewMapUintUintptr() *MapUintUintptr {
	var r MapUintUintptr
	return &r
}

type nodeMapuintuintptr struct {
	key   uint           // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintuintptr or uintptr)
}

// Return walking direction
func (c nodeMapuintuintptr) dir(key uint) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintuintptr) findCrit(key uint) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintuintptr) children() *[2]nodeMapuintuintptr {
	return (*[2]nodeMapuintuintptr)(c.child)
}

func (c *nodeMapuintuintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintuintptr) find(key uint) (crit uint, child, parent *nodeMapuintuintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintUintptr) transformKey(key uint) uint {
	var mask uint = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintUintptr) Rem(key uint) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintUintptr) SetP(key uint, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintuintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintUintptr) Set(key uint, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintUintptr) GetP(key uint) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintUintptr) Get(key uint) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintUintptr) Length() int {
	return t.length
}

// func (c *nodeMapuintuintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintuintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUintUintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintUintptr struct {
	t       *MapUintUintptr
	nodes   []*nodeMapuintuintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint     // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintUintptr.
func (t *MapUintUintptr) Iterator() *IterUintUintptr {
	var i IterUintUintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintUintptr) Seek(key uint) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintUintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintuintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintUintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintUintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintUintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrBool implements an associative array of bool indexed by uintptr.
type MapUintptrBool struct {
	length int
	root   nodeMapuintptrbool
}

// NewMapUintptrBool returns a new map with keys of type uintptr and values of type bool
func NewMapUintptrBool() *MapUintptrBool {
	var r MapUintptrBool
	return &r
}

type nodeMapuintptrbool struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrbool or bool)
}

// Return walking direction
func (c nodeMapuintptrbool) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrbool) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrbool) children() *[2]nodeMapuintptrbool {
	return (*[2]nodeMapuintptrbool)(c.child)
}

func (c *nodeMapuintptrbool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrbool) find(key uintptr) (crit uint, child, parent *nodeMapuintptrbool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrBool) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrBool) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrBool) SetP(key uintptr, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrbool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrBool) Set(key uintptr, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrBool) GetP(key uintptr) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrBool) Get(key uintptr) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrBool) Length() int {
	return t.length
}

// func (c *nodeMapuintptrbool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrbool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUintptrBool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrBool struct {
	t       *MapUintptrBool
	nodes   []*nodeMapuintptrbool
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *bool   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrBool.
func (t *MapUintptrBool) Iterator() *IterUintptrBool {
	var i IterUintptrBool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrBool) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrBool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrbool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrBool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrBool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrBool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrByte implements an associative array of byte indexed by uintptr.
type MapUintptrByte struct {
	length int
	root   nodeMapuintptrbyte
}

// NewMapUintptrByte returns a new map with keys of type uintptr and values of type byte
func NewMapUintptrByte() *MapUintptrByte {
	var r MapUintptrByte
	return &r
}

type nodeMapuintptrbyte struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrbyte or byte)
}

// Return walking direction
func (c nodeMapuintptrbyte) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrbyte) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrbyte) children() *[2]nodeMapuintptrbyte {
	return (*[2]nodeMapuintptrbyte)(c.child)
}

func (c *nodeMapuintptrbyte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrbyte) find(key uintptr) (crit uint, child, parent *nodeMapuintptrbyte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrByte) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrByte) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrByte) SetP(key uintptr, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrbyte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrByte) Set(key uintptr, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrByte) GetP(key uintptr) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrByte) Get(key uintptr) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrByte) Length() int {
	return t.length
}

// func (c *nodeMapuintptrbyte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrbyte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUintptrByte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrByte struct {
	t       *MapUintptrByte
	nodes   []*nodeMapuintptrbyte
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *byte   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrByte.
func (t *MapUintptrByte) Iterator() *IterUintptrByte {
	var i IterUintptrByte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrByte) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrByte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrbyte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrByte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrByte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrByte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrComplex128 implements an associative array of complex128 indexed by uintptr.
type MapUintptrComplex128 struct {
	length int
	root   nodeMapuintptrcomplex128
}

// NewMapUintptrComplex128 returns a new map with keys of type uintptr and values of type complex128
func NewMapUintptrComplex128() *MapUintptrComplex128 {
	var r MapUintptrComplex128
	return &r
}

type nodeMapuintptrcomplex128 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrcomplex128 or complex128)
}

// Return walking direction
func (c nodeMapuintptrcomplex128) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrcomplex128) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrcomplex128) children() *[2]nodeMapuintptrcomplex128 {
	return (*[2]nodeMapuintptrcomplex128)(c.child)
}

func (c *nodeMapuintptrcomplex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrcomplex128) find(key uintptr) (crit uint, child, parent *nodeMapuintptrcomplex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrComplex128) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrComplex128) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrComplex128) SetP(key uintptr, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrcomplex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrComplex128) Set(key uintptr, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrComplex128) GetP(key uintptr) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrComplex128) Get(key uintptr) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrComplex128) Length() int {
	return t.length
}

// func (c *nodeMapuintptrcomplex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrcomplex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUintptrComplex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrComplex128 struct {
	t       *MapUintptrComplex128
	nodes   []*nodeMapuintptrcomplex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr     // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrComplex128.
func (t *MapUintptrComplex128) Iterator() *IterUintptrComplex128 {
	var i IterUintptrComplex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrComplex128) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrComplex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrcomplex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrComplex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrComplex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrComplex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrComplex64 implements an associative array of complex64 indexed by uintptr.
type MapUintptrComplex64 struct {
	length int
	root   nodeMapuintptrcomplex64
}

// NewMapUintptrComplex64 returns a new map with keys of type uintptr and values of type complex64
func NewMapUintptrComplex64() *MapUintptrComplex64 {
	var r MapUintptrComplex64
	return &r
}

type nodeMapuintptrcomplex64 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrcomplex64 or complex64)
}

// Return walking direction
func (c nodeMapuintptrcomplex64) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrcomplex64) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrcomplex64) children() *[2]nodeMapuintptrcomplex64 {
	return (*[2]nodeMapuintptrcomplex64)(c.child)
}

func (c *nodeMapuintptrcomplex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrcomplex64) find(key uintptr) (crit uint, child, parent *nodeMapuintptrcomplex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrComplex64) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrComplex64) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrComplex64) SetP(key uintptr, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrcomplex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrComplex64) Set(key uintptr, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrComplex64) GetP(key uintptr) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrComplex64) Get(key uintptr) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrComplex64) Length() int {
	return t.length
}

// func (c *nodeMapuintptrcomplex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrcomplex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUintptrComplex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrComplex64 struct {
	t       *MapUintptrComplex64
	nodes   []*nodeMapuintptrcomplex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr    // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrComplex64.
func (t *MapUintptrComplex64) Iterator() *IterUintptrComplex64 {
	var i IterUintptrComplex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrComplex64) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrComplex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrcomplex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrComplex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrComplex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrComplex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrError implements an associative array of error indexed by uintptr.
type MapUintptrError struct {
	length int
	root   nodeMapuintptrerror
}

// NewMapUintptrError returns a new map with keys of type uintptr and values of type error
func NewMapUintptrError() *MapUintptrError {
	var r MapUintptrError
	return &r
}

type nodeMapuintptrerror struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrerror or error)
}

// Return walking direction
func (c nodeMapuintptrerror) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrerror) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrerror) children() *[2]nodeMapuintptrerror {
	return (*[2]nodeMapuintptrerror)(c.child)
}

func (c *nodeMapuintptrerror) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrerror) find(key uintptr) (crit uint, child, parent *nodeMapuintptrerror) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrError) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrError) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrError) SetP(key uintptr, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrerror{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrError) Set(key uintptr, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrError) GetP(key uintptr) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrError) Get(key uintptr) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrError) Length() int {
	return t.length
}

// func (c *nodeMapuintptrerror) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrerror)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUintptrError The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrError struct {
	t       *MapUintptrError
	nodes   []*nodeMapuintptrerror
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *error  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrError.
func (t *MapUintptrError) Iterator() *IterUintptrError {
	var i IterUintptrError
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrError) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrError) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrerror, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrError) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrError) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrError) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrFloat32 implements an associative array of float32 indexed by uintptr.
type MapUintptrFloat32 struct {
	length int
	root   nodeMapuintptrfloat32
}

// NewMapUintptrFloat32 returns a new map with keys of type uintptr and values of type float32
func NewMapUintptrFloat32() *MapUintptrFloat32 {
	var r MapUintptrFloat32
	return &r
}

type nodeMapuintptrfloat32 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrfloat32 or float32)
}

// Return walking direction
func (c nodeMapuintptrfloat32) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrfloat32) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrfloat32) children() *[2]nodeMapuintptrfloat32 {
	return (*[2]nodeMapuintptrfloat32)(c.child)
}

func (c *nodeMapuintptrfloat32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrfloat32) find(key uintptr) (crit uint, child, parent *nodeMapuintptrfloat32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrFloat32) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrFloat32) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrFloat32) SetP(key uintptr, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrfloat32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrFloat32) Set(key uintptr, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrFloat32) GetP(key uintptr) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrFloat32) Get(key uintptr) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrFloat32) Length() int {
	return t.length
}

// func (c *nodeMapuintptrfloat32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrfloat32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUintptrFloat32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrFloat32 struct {
	t       *MapUintptrFloat32
	nodes   []*nodeMapuintptrfloat32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr  // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrFloat32.
func (t *MapUintptrFloat32) Iterator() *IterUintptrFloat32 {
	var i IterUintptrFloat32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrFloat32) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrFloat32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrfloat32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrFloat32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrFloat32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrFloat32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrFloat64 implements an associative array of float64 indexed by uintptr.
type MapUintptrFloat64 struct {
	length int
	root   nodeMapuintptrfloat64
}

// NewMapUintptrFloat64 returns a new map with keys of type uintptr and values of type float64
func NewMapUintptrFloat64() *MapUintptrFloat64 {
	var r MapUintptrFloat64
	return &r
}

type nodeMapuintptrfloat64 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrfloat64 or float64)
}

// Return walking direction
func (c nodeMapuintptrfloat64) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrfloat64) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrfloat64) children() *[2]nodeMapuintptrfloat64 {
	return (*[2]nodeMapuintptrfloat64)(c.child)
}

func (c *nodeMapuintptrfloat64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrfloat64) find(key uintptr) (crit uint, child, parent *nodeMapuintptrfloat64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrFloat64) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrFloat64) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrFloat64) SetP(key uintptr, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrfloat64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrFloat64) Set(key uintptr, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrFloat64) GetP(key uintptr) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrFloat64) Get(key uintptr) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrFloat64) Length() int {
	return t.length
}

// func (c *nodeMapuintptrfloat64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrfloat64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUintptrFloat64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrFloat64 struct {
	t       *MapUintptrFloat64
	nodes   []*nodeMapuintptrfloat64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr  // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrFloat64.
func (t *MapUintptrFloat64) Iterator() *IterUintptrFloat64 {
	var i IterUintptrFloat64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrFloat64) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrFloat64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrfloat64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrFloat64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrFloat64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrFloat64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrInt implements an associative array of int indexed by uintptr.
type MapUintptrInt struct {
	length int
	root   nodeMapuintptrint
}

// NewMapUintptrInt returns a new map with keys of type uintptr and values of type int
func NewMapUintptrInt() *MapUintptrInt {
	var r MapUintptrInt
	return &r
}

type nodeMapuintptrint struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrint or int)
}

// Return walking direction
func (c nodeMapuintptrint) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrint) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrint) children() *[2]nodeMapuintptrint {
	return (*[2]nodeMapuintptrint)(c.child)
}

func (c *nodeMapuintptrint) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrint) find(key uintptr) (crit uint, child, parent *nodeMapuintptrint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrInt) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrInt) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrInt) SetP(key uintptr, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrInt) Set(key uintptr, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrInt) GetP(key uintptr) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrInt) Get(key uintptr) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrInt) Length() int {
	return t.length
}

// func (c *nodeMapuintptrint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUintptrInt The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrInt struct {
	t       *MapUintptrInt
	nodes   []*nodeMapuintptrint
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *int    // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrInt.
func (t *MapUintptrInt) Iterator() *IterUintptrInt {
	var i IterUintptrInt
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrInt) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrInt) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrInt) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrInt) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrInt) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrInt16 implements an associative array of int16 indexed by uintptr.
type MapUintptrInt16 struct {
	length int
	root   nodeMapuintptrint16
}

// NewMapUintptrInt16 returns a new map with keys of type uintptr and values of type int16
func NewMapUintptrInt16() *MapUintptrInt16 {
	var r MapUintptrInt16
	return &r
}

type nodeMapuintptrint16 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrint16 or int16)
}

// Return walking direction
func (c nodeMapuintptrint16) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrint16) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrint16) children() *[2]nodeMapuintptrint16 {
	return (*[2]nodeMapuintptrint16)(c.child)
}

func (c *nodeMapuintptrint16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrint16) find(key uintptr) (crit uint, child, parent *nodeMapuintptrint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrInt16) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrInt16) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrInt16) SetP(key uintptr, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrInt16) Set(key uintptr, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrInt16) GetP(key uintptr) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrInt16) Get(key uintptr) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrInt16) Length() int {
	return t.length
}

// func (c *nodeMapuintptrint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUintptrInt16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrInt16 struct {
	t       *MapUintptrInt16
	nodes   []*nodeMapuintptrint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *int16  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrInt16.
func (t *MapUintptrInt16) Iterator() *IterUintptrInt16 {
	var i IterUintptrInt16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrInt16) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrInt16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrInt16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrInt16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrInt16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrInt32 implements an associative array of int32 indexed by uintptr.
type MapUintptrInt32 struct {
	length int
	root   nodeMapuintptrint32
}

// NewMapUintptrInt32 returns a new map with keys of type uintptr and values of type int32
func NewMapUintptrInt32() *MapUintptrInt32 {
	var r MapUintptrInt32
	return &r
}

type nodeMapuintptrint32 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrint32 or int32)
}

// Return walking direction
func (c nodeMapuintptrint32) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrint32) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrint32) children() *[2]nodeMapuintptrint32 {
	return (*[2]nodeMapuintptrint32)(c.child)
}

func (c *nodeMapuintptrint32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrint32) find(key uintptr) (crit uint, child, parent *nodeMapuintptrint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrInt32) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrInt32) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrInt32) SetP(key uintptr, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrInt32) Set(key uintptr, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrInt32) GetP(key uintptr) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrInt32) Get(key uintptr) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrInt32) Length() int {
	return t.length
}

// func (c *nodeMapuintptrint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUintptrInt32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrInt32 struct {
	t       *MapUintptrInt32
	nodes   []*nodeMapuintptrint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *int32  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrInt32.
func (t *MapUintptrInt32) Iterator() *IterUintptrInt32 {
	var i IterUintptrInt32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrInt32) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrInt32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrInt32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrInt32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrInt32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrInt64 implements an associative array of int64 indexed by uintptr.
type MapUintptrInt64 struct {
	length int
	root   nodeMapuintptrint64
}

// NewMapUintptrInt64 returns a new map with keys of type uintptr and values of type int64
func NewMapUintptrInt64() *MapUintptrInt64 {
	var r MapUintptrInt64
	return &r
}

type nodeMapuintptrint64 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrint64 or int64)
}

// Return walking direction
func (c nodeMapuintptrint64) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrint64) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrint64) children() *[2]nodeMapuintptrint64 {
	return (*[2]nodeMapuintptrint64)(c.child)
}

func (c *nodeMapuintptrint64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrint64) find(key uintptr) (crit uint, child, parent *nodeMapuintptrint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrInt64) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrInt64) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrInt64) SetP(key uintptr, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrInt64) Set(key uintptr, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrInt64) GetP(key uintptr) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrInt64) Get(key uintptr) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrInt64) Length() int {
	return t.length
}

// func (c *nodeMapuintptrint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUintptrInt64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrInt64 struct {
	t       *MapUintptrInt64
	nodes   []*nodeMapuintptrint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *int64  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrInt64.
func (t *MapUintptrInt64) Iterator() *IterUintptrInt64 {
	var i IterUintptrInt64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrInt64) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrInt64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrInt64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrInt64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrInt64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrInt8 implements an associative array of int8 indexed by uintptr.
type MapUintptrInt8 struct {
	length int
	root   nodeMapuintptrint8
}

// NewMapUintptrInt8 returns a new map with keys of type uintptr and values of type int8
func NewMapUintptrInt8() *MapUintptrInt8 {
	var r MapUintptrInt8
	return &r
}

type nodeMapuintptrint8 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrint8 or int8)
}

// Return walking direction
func (c nodeMapuintptrint8) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrint8) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrint8) children() *[2]nodeMapuintptrint8 {
	return (*[2]nodeMapuintptrint8)(c.child)
}

func (c *nodeMapuintptrint8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrint8) find(key uintptr) (crit uint, child, parent *nodeMapuintptrint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrInt8) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrInt8) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrInt8) SetP(key uintptr, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrInt8) Set(key uintptr, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrInt8) GetP(key uintptr) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrInt8) Get(key uintptr) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrInt8) Length() int {
	return t.length
}

// func (c *nodeMapuintptrint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUintptrInt8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrInt8 struct {
	t       *MapUintptrInt8
	nodes   []*nodeMapuintptrint8
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *int8   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrInt8.
func (t *MapUintptrInt8) Iterator() *IterUintptrInt8 {
	var i IterUintptrInt8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrInt8) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrInt8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrInt8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrInt8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrInt8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrRune implements an associative array of rune indexed by uintptr.
type MapUintptrRune struct {
	length int
	root   nodeMapuintptrrune
}

// NewMapUintptrRune returns a new map with keys of type uintptr and values of type rune
func NewMapUintptrRune() *MapUintptrRune {
	var r MapUintptrRune
	return &r
}

type nodeMapuintptrrune struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrrune or rune)
}

// Return walking direction
func (c nodeMapuintptrrune) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrrune) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrrune) children() *[2]nodeMapuintptrrune {
	return (*[2]nodeMapuintptrrune)(c.child)
}

func (c *nodeMapuintptrrune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrrune) find(key uintptr) (crit uint, child, parent *nodeMapuintptrrune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrRune) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrRune) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrRune) SetP(key uintptr, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrrune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrRune) Set(key uintptr, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrRune) GetP(key uintptr) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrRune) Get(key uintptr) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrRune) Length() int {
	return t.length
}

// func (c *nodeMapuintptrrune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrrune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUintptrRune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrRune struct {
	t       *MapUintptrRune
	nodes   []*nodeMapuintptrrune
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *rune   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrRune.
func (t *MapUintptrRune) Iterator() *IterUintptrRune {
	var i IterUintptrRune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrRune) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrRune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrrune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrRune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrRune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrRune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrString implements an associative array of string indexed by uintptr.
type MapUintptrString struct {
	length int
	root   nodeMapuintptrstring
}

// NewMapUintptrString returns a new map with keys of type uintptr and values of type string
func NewMapUintptrString() *MapUintptrString {
	var r MapUintptrString
	return &r
}

type nodeMapuintptrstring struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptrstring or string)
}

// Return walking direction
func (c nodeMapuintptrstring) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptrstring) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptrstring) children() *[2]nodeMapuintptrstring {
	return (*[2]nodeMapuintptrstring)(c.child)
}

func (c *nodeMapuintptrstring) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptrstring) find(key uintptr) (crit uint, child, parent *nodeMapuintptrstring) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrString) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrString) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrString) SetP(key uintptr, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptrstring{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrString) Set(key uintptr, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrString) GetP(key uintptr) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrString) Get(key uintptr) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrString) Length() int {
	return t.length
}

// func (c *nodeMapuintptrstring) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptrstring)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUintptrString The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrString struct {
	t       *MapUintptrString
	nodes   []*nodeMapuintptrstring
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrString.
func (t *MapUintptrString) Iterator() *IterUintptrString {
	var i IterUintptrString
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrString) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrString) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptrstring, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrString) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrString) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrString) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUint implements an associative array of uint indexed by uintptr.
type MapUintptrUint struct {
	length int
	root   nodeMapuintptruint
}

// NewMapUintptrUint returns a new map with keys of type uintptr and values of type uint
func NewMapUintptrUint() *MapUintptrUint {
	var r MapUintptrUint
	return &r
}

type nodeMapuintptruint struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruint or uint)
}

// Return walking direction
func (c nodeMapuintptruint) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruint) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruint) children() *[2]nodeMapuintptruint {
	return (*[2]nodeMapuintptruint)(c.child)
}

func (c *nodeMapuintptruint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruint) find(key uintptr) (crit uint, child, parent *nodeMapuintptruint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUint) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUint) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUint) SetP(key uintptr, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUint) Set(key uintptr, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUint) GetP(key uintptr) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUint) Get(key uintptr) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUint) Length() int {
	return t.length
}

// func (c *nodeMapuintptruint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUintptrUint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUint struct {
	t       *MapUintptrUint
	nodes   []*nodeMapuintptruint
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *uint   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUint.
func (t *MapUintptrUint) Iterator() *IterUintptrUint {
	var i IterUintptrUint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUint) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUint16 implements an associative array of uint16 indexed by uintptr.
type MapUintptrUint16 struct {
	length int
	root   nodeMapuintptruint16
}

// NewMapUintptrUint16 returns a new map with keys of type uintptr and values of type uint16
func NewMapUintptrUint16() *MapUintptrUint16 {
	var r MapUintptrUint16
	return &r
}

type nodeMapuintptruint16 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruint16 or uint16)
}

// Return walking direction
func (c nodeMapuintptruint16) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruint16) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruint16) children() *[2]nodeMapuintptruint16 {
	return (*[2]nodeMapuintptruint16)(c.child)
}

func (c *nodeMapuintptruint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruint16) find(key uintptr) (crit uint, child, parent *nodeMapuintptruint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUint16) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUint16) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUint16) SetP(key uintptr, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUint16) Set(key uintptr, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUint16) GetP(key uintptr) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUint16) Get(key uintptr) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUint16) Length() int {
	return t.length
}

// func (c *nodeMapuintptruint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUintptrUint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUint16 struct {
	t       *MapUintptrUint16
	nodes   []*nodeMapuintptruint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUint16.
func (t *MapUintptrUint16) Iterator() *IterUintptrUint16 {
	var i IterUintptrUint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUint16) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUint32 implements an associative array of uint32 indexed by uintptr.
type MapUintptrUint32 struct {
	length int
	root   nodeMapuintptruint32
}

// NewMapUintptrUint32 returns a new map with keys of type uintptr and values of type uint32
func NewMapUintptrUint32() *MapUintptrUint32 {
	var r MapUintptrUint32
	return &r
}

type nodeMapuintptruint32 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruint32 or uint32)
}

// Return walking direction
func (c nodeMapuintptruint32) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruint32) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruint32) children() *[2]nodeMapuintptruint32 {
	return (*[2]nodeMapuintptruint32)(c.child)
}

func (c *nodeMapuintptruint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruint32) find(key uintptr) (crit uint, child, parent *nodeMapuintptruint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUint32) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUint32) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUint32) SetP(key uintptr, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUint32) Set(key uintptr, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUint32) GetP(key uintptr) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUint32) Get(key uintptr) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUint32) Length() int {
	return t.length
}

// func (c *nodeMapuintptruint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUintptrUint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUint32 struct {
	t       *MapUintptrUint32
	nodes   []*nodeMapuintptruint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUint32.
func (t *MapUintptrUint32) Iterator() *IterUintptrUint32 {
	var i IterUintptrUint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUint32) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUint64 implements an associative array of uint64 indexed by uintptr.
type MapUintptrUint64 struct {
	length int
	root   nodeMapuintptruint64
}

// NewMapUintptrUint64 returns a new map with keys of type uintptr and values of type uint64
func NewMapUintptrUint64() *MapUintptrUint64 {
	var r MapUintptrUint64
	return &r
}

type nodeMapuintptruint64 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruint64 or uint64)
}

// Return walking direction
func (c nodeMapuintptruint64) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruint64) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruint64) children() *[2]nodeMapuintptruint64 {
	return (*[2]nodeMapuintptruint64)(c.child)
}

func (c *nodeMapuintptruint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruint64) find(key uintptr) (crit uint, child, parent *nodeMapuintptruint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUint64) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUint64) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUint64) SetP(key uintptr, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUint64) Set(key uintptr, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUint64) GetP(key uintptr) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUint64) Get(key uintptr) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUint64) Length() int {
	return t.length
}

// func (c *nodeMapuintptruint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUintptrUint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUint64 struct {
	t       *MapUintptrUint64
	nodes   []*nodeMapuintptruint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUint64.
func (t *MapUintptrUint64) Iterator() *IterUintptrUint64 {
	var i IterUintptrUint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUint64) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUint8 implements an associative array of uint8 indexed by uintptr.
type MapUintptrUint8 struct {
	length int
	root   nodeMapuintptruint8
}

// NewMapUintptrUint8 returns a new map with keys of type uintptr and values of type uint8
func NewMapUintptrUint8() *MapUintptrUint8 {
	var r MapUintptrUint8
	return &r
}

type nodeMapuintptruint8 struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruint8 or uint8)
}

// Return walking direction
func (c nodeMapuintptruint8) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruint8) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruint8) children() *[2]nodeMapuintptruint8 {
	return (*[2]nodeMapuintptruint8)(c.child)
}

func (c *nodeMapuintptruint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruint8) find(key uintptr) (crit uint, child, parent *nodeMapuintptruint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUint8) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUint8) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUint8) SetP(key uintptr, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUint8) Set(key uintptr, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUint8) GetP(key uintptr) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUint8) Get(key uintptr) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUint8) Length() int {
	return t.length
}

// func (c *nodeMapuintptruint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUintptrUint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUint8 struct {
	t       *MapUintptrUint8
	nodes   []*nodeMapuintptruint8
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr // Key found by last call to Next, Prev.
	Value   *uint8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUint8.
func (t *MapUintptrUint8) Iterator() *IterUintptrUint8 {
	var i IterUintptrUint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUint8) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUintptrUintptr implements an associative array of uintptr indexed by uintptr.
type MapUintptrUintptr struct {
	length int
	root   nodeMapuintptruintptr
}

// NewMapUintptrUintptr returns a new map with keys of type uintptr and values of type uintptr
func NewMapUintptrUintptr() *MapUintptrUintptr {
	var r MapUintptrUintptr
	return &r
}

type nodeMapuintptruintptr struct {
	key   uintptr        // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuintptruintptr or uintptr)
}

// Return walking direction
func (c nodeMapuintptruintptr) dir(key uintptr) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuintptruintptr) findCrit(key uintptr) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuintptruintptr) children() *[2]nodeMapuintptruintptr {
	return (*[2]nodeMapuintptruintptr)(c.child)
}

func (c *nodeMapuintptruintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuintptruintptr) find(key uintptr) (crit uint, child, parent *nodeMapuintptruintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUintptrUintptr) transformKey(key uintptr) uintptr {
	var mask uintptr = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUintptrUintptr) Rem(key uintptr) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUintptrUintptr) SetP(key uintptr, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuintptruintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUintptrUintptr) Set(key uintptr, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUintptrUintptr) GetP(key uintptr) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUintptrUintptr) Get(key uintptr) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUintptrUintptr) Length() int {
	return t.length
}

// func (c *nodeMapuintptruintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuintptruintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUintptrUintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUintptrUintptr struct {
	t       *MapUintptrUintptr
	nodes   []*nodeMapuintptruintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uintptr  // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUintptrUintptr.
func (t *MapUintptrUintptr) Iterator() *IterUintptrUintptr {
	var i IterUintptrUintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUintptrUintptr) Seek(key uintptr) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUintptrUintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuintptruintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUintptrUintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUintptrUintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUintptrUintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Bool implements an associative array of bool indexed by uint64.
type MapUint64Bool struct {
	length int
	root   nodeMapuint64bool
}

// NewMapUint64Bool returns a new map with keys of type uint64 and values of type bool
func NewMapUint64Bool() *MapUint64Bool {
	var r MapUint64Bool
	return &r
}

type nodeMapuint64bool struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64bool or bool)
}

// Return walking direction
func (c nodeMapuint64bool) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64bool) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64bool) children() *[2]nodeMapuint64bool {
	return (*[2]nodeMapuint64bool)(c.child)
}

func (c *nodeMapuint64bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64bool) find(key uint64) (crit uint, child, parent *nodeMapuint64bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Bool) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Bool) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Bool) SetP(key uint64, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Bool) Set(key uint64, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Bool) GetP(key uint64) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Bool) Get(key uint64) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint64bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint64Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Bool struct {
	t       *MapUint64Bool
	nodes   []*nodeMapuint64bool
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Bool.
func (t *MapUint64Bool) Iterator() *IterUint64Bool {
	var i IterUint64Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Bool) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Byte implements an associative array of byte indexed by uint64.
type MapUint64Byte struct {
	length int
	root   nodeMapuint64byte
}

// NewMapUint64Byte returns a new map with keys of type uint64 and values of type byte
func NewMapUint64Byte() *MapUint64Byte {
	var r MapUint64Byte
	return &r
}

type nodeMapuint64byte struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64byte or byte)
}

// Return walking direction
func (c nodeMapuint64byte) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64byte) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64byte) children() *[2]nodeMapuint64byte {
	return (*[2]nodeMapuint64byte)(c.child)
}

func (c *nodeMapuint64byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64byte) find(key uint64) (crit uint, child, parent *nodeMapuint64byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Byte) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Byte) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Byte) SetP(key uint64, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Byte) Set(key uint64, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Byte) GetP(key uint64) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Byte) Get(key uint64) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint64byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint64Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Byte struct {
	t       *MapUint64Byte
	nodes   []*nodeMapuint64byte
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Byte.
func (t *MapUint64Byte) Iterator() *IterUint64Byte {
	var i IterUint64Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Byte) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Complex128 implements an associative array of complex128 indexed by uint64.
type MapUint64Complex128 struct {
	length int
	root   nodeMapuint64complex128
}

// NewMapUint64Complex128 returns a new map with keys of type uint64 and values of type complex128
func NewMapUint64Complex128() *MapUint64Complex128 {
	var r MapUint64Complex128
	return &r
}

type nodeMapuint64complex128 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint64complex128) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex128) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64complex128) children() *[2]nodeMapuint64complex128 {
	return (*[2]nodeMapuint64complex128)(c.child)
}

func (c *nodeMapuint64complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64complex128) find(key uint64) (crit uint, child, parent *nodeMapuint64complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Complex128) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Complex128) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Complex128) SetP(key uint64, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Complex128) Set(key uint64, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Complex128) GetP(key uint64) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Complex128) Get(key uint64) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint64Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Complex128 struct {
	t       *MapUint64Complex128
	nodes   []*nodeMapuint64complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64      // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Complex128.
func (t *MapUint64Complex128) Iterator() *IterUint64Complex128 {
	var i IterUint64Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Complex128) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Complex64 implements an associative array of complex64 indexed by uint64.
type MapUint64Complex64 struct {
	length int
	root   nodeMapuint64complex64
}

// NewMapUint64Complex64 returns a new map with keys of type uint64 and values of type complex64
func NewMapUint64Complex64() *MapUint64Complex64 {
	var r MapUint64Complex64
	return &r
}

type nodeMapuint64complex64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint64complex64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64complex64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64complex64) children() *[2]nodeMapuint64complex64 {
	return (*[2]nodeMapuint64complex64)(c.child)
}

func (c *nodeMapuint64complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64complex64) find(key uint64) (crit uint, child, parent *nodeMapuint64complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Complex64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Complex64) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Complex64) SetP(key uint64, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Complex64) Set(key uint64, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Complex64) GetP(key uint64) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Complex64) Get(key uint64) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint64complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint64Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Complex64 struct {
	t       *MapUint64Complex64
	nodes   []*nodeMapuint64complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64     // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Complex64.
func (t *MapUint64Complex64) Iterator() *IterUint64Complex64 {
	var i IterUint64Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Complex64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Error implements an associative array of error indexed by uint64.
type MapUint64Error struct {
	length int
	root   nodeMapuint64error
}

// NewMapUint64Error returns a new map with keys of type uint64 and values of type error
func NewMapUint64Error() *MapUint64Error {
	var r MapUint64Error
	return &r
}

type nodeMapuint64error struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64error or error)
}

// Return walking direction
func (c nodeMapuint64error) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64error) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64error) children() *[2]nodeMapuint64error {
	return (*[2]nodeMapuint64error)(c.child)
}

func (c *nodeMapuint64error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64error) find(key uint64) (crit uint, child, parent *nodeMapuint64error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Error) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Error) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Error) SetP(key uint64, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Error) Set(key uint64, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Error) GetP(key uint64) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Error) Get(key uint64) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Error) Length() int {
	return t.length
}

// func (c *nodeMapuint64error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint64Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Error struct {
	t       *MapUint64Error
	nodes   []*nodeMapuint64error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Error.
func (t *MapUint64Error) Iterator() *IterUint64Error {
	var i IterUint64Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Error) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Float32 implements an associative array of float32 indexed by uint64.
type MapUint64Float32 struct {
	length int
	root   nodeMapuint64float32
}

// NewMapUint64Float32 returns a new map with keys of type uint64 and values of type float32
func NewMapUint64Float32() *MapUint64Float32 {
	var r MapUint64Float32
	return &r
}

type nodeMapuint64float32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float32 or float32)
}

// Return walking direction
func (c nodeMapuint64float32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64float32) children() *[2]nodeMapuint64float32 {
	return (*[2]nodeMapuint64float32)(c.child)
}

func (c *nodeMapuint64float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64float32) find(key uint64) (crit uint, child, parent *nodeMapuint64float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Float32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Float32) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Float32) SetP(key uint64, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Float32) Set(key uint64, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Float32) GetP(key uint64) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Float32) Get(key uint64) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint64float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint64Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Float32 struct {
	t       *MapUint64Float32
	nodes   []*nodeMapuint64float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64   // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Float32.
func (t *MapUint64Float32) Iterator() *IterUint64Float32 {
	var i IterUint64Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Float32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Float64 implements an associative array of float64 indexed by uint64.
type MapUint64Float64 struct {
	length int
	root   nodeMapuint64float64
}

// NewMapUint64Float64 returns a new map with keys of type uint64 and values of type float64
func NewMapUint64Float64() *MapUint64Float64 {
	var r MapUint64Float64
	return &r
}

type nodeMapuint64float64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64float64 or float64)
}

// Return walking direction
func (c nodeMapuint64float64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64float64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64float64) children() *[2]nodeMapuint64float64 {
	return (*[2]nodeMapuint64float64)(c.child)
}

func (c *nodeMapuint64float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64float64) find(key uint64) (crit uint, child, parent *nodeMapuint64float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Float64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Float64) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Float64) SetP(key uint64, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Float64) Set(key uint64, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Float64) GetP(key uint64) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Float64) Get(key uint64) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint64float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint64Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Float64 struct {
	t       *MapUint64Float64
	nodes   []*nodeMapuint64float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64   // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Float64.
func (t *MapUint64Float64) Iterator() *IterUint64Float64 {
	var i IterUint64Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Float64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Int implements an associative array of int indexed by uint64.
type MapUint64Int struct {
	length int
	root   nodeMapuint64int
}

// NewMapUint64Int returns a new map with keys of type uint64 and values of type int
func NewMapUint64Int() *MapUint64Int {
	var r MapUint64Int
	return &r
}

type nodeMapuint64int struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int or int)
}

// Return walking direction
func (c nodeMapuint64int) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int) children() *[2]nodeMapuint64int {
	return (*[2]nodeMapuint64int)(c.child)
}

func (c *nodeMapuint64int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64int) find(key uint64) (crit uint, child, parent *nodeMapuint64int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Int) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Int) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int) SetP(key uint64, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int) Set(key uint64, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int) GetP(key uint64) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int) Get(key uint64) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int) Length() int {
	return t.length
}

// func (c *nodeMapuint64int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint64Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int struct {
	t       *MapUint64Int
	nodes   []*nodeMapuint64int
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int.
func (t *MapUint64Int) Iterator() *IterUint64Int {
	var i IterUint64Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Int) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Int16 implements an associative array of int16 indexed by uint64.
type MapUint64Int16 struct {
	length int
	root   nodeMapuint64int16
}

// NewMapUint64Int16 returns a new map with keys of type uint64 and values of type int16
func NewMapUint64Int16() *MapUint64Int16 {
	var r MapUint64Int16
	return &r
}

type nodeMapuint64int16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int16 or int16)
}

// Return walking direction
func (c nodeMapuint64int16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int16) children() *[2]nodeMapuint64int16 {
	return (*[2]nodeMapuint64int16)(c.child)
}

func (c *nodeMapuint64int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64int16) find(key uint64) (crit uint, child, parent *nodeMapuint64int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Int16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Int16) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int16) SetP(key uint64, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int16) Set(key uint64, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int16) GetP(key uint64) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int16) Get(key uint64) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint64int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint64Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int16 struct {
	t       *MapUint64Int16
	nodes   []*nodeMapuint64int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int16.
func (t *MapUint64Int16) Iterator() *IterUint64Int16 {
	var i IterUint64Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Int16) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Int32 implements an associative array of int32 indexed by uint64.
type MapUint64Int32 struct {
	length int
	root   nodeMapuint64int32
}

// NewMapUint64Int32 returns a new map with keys of type uint64 and values of type int32
func NewMapUint64Int32() *MapUint64Int32 {
	var r MapUint64Int32
	return &r
}

type nodeMapuint64int32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int32 or int32)
}

// Return walking direction
func (c nodeMapuint64int32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int32) children() *[2]nodeMapuint64int32 {
	return (*[2]nodeMapuint64int32)(c.child)
}

func (c *nodeMapuint64int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64int32) find(key uint64) (crit uint, child, parent *nodeMapuint64int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Int32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Int32) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int32) SetP(key uint64, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int32) Set(key uint64, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int32) GetP(key uint64) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int32) Get(key uint64) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint64int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint64Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int32 struct {
	t       *MapUint64Int32
	nodes   []*nodeMapuint64int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int32.
func (t *MapUint64Int32) Iterator() *IterUint64Int32 {
	var i IterUint64Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Int32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Int64 implements an associative array of int64 indexed by uint64.
type MapUint64Int64 struct {
	length int
	root   nodeMapuint64int64
}

// NewMapUint64Int64 returns a new map with keys of type uint64 and values of type int64
func NewMapUint64Int64() *MapUint64Int64 {
	var r MapUint64Int64
	return &r
}

type nodeMapuint64int64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int64 or int64)
}

// Return walking direction
func (c nodeMapuint64int64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int64) children() *[2]nodeMapuint64int64 {
	return (*[2]nodeMapuint64int64)(c.child)
}

func (c *nodeMapuint64int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64int64) find(key uint64) (crit uint, child, parent *nodeMapuint64int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Int64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Int64) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int64) SetP(key uint64, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int64) Set(key uint64, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int64) GetP(key uint64) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int64) Get(key uint64) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint64int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint64Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int64 struct {
	t       *MapUint64Int64
	nodes   []*nodeMapuint64int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int64.
func (t *MapUint64Int64) Iterator() *IterUint64Int64 {
	var i IterUint64Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Int64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Int8 implements an associative array of int8 indexed by uint64.
type MapUint64Int8 struct {
	length int
	root   nodeMapuint64int8
}

// NewMapUint64Int8 returns a new map with keys of type uint64 and values of type int8
func NewMapUint64Int8() *MapUint64Int8 {
	var r MapUint64Int8
	return &r
}

type nodeMapuint64int8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64int8 or int8)
}

// Return walking direction
func (c nodeMapuint64int8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64int8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64int8) children() *[2]nodeMapuint64int8 {
	return (*[2]nodeMapuint64int8)(c.child)
}

func (c *nodeMapuint64int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64int8) find(key uint64) (crit uint, child, parent *nodeMapuint64int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Int8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Int8) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Int8) SetP(key uint64, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Int8) Set(key uint64, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Int8) GetP(key uint64) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Int8) Get(key uint64) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint64int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint64Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Int8 struct {
	t       *MapUint64Int8
	nodes   []*nodeMapuint64int8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Int8.
func (t *MapUint64Int8) Iterator() *IterUint64Int8 {
	var i IterUint64Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Int8) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Rune implements an associative array of rune indexed by uint64.
type MapUint64Rune struct {
	length int
	root   nodeMapuint64rune
}

// NewMapUint64Rune returns a new map with keys of type uint64 and values of type rune
func NewMapUint64Rune() *MapUint64Rune {
	var r MapUint64Rune
	return &r
}

type nodeMapuint64rune struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64rune or rune)
}

// Return walking direction
func (c nodeMapuint64rune) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64rune) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64rune) children() *[2]nodeMapuint64rune {
	return (*[2]nodeMapuint64rune)(c.child)
}

func (c *nodeMapuint64rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64rune) find(key uint64) (crit uint, child, parent *nodeMapuint64rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Rune) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Rune) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Rune) SetP(key uint64, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Rune) Set(key uint64, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Rune) GetP(key uint64) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Rune) Get(key uint64) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint64rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint64Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Rune struct {
	t       *MapUint64Rune
	nodes   []*nodeMapuint64rune
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Rune.
func (t *MapUint64Rune) Iterator() *IterUint64Rune {
	var i IterUint64Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Rune) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64String implements an associative array of string indexed by uint64.
type MapUint64String struct {
	length int
	root   nodeMapuint64string
}

// NewMapUint64String returns a new map with keys of type uint64 and values of type string
func NewMapUint64String() *MapUint64String {
	var r MapUint64String
	return &r
}

type nodeMapuint64string struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64string or string)
}

// Return walking direction
func (c nodeMapuint64string) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64string) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64string) children() *[2]nodeMapuint64string {
	return (*[2]nodeMapuint64string)(c.child)
}

func (c *nodeMapuint64string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64string) find(key uint64) (crit uint, child, parent *nodeMapuint64string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64String) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64String) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64String) SetP(key uint64, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64String) Set(key uint64, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64String) GetP(key uint64) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64String) Get(key uint64) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64String) Length() int {
	return t.length
}

// func (c *nodeMapuint64string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint64String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64String struct {
	t       *MapUint64String
	nodes   []*nodeMapuint64string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64  // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64String.
func (t *MapUint64String) Iterator() *IterUint64String {
	var i IterUint64String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64String) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uint implements an associative array of uint indexed by uint64.
type MapUint64Uint struct {
	length int
	root   nodeMapuint64uint
}

// NewMapUint64Uint returns a new map with keys of type uint64 and values of type uint
func NewMapUint64Uint() *MapUint64Uint {
	var r MapUint64Uint
	return &r
}

type nodeMapuint64uint struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint or uint)
}

// Return walking direction
func (c nodeMapuint64uint) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint) children() *[2]nodeMapuint64uint {
	return (*[2]nodeMapuint64uint)(c.child)
}

func (c *nodeMapuint64uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uint) find(key uint64) (crit uint, child, parent *nodeMapuint64uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uint) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uint) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint) SetP(key uint64, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint) Set(key uint64, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint) GetP(key uint64) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint) Get(key uint64) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint64Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint struct {
	t       *MapUint64Uint
	nodes   []*nodeMapuint64uint
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint.
func (t *MapUint64Uint) Iterator() *IterUint64Uint {
	var i IterUint64Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uint) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uint16 implements an associative array of uint16 indexed by uint64.
type MapUint64Uint16 struct {
	length int
	root   nodeMapuint64uint16
}

// NewMapUint64Uint16 returns a new map with keys of type uint64 and values of type uint16
func NewMapUint64Uint16() *MapUint64Uint16 {
	var r MapUint64Uint16
	return &r
}

type nodeMapuint64uint16 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint64uint16) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint16) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint16) children() *[2]nodeMapuint64uint16 {
	return (*[2]nodeMapuint64uint16)(c.child)
}

func (c *nodeMapuint64uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uint16) find(key uint64) (crit uint, child, parent *nodeMapuint64uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uint16) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uint16) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint16) SetP(key uint64, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint16) Set(key uint64, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint16) GetP(key uint64) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint16) Get(key uint64) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint64Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint16 struct {
	t       *MapUint64Uint16
	nodes   []*nodeMapuint64uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64  // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint16.
func (t *MapUint64Uint16) Iterator() *IterUint64Uint16 {
	var i IterUint64Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uint16) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uint32 implements an associative array of uint32 indexed by uint64.
type MapUint64Uint32 struct {
	length int
	root   nodeMapuint64uint32
}

// NewMapUint64Uint32 returns a new map with keys of type uint64 and values of type uint32
func NewMapUint64Uint32() *MapUint64Uint32 {
	var r MapUint64Uint32
	return &r
}

type nodeMapuint64uint32 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint64uint32) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint32) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint32) children() *[2]nodeMapuint64uint32 {
	return (*[2]nodeMapuint64uint32)(c.child)
}

func (c *nodeMapuint64uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uint32) find(key uint64) (crit uint, child, parent *nodeMapuint64uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uint32) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uint32) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint32) SetP(key uint64, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint32) Set(key uint64, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint32) GetP(key uint64) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint32) Get(key uint64) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint64Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint32 struct {
	t       *MapUint64Uint32
	nodes   []*nodeMapuint64uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64  // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint32.
func (t *MapUint64Uint32) Iterator() *IterUint64Uint32 {
	var i IterUint64Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uint32) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uint64 implements an associative array of uint64 indexed by uint64.
type MapUint64Uint64 struct {
	length int
	root   nodeMapuint64uint64
}

// NewMapUint64Uint64 returns a new map with keys of type uint64 and values of type uint64
func NewMapUint64Uint64() *MapUint64Uint64 {
	var r MapUint64Uint64
	return &r
}

type nodeMapuint64uint64 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint64uint64) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint64) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint64) children() *[2]nodeMapuint64uint64 {
	return (*[2]nodeMapuint64uint64)(c.child)
}

func (c *nodeMapuint64uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uint64) find(key uint64) (crit uint, child, parent *nodeMapuint64uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uint64) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uint64) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint64) SetP(key uint64, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint64) Set(key uint64, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint64) GetP(key uint64) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint64) Get(key uint64) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint64Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint64 struct {
	t       *MapUint64Uint64
	nodes   []*nodeMapuint64uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64  // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint64.
func (t *MapUint64Uint64) Iterator() *IterUint64Uint64 {
	var i IterUint64Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uint64) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uint8 implements an associative array of uint8 indexed by uint64.
type MapUint64Uint8 struct {
	length int
	root   nodeMapuint64uint8
}

// NewMapUint64Uint8 returns a new map with keys of type uint64 and values of type uint8
func NewMapUint64Uint8() *MapUint64Uint8 {
	var r MapUint64Uint8
	return &r
}

type nodeMapuint64uint8 struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint64uint8) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uint8) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uint8) children() *[2]nodeMapuint64uint8 {
	return (*[2]nodeMapuint64uint8)(c.child)
}

func (c *nodeMapuint64uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uint8) find(key uint64) (crit uint, child, parent *nodeMapuint64uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uint8) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uint8) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uint8) SetP(key uint64, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uint8) Set(key uint64, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uint8) GetP(key uint64) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uint8) Get(key uint64) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint64uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint64Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uint8 struct {
	t       *MapUint64Uint8
	nodes   []*nodeMapuint64uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64 // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uint8.
func (t *MapUint64Uint8) Iterator() *IterUint64Uint8 {
	var i IterUint64Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uint8) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint64Uintptr implements an associative array of uintptr indexed by uint64.
type MapUint64Uintptr struct {
	length int
	root   nodeMapuint64uintptr
}

// NewMapUint64Uintptr returns a new map with keys of type uint64 and values of type uintptr
func NewMapUint64Uintptr() *MapUint64Uintptr {
	var r MapUint64Uintptr
	return &r
}

type nodeMapuint64uintptr struct {
	key   uint64         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint64uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint64uintptr) dir(key uint64) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint64uintptr) findCrit(key uint64) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint64uintptr) children() *[2]nodeMapuint64uintptr {
	return (*[2]nodeMapuint64uintptr)(c.child)
}

func (c *nodeMapuint64uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint64uintptr) find(key uint64) (crit uint, child, parent *nodeMapuint64uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint64Uintptr) transformKey(key uint64) uint64 {
	var mask uint64 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint64Uintptr) Rem(key uint64) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint64Uintptr) SetP(key uint64, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint64uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint64Uintptr) Set(key uint64, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint64Uintptr) GetP(key uint64) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint64Uintptr) Get(key uint64) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint64Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint64uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint64uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint64Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint64Uintptr struct {
	t       *MapUint64Uintptr
	nodes   []*nodeMapuint64uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint64   // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint64Uintptr.
func (t *MapUint64Uintptr) Iterator() *IterUint64Uintptr {
	var i IterUint64Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint64Uintptr) Seek(key uint64) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint64Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint64uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint64Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint64Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint64Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Bool implements an associative array of bool indexed by uint32.
type MapUint32Bool struct {
	length int
	root   nodeMapuint32bool
}

// NewMapUint32Bool returns a new map with keys of type uint32 and values of type bool
func NewMapUint32Bool() *MapUint32Bool {
	var r MapUint32Bool
	return &r
}

type nodeMapuint32bool struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32bool or bool)
}

// Return walking direction
func (c nodeMapuint32bool) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32bool) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32bool) children() *[2]nodeMapuint32bool {
	return (*[2]nodeMapuint32bool)(c.child)
}

func (c *nodeMapuint32bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32bool) find(key uint32) (crit uint, child, parent *nodeMapuint32bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Bool) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Bool) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Bool) SetP(key uint32, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Bool) Set(key uint32, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Bool) GetP(key uint32) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Bool) Get(key uint32) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint32bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint32Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Bool struct {
	t       *MapUint32Bool
	nodes   []*nodeMapuint32bool
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Bool.
func (t *MapUint32Bool) Iterator() *IterUint32Bool {
	var i IterUint32Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Bool) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Byte implements an associative array of byte indexed by uint32.
type MapUint32Byte struct {
	length int
	root   nodeMapuint32byte
}

// NewMapUint32Byte returns a new map with keys of type uint32 and values of type byte
func NewMapUint32Byte() *MapUint32Byte {
	var r MapUint32Byte
	return &r
}

type nodeMapuint32byte struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32byte or byte)
}

// Return walking direction
func (c nodeMapuint32byte) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32byte) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32byte) children() *[2]nodeMapuint32byte {
	return (*[2]nodeMapuint32byte)(c.child)
}

func (c *nodeMapuint32byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32byte) find(key uint32) (crit uint, child, parent *nodeMapuint32byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Byte) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Byte) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Byte) SetP(key uint32, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Byte) Set(key uint32, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Byte) GetP(key uint32) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Byte) Get(key uint32) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint32byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint32Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Byte struct {
	t       *MapUint32Byte
	nodes   []*nodeMapuint32byte
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Byte.
func (t *MapUint32Byte) Iterator() *IterUint32Byte {
	var i IterUint32Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Byte) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Complex128 implements an associative array of complex128 indexed by uint32.
type MapUint32Complex128 struct {
	length int
	root   nodeMapuint32complex128
}

// NewMapUint32Complex128 returns a new map with keys of type uint32 and values of type complex128
func NewMapUint32Complex128() *MapUint32Complex128 {
	var r MapUint32Complex128
	return &r
}

type nodeMapuint32complex128 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint32complex128) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex128) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32complex128) children() *[2]nodeMapuint32complex128 {
	return (*[2]nodeMapuint32complex128)(c.child)
}

func (c *nodeMapuint32complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32complex128) find(key uint32) (crit uint, child, parent *nodeMapuint32complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Complex128) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Complex128) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Complex128) SetP(key uint32, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Complex128) Set(key uint32, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Complex128) GetP(key uint32) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Complex128) Get(key uint32) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint32Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Complex128 struct {
	t       *MapUint32Complex128
	nodes   []*nodeMapuint32complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32      // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Complex128.
func (t *MapUint32Complex128) Iterator() *IterUint32Complex128 {
	var i IterUint32Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Complex128) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Complex64 implements an associative array of complex64 indexed by uint32.
type MapUint32Complex64 struct {
	length int
	root   nodeMapuint32complex64
}

// NewMapUint32Complex64 returns a new map with keys of type uint32 and values of type complex64
func NewMapUint32Complex64() *MapUint32Complex64 {
	var r MapUint32Complex64
	return &r
}

type nodeMapuint32complex64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint32complex64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32complex64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32complex64) children() *[2]nodeMapuint32complex64 {
	return (*[2]nodeMapuint32complex64)(c.child)
}

func (c *nodeMapuint32complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32complex64) find(key uint32) (crit uint, child, parent *nodeMapuint32complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Complex64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Complex64) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Complex64) SetP(key uint32, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Complex64) Set(key uint32, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Complex64) GetP(key uint32) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Complex64) Get(key uint32) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint32complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint32Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Complex64 struct {
	t       *MapUint32Complex64
	nodes   []*nodeMapuint32complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32     // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Complex64.
func (t *MapUint32Complex64) Iterator() *IterUint32Complex64 {
	var i IterUint32Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Complex64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Error implements an associative array of error indexed by uint32.
type MapUint32Error struct {
	length int
	root   nodeMapuint32error
}

// NewMapUint32Error returns a new map with keys of type uint32 and values of type error
func NewMapUint32Error() *MapUint32Error {
	var r MapUint32Error
	return &r
}

type nodeMapuint32error struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32error or error)
}

// Return walking direction
func (c nodeMapuint32error) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32error) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32error) children() *[2]nodeMapuint32error {
	return (*[2]nodeMapuint32error)(c.child)
}

func (c *nodeMapuint32error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32error) find(key uint32) (crit uint, child, parent *nodeMapuint32error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Error) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Error) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Error) SetP(key uint32, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Error) Set(key uint32, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Error) GetP(key uint32) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Error) Get(key uint32) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Error) Length() int {
	return t.length
}

// func (c *nodeMapuint32error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint32Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Error struct {
	t       *MapUint32Error
	nodes   []*nodeMapuint32error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Error.
func (t *MapUint32Error) Iterator() *IterUint32Error {
	var i IterUint32Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Error) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Float32 implements an associative array of float32 indexed by uint32.
type MapUint32Float32 struct {
	length int
	root   nodeMapuint32float32
}

// NewMapUint32Float32 returns a new map with keys of type uint32 and values of type float32
func NewMapUint32Float32() *MapUint32Float32 {
	var r MapUint32Float32
	return &r
}

type nodeMapuint32float32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float32 or float32)
}

// Return walking direction
func (c nodeMapuint32float32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32float32) children() *[2]nodeMapuint32float32 {
	return (*[2]nodeMapuint32float32)(c.child)
}

func (c *nodeMapuint32float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32float32) find(key uint32) (crit uint, child, parent *nodeMapuint32float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Float32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Float32) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Float32) SetP(key uint32, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Float32) Set(key uint32, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Float32) GetP(key uint32) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Float32) Get(key uint32) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint32float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint32Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Float32 struct {
	t       *MapUint32Float32
	nodes   []*nodeMapuint32float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32   // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Float32.
func (t *MapUint32Float32) Iterator() *IterUint32Float32 {
	var i IterUint32Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Float32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Float64 implements an associative array of float64 indexed by uint32.
type MapUint32Float64 struct {
	length int
	root   nodeMapuint32float64
}

// NewMapUint32Float64 returns a new map with keys of type uint32 and values of type float64
func NewMapUint32Float64() *MapUint32Float64 {
	var r MapUint32Float64
	return &r
}

type nodeMapuint32float64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32float64 or float64)
}

// Return walking direction
func (c nodeMapuint32float64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32float64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32float64) children() *[2]nodeMapuint32float64 {
	return (*[2]nodeMapuint32float64)(c.child)
}

func (c *nodeMapuint32float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32float64) find(key uint32) (crit uint, child, parent *nodeMapuint32float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Float64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Float64) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Float64) SetP(key uint32, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Float64) Set(key uint32, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Float64) GetP(key uint32) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Float64) Get(key uint32) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint32float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint32Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Float64 struct {
	t       *MapUint32Float64
	nodes   []*nodeMapuint32float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32   // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Float64.
func (t *MapUint32Float64) Iterator() *IterUint32Float64 {
	var i IterUint32Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Float64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Int implements an associative array of int indexed by uint32.
type MapUint32Int struct {
	length int
	root   nodeMapuint32int
}

// NewMapUint32Int returns a new map with keys of type uint32 and values of type int
func NewMapUint32Int() *MapUint32Int {
	var r MapUint32Int
	return &r
}

type nodeMapuint32int struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int or int)
}

// Return walking direction
func (c nodeMapuint32int) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int) children() *[2]nodeMapuint32int {
	return (*[2]nodeMapuint32int)(c.child)
}

func (c *nodeMapuint32int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32int) find(key uint32) (crit uint, child, parent *nodeMapuint32int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Int) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Int) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int) SetP(key uint32, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int) Set(key uint32, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int) GetP(key uint32) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int) Get(key uint32) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int) Length() int {
	return t.length
}

// func (c *nodeMapuint32int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint32Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int struct {
	t       *MapUint32Int
	nodes   []*nodeMapuint32int
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int.
func (t *MapUint32Int) Iterator() *IterUint32Int {
	var i IterUint32Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Int) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Int16 implements an associative array of int16 indexed by uint32.
type MapUint32Int16 struct {
	length int
	root   nodeMapuint32int16
}

// NewMapUint32Int16 returns a new map with keys of type uint32 and values of type int16
func NewMapUint32Int16() *MapUint32Int16 {
	var r MapUint32Int16
	return &r
}

type nodeMapuint32int16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int16 or int16)
}

// Return walking direction
func (c nodeMapuint32int16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int16) children() *[2]nodeMapuint32int16 {
	return (*[2]nodeMapuint32int16)(c.child)
}

func (c *nodeMapuint32int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32int16) find(key uint32) (crit uint, child, parent *nodeMapuint32int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Int16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Int16) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int16) SetP(key uint32, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int16) Set(key uint32, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int16) GetP(key uint32) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int16) Get(key uint32) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint32int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint32Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int16 struct {
	t       *MapUint32Int16
	nodes   []*nodeMapuint32int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int16.
func (t *MapUint32Int16) Iterator() *IterUint32Int16 {
	var i IterUint32Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Int16) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Int32 implements an associative array of int32 indexed by uint32.
type MapUint32Int32 struct {
	length int
	root   nodeMapuint32int32
}

// NewMapUint32Int32 returns a new map with keys of type uint32 and values of type int32
func NewMapUint32Int32() *MapUint32Int32 {
	var r MapUint32Int32
	return &r
}

type nodeMapuint32int32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int32 or int32)
}

// Return walking direction
func (c nodeMapuint32int32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int32) children() *[2]nodeMapuint32int32 {
	return (*[2]nodeMapuint32int32)(c.child)
}

func (c *nodeMapuint32int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32int32) find(key uint32) (crit uint, child, parent *nodeMapuint32int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Int32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Int32) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int32) SetP(key uint32, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int32) Set(key uint32, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int32) GetP(key uint32) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int32) Get(key uint32) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint32int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint32Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int32 struct {
	t       *MapUint32Int32
	nodes   []*nodeMapuint32int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int32.
func (t *MapUint32Int32) Iterator() *IterUint32Int32 {
	var i IterUint32Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Int32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Int64 implements an associative array of int64 indexed by uint32.
type MapUint32Int64 struct {
	length int
	root   nodeMapuint32int64
}

// NewMapUint32Int64 returns a new map with keys of type uint32 and values of type int64
func NewMapUint32Int64() *MapUint32Int64 {
	var r MapUint32Int64
	return &r
}

type nodeMapuint32int64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int64 or int64)
}

// Return walking direction
func (c nodeMapuint32int64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int64) children() *[2]nodeMapuint32int64 {
	return (*[2]nodeMapuint32int64)(c.child)
}

func (c *nodeMapuint32int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32int64) find(key uint32) (crit uint, child, parent *nodeMapuint32int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Int64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Int64) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int64) SetP(key uint32, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int64) Set(key uint32, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int64) GetP(key uint32) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int64) Get(key uint32) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint32int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint32Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int64 struct {
	t       *MapUint32Int64
	nodes   []*nodeMapuint32int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int64.
func (t *MapUint32Int64) Iterator() *IterUint32Int64 {
	var i IterUint32Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Int64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Int8 implements an associative array of int8 indexed by uint32.
type MapUint32Int8 struct {
	length int
	root   nodeMapuint32int8
}

// NewMapUint32Int8 returns a new map with keys of type uint32 and values of type int8
func NewMapUint32Int8() *MapUint32Int8 {
	var r MapUint32Int8
	return &r
}

type nodeMapuint32int8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32int8 or int8)
}

// Return walking direction
func (c nodeMapuint32int8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32int8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32int8) children() *[2]nodeMapuint32int8 {
	return (*[2]nodeMapuint32int8)(c.child)
}

func (c *nodeMapuint32int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32int8) find(key uint32) (crit uint, child, parent *nodeMapuint32int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Int8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Int8) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Int8) SetP(key uint32, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Int8) Set(key uint32, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Int8) GetP(key uint32) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Int8) Get(key uint32) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint32int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint32Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Int8 struct {
	t       *MapUint32Int8
	nodes   []*nodeMapuint32int8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Int8.
func (t *MapUint32Int8) Iterator() *IterUint32Int8 {
	var i IterUint32Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Int8) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Rune implements an associative array of rune indexed by uint32.
type MapUint32Rune struct {
	length int
	root   nodeMapuint32rune
}

// NewMapUint32Rune returns a new map with keys of type uint32 and values of type rune
func NewMapUint32Rune() *MapUint32Rune {
	var r MapUint32Rune
	return &r
}

type nodeMapuint32rune struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32rune or rune)
}

// Return walking direction
func (c nodeMapuint32rune) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32rune) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32rune) children() *[2]nodeMapuint32rune {
	return (*[2]nodeMapuint32rune)(c.child)
}

func (c *nodeMapuint32rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32rune) find(key uint32) (crit uint, child, parent *nodeMapuint32rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Rune) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Rune) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Rune) SetP(key uint32, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Rune) Set(key uint32, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Rune) GetP(key uint32) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Rune) Get(key uint32) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint32rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint32Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Rune struct {
	t       *MapUint32Rune
	nodes   []*nodeMapuint32rune
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Rune.
func (t *MapUint32Rune) Iterator() *IterUint32Rune {
	var i IterUint32Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Rune) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32String implements an associative array of string indexed by uint32.
type MapUint32String struct {
	length int
	root   nodeMapuint32string
}

// NewMapUint32String returns a new map with keys of type uint32 and values of type string
func NewMapUint32String() *MapUint32String {
	var r MapUint32String
	return &r
}

type nodeMapuint32string struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32string or string)
}

// Return walking direction
func (c nodeMapuint32string) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32string) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32string) children() *[2]nodeMapuint32string {
	return (*[2]nodeMapuint32string)(c.child)
}

func (c *nodeMapuint32string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32string) find(key uint32) (crit uint, child, parent *nodeMapuint32string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32String) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32String) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32String) SetP(key uint32, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32String) Set(key uint32, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32String) GetP(key uint32) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32String) Get(key uint32) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32String) Length() int {
	return t.length
}

// func (c *nodeMapuint32string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint32String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32String struct {
	t       *MapUint32String
	nodes   []*nodeMapuint32string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32  // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32String.
func (t *MapUint32String) Iterator() *IterUint32String {
	var i IterUint32String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32String) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uint implements an associative array of uint indexed by uint32.
type MapUint32Uint struct {
	length int
	root   nodeMapuint32uint
}

// NewMapUint32Uint returns a new map with keys of type uint32 and values of type uint
func NewMapUint32Uint() *MapUint32Uint {
	var r MapUint32Uint
	return &r
}

type nodeMapuint32uint struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint or uint)
}

// Return walking direction
func (c nodeMapuint32uint) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint) children() *[2]nodeMapuint32uint {
	return (*[2]nodeMapuint32uint)(c.child)
}

func (c *nodeMapuint32uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uint) find(key uint32) (crit uint, child, parent *nodeMapuint32uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uint) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uint) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint) SetP(key uint32, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint) Set(key uint32, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint) GetP(key uint32) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint) Get(key uint32) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint32Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint struct {
	t       *MapUint32Uint
	nodes   []*nodeMapuint32uint
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint.
func (t *MapUint32Uint) Iterator() *IterUint32Uint {
	var i IterUint32Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uint) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uint16 implements an associative array of uint16 indexed by uint32.
type MapUint32Uint16 struct {
	length int
	root   nodeMapuint32uint16
}

// NewMapUint32Uint16 returns a new map with keys of type uint32 and values of type uint16
func NewMapUint32Uint16() *MapUint32Uint16 {
	var r MapUint32Uint16
	return &r
}

type nodeMapuint32uint16 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint32uint16) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint16) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint16) children() *[2]nodeMapuint32uint16 {
	return (*[2]nodeMapuint32uint16)(c.child)
}

func (c *nodeMapuint32uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uint16) find(key uint32) (crit uint, child, parent *nodeMapuint32uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uint16) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uint16) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint16) SetP(key uint32, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint16) Set(key uint32, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint16) GetP(key uint32) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint16) Get(key uint32) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint32Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint16 struct {
	t       *MapUint32Uint16
	nodes   []*nodeMapuint32uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32  // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint16.
func (t *MapUint32Uint16) Iterator() *IterUint32Uint16 {
	var i IterUint32Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uint16) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uint32 implements an associative array of uint32 indexed by uint32.
type MapUint32Uint32 struct {
	length int
	root   nodeMapuint32uint32
}

// NewMapUint32Uint32 returns a new map with keys of type uint32 and values of type uint32
func NewMapUint32Uint32() *MapUint32Uint32 {
	var r MapUint32Uint32
	return &r
}

type nodeMapuint32uint32 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint32uint32) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint32) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint32) children() *[2]nodeMapuint32uint32 {
	return (*[2]nodeMapuint32uint32)(c.child)
}

func (c *nodeMapuint32uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uint32) find(key uint32) (crit uint, child, parent *nodeMapuint32uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uint32) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uint32) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint32) SetP(key uint32, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint32) Set(key uint32, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint32) GetP(key uint32) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint32) Get(key uint32) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint32Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint32 struct {
	t       *MapUint32Uint32
	nodes   []*nodeMapuint32uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32  // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint32.
func (t *MapUint32Uint32) Iterator() *IterUint32Uint32 {
	var i IterUint32Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uint32) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uint64 implements an associative array of uint64 indexed by uint32.
type MapUint32Uint64 struct {
	length int
	root   nodeMapuint32uint64
}

// NewMapUint32Uint64 returns a new map with keys of type uint32 and values of type uint64
func NewMapUint32Uint64() *MapUint32Uint64 {
	var r MapUint32Uint64
	return &r
}

type nodeMapuint32uint64 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint32uint64) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint64) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint64) children() *[2]nodeMapuint32uint64 {
	return (*[2]nodeMapuint32uint64)(c.child)
}

func (c *nodeMapuint32uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uint64) find(key uint32) (crit uint, child, parent *nodeMapuint32uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uint64) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uint64) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint64) SetP(key uint32, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint64) Set(key uint32, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint64) GetP(key uint32) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint64) Get(key uint32) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint32Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint64 struct {
	t       *MapUint32Uint64
	nodes   []*nodeMapuint32uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32  // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint64.
func (t *MapUint32Uint64) Iterator() *IterUint32Uint64 {
	var i IterUint32Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uint64) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uint8 implements an associative array of uint8 indexed by uint32.
type MapUint32Uint8 struct {
	length int
	root   nodeMapuint32uint8
}

// NewMapUint32Uint8 returns a new map with keys of type uint32 and values of type uint8
func NewMapUint32Uint8() *MapUint32Uint8 {
	var r MapUint32Uint8
	return &r
}

type nodeMapuint32uint8 struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint32uint8) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uint8) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uint8) children() *[2]nodeMapuint32uint8 {
	return (*[2]nodeMapuint32uint8)(c.child)
}

func (c *nodeMapuint32uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uint8) find(key uint32) (crit uint, child, parent *nodeMapuint32uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uint8) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uint8) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uint8) SetP(key uint32, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uint8) Set(key uint32, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uint8) GetP(key uint32) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uint8) Get(key uint32) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint32uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint32Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uint8 struct {
	t       *MapUint32Uint8
	nodes   []*nodeMapuint32uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32 // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uint8.
func (t *MapUint32Uint8) Iterator() *IterUint32Uint8 {
	var i IterUint32Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uint8) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint32Uintptr implements an associative array of uintptr indexed by uint32.
type MapUint32Uintptr struct {
	length int
	root   nodeMapuint32uintptr
}

// NewMapUint32Uintptr returns a new map with keys of type uint32 and values of type uintptr
func NewMapUint32Uintptr() *MapUint32Uintptr {
	var r MapUint32Uintptr
	return &r
}

type nodeMapuint32uintptr struct {
	key   uint32         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint32uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint32uintptr) dir(key uint32) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint32uintptr) findCrit(key uint32) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint32uintptr) children() *[2]nodeMapuint32uintptr {
	return (*[2]nodeMapuint32uintptr)(c.child)
}

func (c *nodeMapuint32uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint32uintptr) find(key uint32) (crit uint, child, parent *nodeMapuint32uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint32Uintptr) transformKey(key uint32) uint32 {
	var mask uint32 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint32Uintptr) Rem(key uint32) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint32Uintptr) SetP(key uint32, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint32uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint32Uintptr) Set(key uint32, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint32Uintptr) GetP(key uint32) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint32Uintptr) Get(key uint32) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint32Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint32uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint32uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint32Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint32Uintptr struct {
	t       *MapUint32Uintptr
	nodes   []*nodeMapuint32uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint32   // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint32Uintptr.
func (t *MapUint32Uintptr) Iterator() *IterUint32Uintptr {
	var i IterUint32Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint32Uintptr) Seek(key uint32) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint32Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint32uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint32Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint32Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint32Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Bool implements an associative array of bool indexed by uint16.
type MapUint16Bool struct {
	length int
	root   nodeMapuint16bool
}

// NewMapUint16Bool returns a new map with keys of type uint16 and values of type bool
func NewMapUint16Bool() *MapUint16Bool {
	var r MapUint16Bool
	return &r
}

type nodeMapuint16bool struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16bool or bool)
}

// Return walking direction
func (c nodeMapuint16bool) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16bool) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16bool) children() *[2]nodeMapuint16bool {
	return (*[2]nodeMapuint16bool)(c.child)
}

func (c *nodeMapuint16bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16bool) find(key uint16) (crit uint, child, parent *nodeMapuint16bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Bool) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Bool) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Bool) SetP(key uint16, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Bool) Set(key uint16, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Bool) GetP(key uint16) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Bool) Get(key uint16) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint16bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint16Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Bool struct {
	t       *MapUint16Bool
	nodes   []*nodeMapuint16bool
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *bool  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Bool.
func (t *MapUint16Bool) Iterator() *IterUint16Bool {
	var i IterUint16Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Bool) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Byte implements an associative array of byte indexed by uint16.
type MapUint16Byte struct {
	length int
	root   nodeMapuint16byte
}

// NewMapUint16Byte returns a new map with keys of type uint16 and values of type byte
func NewMapUint16Byte() *MapUint16Byte {
	var r MapUint16Byte
	return &r
}

type nodeMapuint16byte struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16byte or byte)
}

// Return walking direction
func (c nodeMapuint16byte) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16byte) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16byte) children() *[2]nodeMapuint16byte {
	return (*[2]nodeMapuint16byte)(c.child)
}

func (c *nodeMapuint16byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16byte) find(key uint16) (crit uint, child, parent *nodeMapuint16byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Byte) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Byte) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Byte) SetP(key uint16, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Byte) Set(key uint16, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Byte) GetP(key uint16) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Byte) Get(key uint16) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint16byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint16Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Byte struct {
	t       *MapUint16Byte
	nodes   []*nodeMapuint16byte
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *byte  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Byte.
func (t *MapUint16Byte) Iterator() *IterUint16Byte {
	var i IterUint16Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Byte) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Complex128 implements an associative array of complex128 indexed by uint16.
type MapUint16Complex128 struct {
	length int
	root   nodeMapuint16complex128
}

// NewMapUint16Complex128 returns a new map with keys of type uint16 and values of type complex128
func NewMapUint16Complex128() *MapUint16Complex128 {
	var r MapUint16Complex128
	return &r
}

type nodeMapuint16complex128 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint16complex128) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex128) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16complex128) children() *[2]nodeMapuint16complex128 {
	return (*[2]nodeMapuint16complex128)(c.child)
}

func (c *nodeMapuint16complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16complex128) find(key uint16) (crit uint, child, parent *nodeMapuint16complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Complex128) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Complex128) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Complex128) SetP(key uint16, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Complex128) Set(key uint16, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Complex128) GetP(key uint16) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Complex128) Get(key uint16) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint16Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Complex128 struct {
	t       *MapUint16Complex128
	nodes   []*nodeMapuint16complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16      // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Complex128.
func (t *MapUint16Complex128) Iterator() *IterUint16Complex128 {
	var i IterUint16Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Complex128) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Complex64 implements an associative array of complex64 indexed by uint16.
type MapUint16Complex64 struct {
	length int
	root   nodeMapuint16complex64
}

// NewMapUint16Complex64 returns a new map with keys of type uint16 and values of type complex64
func NewMapUint16Complex64() *MapUint16Complex64 {
	var r MapUint16Complex64
	return &r
}

type nodeMapuint16complex64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint16complex64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16complex64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16complex64) children() *[2]nodeMapuint16complex64 {
	return (*[2]nodeMapuint16complex64)(c.child)
}

func (c *nodeMapuint16complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16complex64) find(key uint16) (crit uint, child, parent *nodeMapuint16complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Complex64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Complex64) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Complex64) SetP(key uint16, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Complex64) Set(key uint16, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Complex64) GetP(key uint16) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Complex64) Get(key uint16) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint16complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint16Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Complex64 struct {
	t       *MapUint16Complex64
	nodes   []*nodeMapuint16complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16     // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Complex64.
func (t *MapUint16Complex64) Iterator() *IterUint16Complex64 {
	var i IterUint16Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Complex64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Error implements an associative array of error indexed by uint16.
type MapUint16Error struct {
	length int
	root   nodeMapuint16error
}

// NewMapUint16Error returns a new map with keys of type uint16 and values of type error
func NewMapUint16Error() *MapUint16Error {
	var r MapUint16Error
	return &r
}

type nodeMapuint16error struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16error or error)
}

// Return walking direction
func (c nodeMapuint16error) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16error) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16error) children() *[2]nodeMapuint16error {
	return (*[2]nodeMapuint16error)(c.child)
}

func (c *nodeMapuint16error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16error) find(key uint16) (crit uint, child, parent *nodeMapuint16error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Error) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Error) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Error) SetP(key uint16, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Error) Set(key uint16, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Error) GetP(key uint16) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Error) Get(key uint16) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Error) Length() int {
	return t.length
}

// func (c *nodeMapuint16error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint16Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Error struct {
	t       *MapUint16Error
	nodes   []*nodeMapuint16error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Error.
func (t *MapUint16Error) Iterator() *IterUint16Error {
	var i IterUint16Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Error) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Float32 implements an associative array of float32 indexed by uint16.
type MapUint16Float32 struct {
	length int
	root   nodeMapuint16float32
}

// NewMapUint16Float32 returns a new map with keys of type uint16 and values of type float32
func NewMapUint16Float32() *MapUint16Float32 {
	var r MapUint16Float32
	return &r
}

type nodeMapuint16float32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float32 or float32)
}

// Return walking direction
func (c nodeMapuint16float32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16float32) children() *[2]nodeMapuint16float32 {
	return (*[2]nodeMapuint16float32)(c.child)
}

func (c *nodeMapuint16float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16float32) find(key uint16) (crit uint, child, parent *nodeMapuint16float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Float32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Float32) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Float32) SetP(key uint16, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Float32) Set(key uint16, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Float32) GetP(key uint16) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Float32) Get(key uint16) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint16float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint16Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Float32 struct {
	t       *MapUint16Float32
	nodes   []*nodeMapuint16float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16   // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Float32.
func (t *MapUint16Float32) Iterator() *IterUint16Float32 {
	var i IterUint16Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Float32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Float64 implements an associative array of float64 indexed by uint16.
type MapUint16Float64 struct {
	length int
	root   nodeMapuint16float64
}

// NewMapUint16Float64 returns a new map with keys of type uint16 and values of type float64
func NewMapUint16Float64() *MapUint16Float64 {
	var r MapUint16Float64
	return &r
}

type nodeMapuint16float64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16float64 or float64)
}

// Return walking direction
func (c nodeMapuint16float64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16float64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16float64) children() *[2]nodeMapuint16float64 {
	return (*[2]nodeMapuint16float64)(c.child)
}

func (c *nodeMapuint16float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16float64) find(key uint16) (crit uint, child, parent *nodeMapuint16float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Float64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Float64) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Float64) SetP(key uint16, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Float64) Set(key uint16, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Float64) GetP(key uint16) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Float64) Get(key uint16) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint16float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint16Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Float64 struct {
	t       *MapUint16Float64
	nodes   []*nodeMapuint16float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16   // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Float64.
func (t *MapUint16Float64) Iterator() *IterUint16Float64 {
	var i IterUint16Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Float64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Int implements an associative array of int indexed by uint16.
type MapUint16Int struct {
	length int
	root   nodeMapuint16int
}

// NewMapUint16Int returns a new map with keys of type uint16 and values of type int
func NewMapUint16Int() *MapUint16Int {
	var r MapUint16Int
	return &r
}

type nodeMapuint16int struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int or int)
}

// Return walking direction
func (c nodeMapuint16int) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int) children() *[2]nodeMapuint16int {
	return (*[2]nodeMapuint16int)(c.child)
}

func (c *nodeMapuint16int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16int) find(key uint16) (crit uint, child, parent *nodeMapuint16int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Int) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Int) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int) SetP(key uint16, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int) Set(key uint16, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int) GetP(key uint16) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int) Get(key uint16) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int) Length() int {
	return t.length
}

// func (c *nodeMapuint16int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint16Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int struct {
	t       *MapUint16Int
	nodes   []*nodeMapuint16int
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *int   // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int.
func (t *MapUint16Int) Iterator() *IterUint16Int {
	var i IterUint16Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Int) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Int16 implements an associative array of int16 indexed by uint16.
type MapUint16Int16 struct {
	length int
	root   nodeMapuint16int16
}

// NewMapUint16Int16 returns a new map with keys of type uint16 and values of type int16
func NewMapUint16Int16() *MapUint16Int16 {
	var r MapUint16Int16
	return &r
}

type nodeMapuint16int16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int16 or int16)
}

// Return walking direction
func (c nodeMapuint16int16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int16) children() *[2]nodeMapuint16int16 {
	return (*[2]nodeMapuint16int16)(c.child)
}

func (c *nodeMapuint16int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16int16) find(key uint16) (crit uint, child, parent *nodeMapuint16int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Int16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Int16) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int16) SetP(key uint16, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int16) Set(key uint16, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int16) GetP(key uint16) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int16) Get(key uint16) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint16int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint16Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int16 struct {
	t       *MapUint16Int16
	nodes   []*nodeMapuint16int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int16.
func (t *MapUint16Int16) Iterator() *IterUint16Int16 {
	var i IterUint16Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Int16) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Int32 implements an associative array of int32 indexed by uint16.
type MapUint16Int32 struct {
	length int
	root   nodeMapuint16int32
}

// NewMapUint16Int32 returns a new map with keys of type uint16 and values of type int32
func NewMapUint16Int32() *MapUint16Int32 {
	var r MapUint16Int32
	return &r
}

type nodeMapuint16int32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int32 or int32)
}

// Return walking direction
func (c nodeMapuint16int32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int32) children() *[2]nodeMapuint16int32 {
	return (*[2]nodeMapuint16int32)(c.child)
}

func (c *nodeMapuint16int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16int32) find(key uint16) (crit uint, child, parent *nodeMapuint16int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Int32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Int32) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int32) SetP(key uint16, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int32) Set(key uint16, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int32) GetP(key uint16) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int32) Get(key uint16) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint16int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint16Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int32 struct {
	t       *MapUint16Int32
	nodes   []*nodeMapuint16int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int32.
func (t *MapUint16Int32) Iterator() *IterUint16Int32 {
	var i IterUint16Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Int32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Int64 implements an associative array of int64 indexed by uint16.
type MapUint16Int64 struct {
	length int
	root   nodeMapuint16int64
}

// NewMapUint16Int64 returns a new map with keys of type uint16 and values of type int64
func NewMapUint16Int64() *MapUint16Int64 {
	var r MapUint16Int64
	return &r
}

type nodeMapuint16int64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int64 or int64)
}

// Return walking direction
func (c nodeMapuint16int64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int64) children() *[2]nodeMapuint16int64 {
	return (*[2]nodeMapuint16int64)(c.child)
}

func (c *nodeMapuint16int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16int64) find(key uint16) (crit uint, child, parent *nodeMapuint16int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Int64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Int64) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int64) SetP(key uint16, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int64) Set(key uint16, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int64) GetP(key uint16) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int64) Get(key uint16) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint16int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint16Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int64 struct {
	t       *MapUint16Int64
	nodes   []*nodeMapuint16int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int64.
func (t *MapUint16Int64) Iterator() *IterUint16Int64 {
	var i IterUint16Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Int64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Int8 implements an associative array of int8 indexed by uint16.
type MapUint16Int8 struct {
	length int
	root   nodeMapuint16int8
}

// NewMapUint16Int8 returns a new map with keys of type uint16 and values of type int8
func NewMapUint16Int8() *MapUint16Int8 {
	var r MapUint16Int8
	return &r
}

type nodeMapuint16int8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16int8 or int8)
}

// Return walking direction
func (c nodeMapuint16int8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16int8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16int8) children() *[2]nodeMapuint16int8 {
	return (*[2]nodeMapuint16int8)(c.child)
}

func (c *nodeMapuint16int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16int8) find(key uint16) (crit uint, child, parent *nodeMapuint16int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Int8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Int8) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Int8) SetP(key uint16, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Int8) Set(key uint16, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Int8) GetP(key uint16) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Int8) Get(key uint16) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint16int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint16Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Int8 struct {
	t       *MapUint16Int8
	nodes   []*nodeMapuint16int8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *int8  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Int8.
func (t *MapUint16Int8) Iterator() *IterUint16Int8 {
	var i IterUint16Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Int8) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Rune implements an associative array of rune indexed by uint16.
type MapUint16Rune struct {
	length int
	root   nodeMapuint16rune
}

// NewMapUint16Rune returns a new map with keys of type uint16 and values of type rune
func NewMapUint16Rune() *MapUint16Rune {
	var r MapUint16Rune
	return &r
}

type nodeMapuint16rune struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16rune or rune)
}

// Return walking direction
func (c nodeMapuint16rune) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16rune) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16rune) children() *[2]nodeMapuint16rune {
	return (*[2]nodeMapuint16rune)(c.child)
}

func (c *nodeMapuint16rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16rune) find(key uint16) (crit uint, child, parent *nodeMapuint16rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Rune) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Rune) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Rune) SetP(key uint16, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Rune) Set(key uint16, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Rune) GetP(key uint16) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Rune) Get(key uint16) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint16rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint16Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Rune struct {
	t       *MapUint16Rune
	nodes   []*nodeMapuint16rune
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *rune  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Rune.
func (t *MapUint16Rune) Iterator() *IterUint16Rune {
	var i IterUint16Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Rune) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16String implements an associative array of string indexed by uint16.
type MapUint16String struct {
	length int
	root   nodeMapuint16string
}

// NewMapUint16String returns a new map with keys of type uint16 and values of type string
func NewMapUint16String() *MapUint16String {
	var r MapUint16String
	return &r
}

type nodeMapuint16string struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16string or string)
}

// Return walking direction
func (c nodeMapuint16string) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16string) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16string) children() *[2]nodeMapuint16string {
	return (*[2]nodeMapuint16string)(c.child)
}

func (c *nodeMapuint16string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16string) find(key uint16) (crit uint, child, parent *nodeMapuint16string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16String) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16String) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16String) SetP(key uint16, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16String) Set(key uint16, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16String) GetP(key uint16) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16String) Get(key uint16) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16String) Length() int {
	return t.length
}

// func (c *nodeMapuint16string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint16String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16String struct {
	t       *MapUint16String
	nodes   []*nodeMapuint16string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16  // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16String.
func (t *MapUint16String) Iterator() *IterUint16String {
	var i IterUint16String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16String) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uint implements an associative array of uint indexed by uint16.
type MapUint16Uint struct {
	length int
	root   nodeMapuint16uint
}

// NewMapUint16Uint returns a new map with keys of type uint16 and values of type uint
func NewMapUint16Uint() *MapUint16Uint {
	var r MapUint16Uint
	return &r
}

type nodeMapuint16uint struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint or uint)
}

// Return walking direction
func (c nodeMapuint16uint) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint) children() *[2]nodeMapuint16uint {
	return (*[2]nodeMapuint16uint)(c.child)
}

func (c *nodeMapuint16uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uint) find(key uint16) (crit uint, child, parent *nodeMapuint16uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uint) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uint) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint) SetP(key uint16, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint) Set(key uint16, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint) GetP(key uint16) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint) Get(key uint16) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint16Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint struct {
	t       *MapUint16Uint
	nodes   []*nodeMapuint16uint
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *uint  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint.
func (t *MapUint16Uint) Iterator() *IterUint16Uint {
	var i IterUint16Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uint) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uint16 implements an associative array of uint16 indexed by uint16.
type MapUint16Uint16 struct {
	length int
	root   nodeMapuint16uint16
}

// NewMapUint16Uint16 returns a new map with keys of type uint16 and values of type uint16
func NewMapUint16Uint16() *MapUint16Uint16 {
	var r MapUint16Uint16
	return &r
}

type nodeMapuint16uint16 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint16uint16) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint16) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint16) children() *[2]nodeMapuint16uint16 {
	return (*[2]nodeMapuint16uint16)(c.child)
}

func (c *nodeMapuint16uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uint16) find(key uint16) (crit uint, child, parent *nodeMapuint16uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uint16) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uint16) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint16) SetP(key uint16, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint16) Set(key uint16, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint16) GetP(key uint16) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint16) Get(key uint16) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint16Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint16 struct {
	t       *MapUint16Uint16
	nodes   []*nodeMapuint16uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16  // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint16.
func (t *MapUint16Uint16) Iterator() *IterUint16Uint16 {
	var i IterUint16Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uint16) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uint32 implements an associative array of uint32 indexed by uint16.
type MapUint16Uint32 struct {
	length int
	root   nodeMapuint16uint32
}

// NewMapUint16Uint32 returns a new map with keys of type uint16 and values of type uint32
func NewMapUint16Uint32() *MapUint16Uint32 {
	var r MapUint16Uint32
	return &r
}

type nodeMapuint16uint32 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint16uint32) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint32) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint32) children() *[2]nodeMapuint16uint32 {
	return (*[2]nodeMapuint16uint32)(c.child)
}

func (c *nodeMapuint16uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uint32) find(key uint16) (crit uint, child, parent *nodeMapuint16uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uint32) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uint32) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint32) SetP(key uint16, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint32) Set(key uint16, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint32) GetP(key uint16) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint32) Get(key uint16) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint16Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint32 struct {
	t       *MapUint16Uint32
	nodes   []*nodeMapuint16uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16  // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint32.
func (t *MapUint16Uint32) Iterator() *IterUint16Uint32 {
	var i IterUint16Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uint32) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uint64 implements an associative array of uint64 indexed by uint16.
type MapUint16Uint64 struct {
	length int
	root   nodeMapuint16uint64
}

// NewMapUint16Uint64 returns a new map with keys of type uint16 and values of type uint64
func NewMapUint16Uint64() *MapUint16Uint64 {
	var r MapUint16Uint64
	return &r
}

type nodeMapuint16uint64 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint16uint64) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint64) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint64) children() *[2]nodeMapuint16uint64 {
	return (*[2]nodeMapuint16uint64)(c.child)
}

func (c *nodeMapuint16uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uint64) find(key uint16) (crit uint, child, parent *nodeMapuint16uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uint64) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uint64) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint64) SetP(key uint16, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint64) Set(key uint16, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint64) GetP(key uint16) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint64) Get(key uint16) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint16Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint64 struct {
	t       *MapUint16Uint64
	nodes   []*nodeMapuint16uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16  // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint64.
func (t *MapUint16Uint64) Iterator() *IterUint16Uint64 {
	var i IterUint16Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uint64) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uint8 implements an associative array of uint8 indexed by uint16.
type MapUint16Uint8 struct {
	length int
	root   nodeMapuint16uint8
}

// NewMapUint16Uint8 returns a new map with keys of type uint16 and values of type uint8
func NewMapUint16Uint8() *MapUint16Uint8 {
	var r MapUint16Uint8
	return &r
}

type nodeMapuint16uint8 struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint16uint8) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uint8) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uint8) children() *[2]nodeMapuint16uint8 {
	return (*[2]nodeMapuint16uint8)(c.child)
}

func (c *nodeMapuint16uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uint8) find(key uint16) (crit uint, child, parent *nodeMapuint16uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uint8) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uint8) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uint8) SetP(key uint16, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uint8) Set(key uint16, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uint8) GetP(key uint16) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uint8) Get(key uint16) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint16uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint16Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uint8 struct {
	t       *MapUint16Uint8
	nodes   []*nodeMapuint16uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16 // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uint8.
func (t *MapUint16Uint8) Iterator() *IterUint16Uint8 {
	var i IterUint16Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uint8) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint16Uintptr implements an associative array of uintptr indexed by uint16.
type MapUint16Uintptr struct {
	length int
	root   nodeMapuint16uintptr
}

// NewMapUint16Uintptr returns a new map with keys of type uint16 and values of type uintptr
func NewMapUint16Uintptr() *MapUint16Uintptr {
	var r MapUint16Uintptr
	return &r
}

type nodeMapuint16uintptr struct {
	key   uint16         // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint16uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint16uintptr) dir(key uint16) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint16uintptr) findCrit(key uint16) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint16uintptr) children() *[2]nodeMapuint16uintptr {
	return (*[2]nodeMapuint16uintptr)(c.child)
}

func (c *nodeMapuint16uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint16uintptr) find(key uint16) (crit uint, child, parent *nodeMapuint16uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint16Uintptr) transformKey(key uint16) uint16 {
	var mask uint16 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint16Uintptr) Rem(key uint16) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint16Uintptr) SetP(key uint16, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint16uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint16Uintptr) Set(key uint16, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint16Uintptr) GetP(key uint16) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint16Uintptr) Get(key uint16) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint16Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint16uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint16uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint16Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint16Uintptr struct {
	t       *MapUint16Uintptr
	nodes   []*nodeMapuint16uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint16   // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint16Uintptr.
func (t *MapUint16Uintptr) Iterator() *IterUint16Uintptr {
	var i IterUint16Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint16Uintptr) Seek(key uint16) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint16Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint16uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint16Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint16Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint16Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Bool implements an associative array of bool indexed by uint8.
type MapUint8Bool struct {
	length int
	root   nodeMapuint8bool
}

// NewMapUint8Bool returns a new map with keys of type uint8 and values of type bool
func NewMapUint8Bool() *MapUint8Bool {
	var r MapUint8Bool
	return &r
}

type nodeMapuint8bool struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8bool or bool)
}

// Return walking direction
func (c nodeMapuint8bool) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8bool) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8bool) children() *[2]nodeMapuint8bool {
	return (*[2]nodeMapuint8bool)(c.child)
}

func (c *nodeMapuint8bool) value() *bool {
	return (*bool)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8bool) find(key uint8) (crit uint, child, parent *nodeMapuint8bool) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Bool) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Bool) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Bool) SetP(key uint8, val *bool) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8bool{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Bool) Set(key uint8, val bool) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Bool) GetP(key uint8) (*bool, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*bool)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Bool) Get(key uint8) (bool, bool) {
	var v bool
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Bool) Length() int {
	return t.length
}

// func (c *nodeMapuint8bool) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8bool)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*bool)(c.child))
// 	}
// }

// IterUint8Bool The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Bool struct {
	t       *MapUint8Bool
	nodes   []*nodeMapuint8bool
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *bool // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Bool.
func (t *MapUint8Bool) Iterator() *IterUint8Bool {
	var i IterUint8Bool
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Bool) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Bool) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8bool, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Bool) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Bool) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Bool) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Byte implements an associative array of byte indexed by uint8.
type MapUint8Byte struct {
	length int
	root   nodeMapuint8byte
}

// NewMapUint8Byte returns a new map with keys of type uint8 and values of type byte
func NewMapUint8Byte() *MapUint8Byte {
	var r MapUint8Byte
	return &r
}

type nodeMapuint8byte struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8byte or byte)
}

// Return walking direction
func (c nodeMapuint8byte) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8byte) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8byte) children() *[2]nodeMapuint8byte {
	return (*[2]nodeMapuint8byte)(c.child)
}

func (c *nodeMapuint8byte) value() *byte {
	return (*byte)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8byte) find(key uint8) (crit uint, child, parent *nodeMapuint8byte) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Byte) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Byte) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Byte) SetP(key uint8, val *byte) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8byte{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Byte) Set(key uint8, val byte) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Byte) GetP(key uint8) (*byte, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*byte)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Byte) Get(key uint8) (byte, bool) {
	var v byte
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Byte) Length() int {
	return t.length
}

// func (c *nodeMapuint8byte) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8byte)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*byte)(c.child))
// 	}
// }

// IterUint8Byte The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Byte struct {
	t       *MapUint8Byte
	nodes   []*nodeMapuint8byte
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *byte // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Byte.
func (t *MapUint8Byte) Iterator() *IterUint8Byte {
	var i IterUint8Byte
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Byte) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Byte) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8byte, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Byte) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Byte) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Byte) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Complex128 implements an associative array of complex128 indexed by uint8.
type MapUint8Complex128 struct {
	length int
	root   nodeMapuint8complex128
}

// NewMapUint8Complex128 returns a new map with keys of type uint8 and values of type complex128
func NewMapUint8Complex128() *MapUint8Complex128 {
	var r MapUint8Complex128
	return &r
}

type nodeMapuint8complex128 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex128 or complex128)
}

// Return walking direction
func (c nodeMapuint8complex128) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex128) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8complex128) children() *[2]nodeMapuint8complex128 {
	return (*[2]nodeMapuint8complex128)(c.child)
}

func (c *nodeMapuint8complex128) value() *complex128 {
	return (*complex128)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8complex128) find(key uint8) (crit uint, child, parent *nodeMapuint8complex128) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Complex128) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Complex128) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Complex128) SetP(key uint8, val *complex128) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex128{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Complex128) Set(key uint8, val complex128) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Complex128) GetP(key uint8) (*complex128, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex128)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Complex128) Get(key uint8) (complex128, bool) {
	var v complex128
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex128) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex128) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex128)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex128)(c.child))
// 	}
// }

// IterUint8Complex128 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Complex128 struct {
	t       *MapUint8Complex128
	nodes   []*nodeMapuint8complex128
	lastDir int
	Found   bool        // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8       // Key found by last call to Next, Prev.
	Value   *complex128 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Complex128.
func (t *MapUint8Complex128) Iterator() *IterUint8Complex128 {
	var i IterUint8Complex128
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Complex128) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Complex128) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8complex128, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Complex128) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Complex128) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Complex128) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Complex64 implements an associative array of complex64 indexed by uint8.
type MapUint8Complex64 struct {
	length int
	root   nodeMapuint8complex64
}

// NewMapUint8Complex64 returns a new map with keys of type uint8 and values of type complex64
func NewMapUint8Complex64() *MapUint8Complex64 {
	var r MapUint8Complex64
	return &r
}

type nodeMapuint8complex64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8complex64 or complex64)
}

// Return walking direction
func (c nodeMapuint8complex64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8complex64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8complex64) children() *[2]nodeMapuint8complex64 {
	return (*[2]nodeMapuint8complex64)(c.child)
}

func (c *nodeMapuint8complex64) value() *complex64 {
	return (*complex64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8complex64) find(key uint8) (crit uint, child, parent *nodeMapuint8complex64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Complex64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Complex64) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Complex64) SetP(key uint8, val *complex64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8complex64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Complex64) Set(key uint8, val complex64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Complex64) GetP(key uint8) (*complex64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*complex64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Complex64) Get(key uint8) (complex64, bool) {
	var v complex64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Complex64) Length() int {
	return t.length
}

// func (c *nodeMapuint8complex64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8complex64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*complex64)(c.child))
// 	}
// }

// IterUint8Complex64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Complex64 struct {
	t       *MapUint8Complex64
	nodes   []*nodeMapuint8complex64
	lastDir int
	Found   bool       // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8      // Key found by last call to Next, Prev.
	Value   *complex64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Complex64.
func (t *MapUint8Complex64) Iterator() *IterUint8Complex64 {
	var i IterUint8Complex64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Complex64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Complex64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8complex64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Complex64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Complex64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Complex64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Error implements an associative array of error indexed by uint8.
type MapUint8Error struct {
	length int
	root   nodeMapuint8error
}

// NewMapUint8Error returns a new map with keys of type uint8 and values of type error
func NewMapUint8Error() *MapUint8Error {
	var r MapUint8Error
	return &r
}

type nodeMapuint8error struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8error or error)
}

// Return walking direction
func (c nodeMapuint8error) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8error) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8error) children() *[2]nodeMapuint8error {
	return (*[2]nodeMapuint8error)(c.child)
}

func (c *nodeMapuint8error) value() *error {
	return (*error)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8error) find(key uint8) (crit uint, child, parent *nodeMapuint8error) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Error) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Error) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Error) SetP(key uint8, val *error) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8error{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Error) Set(key uint8, val error) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Error) GetP(key uint8) (*error, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*error)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Error) Get(key uint8) (error, bool) {
	var v error
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Error) Length() int {
	return t.length
}

// func (c *nodeMapuint8error) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8error)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*error)(c.child))
// 	}
// }

// IterUint8Error The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Error struct {
	t       *MapUint8Error
	nodes   []*nodeMapuint8error
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8  // Key found by last call to Next, Prev.
	Value   *error // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Error.
func (t *MapUint8Error) Iterator() *IterUint8Error {
	var i IterUint8Error
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Error) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Error) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8error, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Error) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Error) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Error) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Float32 implements an associative array of float32 indexed by uint8.
type MapUint8Float32 struct {
	length int
	root   nodeMapuint8float32
}

// NewMapUint8Float32 returns a new map with keys of type uint8 and values of type float32
func NewMapUint8Float32() *MapUint8Float32 {
	var r MapUint8Float32
	return &r
}

type nodeMapuint8float32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float32 or float32)
}

// Return walking direction
func (c nodeMapuint8float32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8float32) children() *[2]nodeMapuint8float32 {
	return (*[2]nodeMapuint8float32)(c.child)
}

func (c *nodeMapuint8float32) value() *float32 {
	return (*float32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8float32) find(key uint8) (crit uint, child, parent *nodeMapuint8float32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Float32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Float32) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Float32) SetP(key uint8, val *float32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Float32) Set(key uint8, val float32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Float32) GetP(key uint8) (*float32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Float32) Get(key uint8) (float32, bool) {
	var v float32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float32) Length() int {
	return t.length
}

// func (c *nodeMapuint8float32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float32)(c.child))
// 	}
// }

// IterUint8Float32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Float32 struct {
	t       *MapUint8Float32
	nodes   []*nodeMapuint8float32
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8    // Key found by last call to Next, Prev.
	Value   *float32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Float32.
func (t *MapUint8Float32) Iterator() *IterUint8Float32 {
	var i IterUint8Float32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Float32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Float32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8float32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Float32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Float32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Float32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Float64 implements an associative array of float64 indexed by uint8.
type MapUint8Float64 struct {
	length int
	root   nodeMapuint8float64
}

// NewMapUint8Float64 returns a new map with keys of type uint8 and values of type float64
func NewMapUint8Float64() *MapUint8Float64 {
	var r MapUint8Float64
	return &r
}

type nodeMapuint8float64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8float64 or float64)
}

// Return walking direction
func (c nodeMapuint8float64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8float64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8float64) children() *[2]nodeMapuint8float64 {
	return (*[2]nodeMapuint8float64)(c.child)
}

func (c *nodeMapuint8float64) value() *float64 {
	return (*float64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8float64) find(key uint8) (crit uint, child, parent *nodeMapuint8float64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Float64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Float64) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Float64) SetP(key uint8, val *float64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8float64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Float64) Set(key uint8, val float64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Float64) GetP(key uint8) (*float64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*float64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Float64) Get(key uint8) (float64, bool) {
	var v float64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Float64) Length() int {
	return t.length
}

// func (c *nodeMapuint8float64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8float64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*float64)(c.child))
// 	}
// }

// IterUint8Float64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Float64 struct {
	t       *MapUint8Float64
	nodes   []*nodeMapuint8float64
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8    // Key found by last call to Next, Prev.
	Value   *float64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Float64.
func (t *MapUint8Float64) Iterator() *IterUint8Float64 {
	var i IterUint8Float64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Float64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Float64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8float64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Float64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Float64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Float64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Int implements an associative array of int indexed by uint8.
type MapUint8Int struct {
	length int
	root   nodeMapuint8int
}

// NewMapUint8Int returns a new map with keys of type uint8 and values of type int
func NewMapUint8Int() *MapUint8Int {
	var r MapUint8Int
	return &r
}

type nodeMapuint8int struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int or int)
}

// Return walking direction
func (c nodeMapuint8int) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int) children() *[2]nodeMapuint8int {
	return (*[2]nodeMapuint8int)(c.child)
}

func (c *nodeMapuint8int) value() *int {
	return (*int)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8int) find(key uint8) (crit uint, child, parent *nodeMapuint8int) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Int) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Int) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int) SetP(key uint8, val *int) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int) Set(key uint8, val int) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int) GetP(key uint8) (*int, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int) Get(key uint8) (int, bool) {
	var v int
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int) Length() int {
	return t.length
}

// func (c *nodeMapuint8int) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int)(c.child))
// 	}
// }

// IterUint8Int The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int struct {
	t       *MapUint8Int
	nodes   []*nodeMapuint8int
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *int  // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int.
func (t *MapUint8Int) Iterator() *IterUint8Int {
	var i IterUint8Int
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Int) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Int) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Int) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Int) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Int) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Int16 implements an associative array of int16 indexed by uint8.
type MapUint8Int16 struct {
	length int
	root   nodeMapuint8int16
}

// NewMapUint8Int16 returns a new map with keys of type uint8 and values of type int16
func NewMapUint8Int16() *MapUint8Int16 {
	var r MapUint8Int16
	return &r
}

type nodeMapuint8int16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int16 or int16)
}

// Return walking direction
func (c nodeMapuint8int16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int16) children() *[2]nodeMapuint8int16 {
	return (*[2]nodeMapuint8int16)(c.child)
}

func (c *nodeMapuint8int16) value() *int16 {
	return (*int16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8int16) find(key uint8) (crit uint, child, parent *nodeMapuint8int16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Int16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Int16) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int16) SetP(key uint8, val *int16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int16) Set(key uint8, val int16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int16) GetP(key uint8) (*int16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int16) Get(key uint8) (int16, bool) {
	var v int16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int16) Length() int {
	return t.length
}

// func (c *nodeMapuint8int16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int16)(c.child))
// 	}
// }

// IterUint8Int16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int16 struct {
	t       *MapUint8Int16
	nodes   []*nodeMapuint8int16
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8  // Key found by last call to Next, Prev.
	Value   *int16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int16.
func (t *MapUint8Int16) Iterator() *IterUint8Int16 {
	var i IterUint8Int16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Int16) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Int16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Int16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Int16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Int16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Int32 implements an associative array of int32 indexed by uint8.
type MapUint8Int32 struct {
	length int
	root   nodeMapuint8int32
}

// NewMapUint8Int32 returns a new map with keys of type uint8 and values of type int32
func NewMapUint8Int32() *MapUint8Int32 {
	var r MapUint8Int32
	return &r
}

type nodeMapuint8int32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int32 or int32)
}

// Return walking direction
func (c nodeMapuint8int32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int32) children() *[2]nodeMapuint8int32 {
	return (*[2]nodeMapuint8int32)(c.child)
}

func (c *nodeMapuint8int32) value() *int32 {
	return (*int32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8int32) find(key uint8) (crit uint, child, parent *nodeMapuint8int32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Int32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Int32) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int32) SetP(key uint8, val *int32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int32) Set(key uint8, val int32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int32) GetP(key uint8) (*int32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int32) Get(key uint8) (int32, bool) {
	var v int32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int32) Length() int {
	return t.length
}

// func (c *nodeMapuint8int32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int32)(c.child))
// 	}
// }

// IterUint8Int32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int32 struct {
	t       *MapUint8Int32
	nodes   []*nodeMapuint8int32
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8  // Key found by last call to Next, Prev.
	Value   *int32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int32.
func (t *MapUint8Int32) Iterator() *IterUint8Int32 {
	var i IterUint8Int32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Int32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Int32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Int32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Int32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Int32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Int64 implements an associative array of int64 indexed by uint8.
type MapUint8Int64 struct {
	length int
	root   nodeMapuint8int64
}

// NewMapUint8Int64 returns a new map with keys of type uint8 and values of type int64
func NewMapUint8Int64() *MapUint8Int64 {
	var r MapUint8Int64
	return &r
}

type nodeMapuint8int64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int64 or int64)
}

// Return walking direction
func (c nodeMapuint8int64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int64) children() *[2]nodeMapuint8int64 {
	return (*[2]nodeMapuint8int64)(c.child)
}

func (c *nodeMapuint8int64) value() *int64 {
	return (*int64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8int64) find(key uint8) (crit uint, child, parent *nodeMapuint8int64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Int64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Int64) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int64) SetP(key uint8, val *int64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int64) Set(key uint8, val int64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int64) GetP(key uint8) (*int64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int64) Get(key uint8) (int64, bool) {
	var v int64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int64) Length() int {
	return t.length
}

// func (c *nodeMapuint8int64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int64)(c.child))
// 	}
// }

// IterUint8Int64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int64 struct {
	t       *MapUint8Int64
	nodes   []*nodeMapuint8int64
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8  // Key found by last call to Next, Prev.
	Value   *int64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int64.
func (t *MapUint8Int64) Iterator() *IterUint8Int64 {
	var i IterUint8Int64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Int64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Int64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Int64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Int64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Int64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Int8 implements an associative array of int8 indexed by uint8.
type MapUint8Int8 struct {
	length int
	root   nodeMapuint8int8
}

// NewMapUint8Int8 returns a new map with keys of type uint8 and values of type int8
func NewMapUint8Int8() *MapUint8Int8 {
	var r MapUint8Int8
	return &r
}

type nodeMapuint8int8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8int8 or int8)
}

// Return walking direction
func (c nodeMapuint8int8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8int8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8int8) children() *[2]nodeMapuint8int8 {
	return (*[2]nodeMapuint8int8)(c.child)
}

func (c *nodeMapuint8int8) value() *int8 {
	return (*int8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8int8) find(key uint8) (crit uint, child, parent *nodeMapuint8int8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Int8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Int8) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Int8) SetP(key uint8, val *int8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8int8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Int8) Set(key uint8, val int8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Int8) GetP(key uint8) (*int8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*int8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Int8) Get(key uint8) (int8, bool) {
	var v int8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Int8) Length() int {
	return t.length
}

// func (c *nodeMapuint8int8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8int8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*int8)(c.child))
// 	}
// }

// IterUint8Int8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Int8 struct {
	t       *MapUint8Int8
	nodes   []*nodeMapuint8int8
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *int8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Int8.
func (t *MapUint8Int8) Iterator() *IterUint8Int8 {
	var i IterUint8Int8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Int8) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Int8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8int8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Int8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Int8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Int8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Rune implements an associative array of rune indexed by uint8.
type MapUint8Rune struct {
	length int
	root   nodeMapuint8rune
}

// NewMapUint8Rune returns a new map with keys of type uint8 and values of type rune
func NewMapUint8Rune() *MapUint8Rune {
	var r MapUint8Rune
	return &r
}

type nodeMapuint8rune struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8rune or rune)
}

// Return walking direction
func (c nodeMapuint8rune) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8rune) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8rune) children() *[2]nodeMapuint8rune {
	return (*[2]nodeMapuint8rune)(c.child)
}

func (c *nodeMapuint8rune) value() *rune {
	return (*rune)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8rune) find(key uint8) (crit uint, child, parent *nodeMapuint8rune) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Rune) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Rune) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Rune) SetP(key uint8, val *rune) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8rune{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Rune) Set(key uint8, val rune) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Rune) GetP(key uint8) (*rune, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*rune)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Rune) Get(key uint8) (rune, bool) {
	var v rune
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Rune) Length() int {
	return t.length
}

// func (c *nodeMapuint8rune) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8rune)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*rune)(c.child))
// 	}
// }

// IterUint8Rune The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Rune struct {
	t       *MapUint8Rune
	nodes   []*nodeMapuint8rune
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *rune // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Rune.
func (t *MapUint8Rune) Iterator() *IterUint8Rune {
	var i IterUint8Rune
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Rune) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Rune) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8rune, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Rune) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Rune) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Rune) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8String implements an associative array of string indexed by uint8.
type MapUint8String struct {
	length int
	root   nodeMapuint8string
}

// NewMapUint8String returns a new map with keys of type uint8 and values of type string
func NewMapUint8String() *MapUint8String {
	var r MapUint8String
	return &r
}

type nodeMapuint8string struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8string or string)
}

// Return walking direction
func (c nodeMapuint8string) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8string) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8string) children() *[2]nodeMapuint8string {
	return (*[2]nodeMapuint8string)(c.child)
}

func (c *nodeMapuint8string) value() *string {
	return (*string)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8string) find(key uint8) (crit uint, child, parent *nodeMapuint8string) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8String) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8String) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8String) SetP(key uint8, val *string) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8string{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8String) Set(key uint8, val string) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8String) GetP(key uint8) (*string, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*string)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8String) Get(key uint8) (string, bool) {
	var v string
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8String) Length() int {
	return t.length
}

// func (c *nodeMapuint8string) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8string)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*string)(c.child))
// 	}
// }

// IterUint8String The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8String struct {
	t       *MapUint8String
	nodes   []*nodeMapuint8string
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8   // Key found by last call to Next, Prev.
	Value   *string // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8String.
func (t *MapUint8String) Iterator() *IterUint8String {
	var i IterUint8String
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8String) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8String) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8string, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8String) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8String) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8String) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uint implements an associative array of uint indexed by uint8.
type MapUint8Uint struct {
	length int
	root   nodeMapuint8uint
}

// NewMapUint8Uint returns a new map with keys of type uint8 and values of type uint
func NewMapUint8Uint() *MapUint8Uint {
	var r MapUint8Uint
	return &r
}

type nodeMapuint8uint struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint or uint)
}

// Return walking direction
func (c nodeMapuint8uint) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint) children() *[2]nodeMapuint8uint {
	return (*[2]nodeMapuint8uint)(c.child)
}

func (c *nodeMapuint8uint) value() *uint {
	return (*uint)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uint) find(key uint8) (crit uint, child, parent *nodeMapuint8uint) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uint) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uint) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint) SetP(key uint8, val *uint) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint) Set(key uint8, val uint) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint) GetP(key uint8) (*uint, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint) Get(key uint8) (uint, bool) {
	var v uint
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint)(c.child))
// 	}
// }

// IterUint8Uint The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint struct {
	t       *MapUint8Uint
	nodes   []*nodeMapuint8uint
	lastDir int
	Found   bool  // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8 // Key found by last call to Next, Prev.
	Value   *uint // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint.
func (t *MapUint8Uint) Iterator() *IterUint8Uint {
	var i IterUint8Uint
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uint) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uint) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uint) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uint) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uint) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uint16 implements an associative array of uint16 indexed by uint8.
type MapUint8Uint16 struct {
	length int
	root   nodeMapuint8uint16
}

// NewMapUint8Uint16 returns a new map with keys of type uint8 and values of type uint16
func NewMapUint8Uint16() *MapUint8Uint16 {
	var r MapUint8Uint16
	return &r
}

type nodeMapuint8uint16 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint16 or uint16)
}

// Return walking direction
func (c nodeMapuint8uint16) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint16) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint16) children() *[2]nodeMapuint8uint16 {
	return (*[2]nodeMapuint8uint16)(c.child)
}

func (c *nodeMapuint8uint16) value() *uint16 {
	return (*uint16)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uint16) find(key uint8) (crit uint, child, parent *nodeMapuint8uint16) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uint16) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uint16) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint16) SetP(key uint8, val *uint16) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint16{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint16) Set(key uint8, val uint16) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint16) GetP(key uint8) (*uint16, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint16)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint16) Get(key uint8) (uint16, bool) {
	var v uint16
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint16) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint16) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint16)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint16)(c.child))
// 	}
// }

// IterUint8Uint16 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint16 struct {
	t       *MapUint8Uint16
	nodes   []*nodeMapuint8uint16
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8   // Key found by last call to Next, Prev.
	Value   *uint16 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint16.
func (t *MapUint8Uint16) Iterator() *IterUint8Uint16 {
	var i IterUint8Uint16
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uint16) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uint16) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint16, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uint16) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uint16) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uint16) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uint32 implements an associative array of uint32 indexed by uint8.
type MapUint8Uint32 struct {
	length int
	root   nodeMapuint8uint32
}

// NewMapUint8Uint32 returns a new map with keys of type uint8 and values of type uint32
func NewMapUint8Uint32() *MapUint8Uint32 {
	var r MapUint8Uint32
	return &r
}

type nodeMapuint8uint32 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint32 or uint32)
}

// Return walking direction
func (c nodeMapuint8uint32) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint32) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint32) children() *[2]nodeMapuint8uint32 {
	return (*[2]nodeMapuint8uint32)(c.child)
}

func (c *nodeMapuint8uint32) value() *uint32 {
	return (*uint32)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uint32) find(key uint8) (crit uint, child, parent *nodeMapuint8uint32) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uint32) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uint32) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint32) SetP(key uint8, val *uint32) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint32{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint32) Set(key uint8, val uint32) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint32) GetP(key uint8) (*uint32, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint32)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint32) Get(key uint8) (uint32, bool) {
	var v uint32
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint32) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint32) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint32)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint32)(c.child))
// 	}
// }

// IterUint8Uint32 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint32 struct {
	t       *MapUint8Uint32
	nodes   []*nodeMapuint8uint32
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8   // Key found by last call to Next, Prev.
	Value   *uint32 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint32.
func (t *MapUint8Uint32) Iterator() *IterUint8Uint32 {
	var i IterUint8Uint32
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uint32) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uint32) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint32, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uint32) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uint32) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uint32) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uint64 implements an associative array of uint64 indexed by uint8.
type MapUint8Uint64 struct {
	length int
	root   nodeMapuint8uint64
}

// NewMapUint8Uint64 returns a new map with keys of type uint8 and values of type uint64
func NewMapUint8Uint64() *MapUint8Uint64 {
	var r MapUint8Uint64
	return &r
}

type nodeMapuint8uint64 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint64 or uint64)
}

// Return walking direction
func (c nodeMapuint8uint64) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint64) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint64) children() *[2]nodeMapuint8uint64 {
	return (*[2]nodeMapuint8uint64)(c.child)
}

func (c *nodeMapuint8uint64) value() *uint64 {
	return (*uint64)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uint64) find(key uint8) (crit uint, child, parent *nodeMapuint8uint64) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uint64) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uint64) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint64) SetP(key uint8, val *uint64) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint64{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint64) Set(key uint8, val uint64) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint64) GetP(key uint8) (*uint64, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint64)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint64) Get(key uint8) (uint64, bool) {
	var v uint64
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint64) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint64) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint64)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint64)(c.child))
// 	}
// }

// IterUint8Uint64 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint64 struct {
	t       *MapUint8Uint64
	nodes   []*nodeMapuint8uint64
	lastDir int
	Found   bool    // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8   // Key found by last call to Next, Prev.
	Value   *uint64 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint64.
func (t *MapUint8Uint64) Iterator() *IterUint8Uint64 {
	var i IterUint8Uint64
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uint64) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uint64) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint64, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uint64) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uint64) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uint64) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uint8 implements an associative array of uint8 indexed by uint8.
type MapUint8Uint8 struct {
	length int
	root   nodeMapuint8uint8
}

// NewMapUint8Uint8 returns a new map with keys of type uint8 and values of type uint8
func NewMapUint8Uint8() *MapUint8Uint8 {
	var r MapUint8Uint8
	return &r
}

type nodeMapuint8uint8 struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uint8 or uint8)
}

// Return walking direction
func (c nodeMapuint8uint8) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uint8) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uint8) children() *[2]nodeMapuint8uint8 {
	return (*[2]nodeMapuint8uint8)(c.child)
}

func (c *nodeMapuint8uint8) value() *uint8 {
	return (*uint8)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uint8) find(key uint8) (crit uint, child, parent *nodeMapuint8uint8) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uint8) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uint8) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uint8) SetP(key uint8, val *uint8) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uint8{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uint8) Set(key uint8, val uint8) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uint8) GetP(key uint8) (*uint8, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uint8)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uint8) Get(key uint8) (uint8, bool) {
	var v uint8
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uint8) Length() int {
	return t.length
}

// func (c *nodeMapuint8uint8) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uint8)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uint8)(c.child))
// 	}
// }

// IterUint8Uint8 The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uint8 struct {
	t       *MapUint8Uint8
	nodes   []*nodeMapuint8uint8
	lastDir int
	Found   bool   // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8  // Key found by last call to Next, Prev.
	Value   *uint8 // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uint8.
func (t *MapUint8Uint8) Iterator() *IterUint8Uint8 {
	var i IterUint8Uint8
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uint8) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uint8) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uint8, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uint8) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uint8) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uint8) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}

// MapUint8Uintptr implements an associative array of uintptr indexed by uint8.
type MapUint8Uintptr struct {
	length int
	root   nodeMapuint8uintptr
}

// NewMapUint8Uintptr returns a new map with keys of type uint8 and values of type uintptr
func NewMapUint8Uintptr() *MapUint8Uintptr {
	var r MapUint8Uintptr
	return &r
}

type nodeMapuint8uintptr struct {
	key   uint8          // Key prefix up to critical bit
	crit  uint           // Position of critical bit  (LSB=0; ^uint(0) indicates leaf)
	child unsafe.Pointer // Pointer to children or value ([2]nodeMapuint8uintptr or uintptr)
}

// Return walking direction
func (c nodeMapuint8uintptr) dir(key uint8) int {
	return int((key >> c.crit) & 1)
}

// Return number of highest (first) bit that is different between child prefix and provided prefix.
// If there are no differences within the prefix, the returned value is c.crit.
func (c nodeMapuint8uintptr) findCrit(key uint8) uint {
	// Isolate differences in prefix
	key = ((key ^ c.key) >> (c.crit + 1)) << (c.crit + 1)
	// Zero bits from lowest to highest until there are no differences left
	var crit uint = c.crit
	for key != 0 {
		crit++
		key = key &^ (1 << crit)
	}
	return crit
}

func (c *nodeMapuint8uintptr) children() *[2]nodeMapuint8uintptr {
	return (*[2]nodeMapuint8uintptr)(c.child)
}

func (c *nodeMapuint8uintptr) value() *uintptr {
	return (*uintptr)(c.child)
}

// If a leaf with the same key is found, ^uint(0) and leaf node are returned.
// Otherwise, the critical bit and the first child with differing prefix are returned.
// As third value, the parent of the child is returned. If the child is the receiver of the method
// parent is nil.
func (c *nodeMapuint8uintptr) find(key uint8) (crit uint, child, parent *nodeMapuint8uintptr) {
	child = c
	crit = child.findCrit(key)
	// Keep going deeper until a leaf or an incompatible range is found.
	for child.crit != ^uint(0) && child.crit == crit {
		parent = child
		child = &(child.children())[child.dir(key)]
		crit = child.findCrit(key)
	}
	return
}

func (t *MapUint8Uintptr) transformKey(key uint8) uint8 {
	var mask uint8 = 1
	if mask-2 < 0 {
		mask = mask << 7
		for mask > 0 {
			mask = mask << 8
		}
		return key ^ mask
	}
	return key
}

// Rem removes the value associated with the specified key from the map.
func (t *MapUint8Uintptr) Rem(key uint8) {
	if t.length == 0 {
		return
	}
	key = t.transformKey(key)
	var crit, _, parent = t.root.find(key)
	if crit == ^uint(0) {
		if parent != nil {
			*parent = parent.children()[1-parent.dir(key)]
		}
		t.length--
	}
}

// SetP inserts or replaces the value associated with the specified key.
// The specified value pointer can be used to modify the value without using Set.
func (t *MapUint8Uintptr) SetP(key uint8, val *uintptr) {
	key = t.transformKey(key)
	// Make leaf node if tree is empty
	if t.length == 0 {
		t.length++
		t.root.key = key
		t.root.crit = ^uint(0)
		t.root.child = unsafe.Pointer(val)
		return
	}
	// Find node with longest shared prefix and critical bit
	var crit, n, _ = t.root.find(key)
	// Replace value if the node is a leaf with the same key
	if crit == ^uint(0) {
		n.child = unsafe.Pointer(val)
		return
	}
	// Make new child nodes for found node and new value
	var children = [2]nodeMapuint8uintptr{*n, *n}
	// Overwrite found node
	n.child = unsafe.Pointer(&children)
	n.crit = crit
	// Set one child to value
	var dir = n.dir(key)
	children[dir].key = key
	children[dir].crit = ^uint(0)
	children[dir].child = unsafe.Pointer(val)
	t.length++
}

// Set inserts or replaces the value associated with the specified key.
func (t *MapUint8Uintptr) Set(key uint8, val uintptr) {
	t.SetP(key, &val)
}

// Get returns the internal pointer to the value associated with the specified key and true if the key exists.
// Otherwise nil and false are returned. The pointer can be used to modify the value without using Set.
func (t *MapUint8Uintptr) GetP(key uint8) (*uintptr, bool) {
	key = t.transformKey(key)
	if t.length == 0 {
		return nil, false
	}
	// Find leaf node
	var crit, l, _ = t.root.find(key)
	if crit == ^uint(0) {
		return (*uintptr)(l.child), true
	}
	return nil, false
}

// Get returns the value associated with the specified key and true if the key exists.
// Otherwise 0 and false are returned. If a nil pointer was associated with the key,
// Get will panic (use GetP instead).
func (t *MapUint8Uintptr) Get(key uint8) (uintptr, bool) {
	var v uintptr
	var p, ok = t.GetP(key)
	if ok {
		v = *p
	}
	return v, ok
}

// Length returns the number of distinct keys in the multiset
func (t *MapUint8Uintptr) Length() int {
	return t.length
}

// func (c *nodeMapuint8uintptr) dbg(p string) {
// 	if c.crit != ^uint(0) {
// 		fmt.Printf(p+"Node: %08b %d\n", ((c.key>>c.crit)|1)<<c.crit, c.crit)
// 		p += "  "
// var children = (*[2]nodeMapuint8uintptr)(c.child)
// 		children[0].dbg(p)
// 		children[1].dbg(p)
// 	} else {
// fmt.Printf(p+"Leaf: %08b %d\n", c.key, *(*uintptr)(c.child))
// 	}
// }

// IterUint8Uintptr The iterator becomes invalid
// if a new value is inserted in the underlying map, until the Reset or Jump method is called.
type IterUint8Uintptr struct {
	t       *MapUint8Uintptr
	nodes   []*nodeMapuint8uintptr
	lastDir int
	Found   bool     // Initially false (also after calling Reset). Otherwise the return value of the last call to Next, Prev or Jump.
	Key     uint8    // Key found by last call to Next, Prev.
	Value   *uintptr // Pointer to value associated with key found by most last call to Next, Prev or Jump
}

// Iterator returns a new IterUint8Uintptr.
func (t *MapUint8Uintptr) Iterator() *IterUint8Uintptr {
	var i IterUint8Uintptr
	i.t = t
	i.Reset()
	return &i
}

// Seek initializes the iterator in a state that will be advanced to the specified key
// on the next call to Prev or Next. If the key does not exist, the next call to Prev or Next
// will advance the iterator to the next lower or higher key respectively (or the respective end of the map).
func (i *IterUint8Uintptr) Seek(key uint8) {
	key = i.t.transformKey(key)
	i.Reset()
	if i.t.length == 0 {
		return
	}
	var last = &i.t.root
	for last.crit != ^uint(0) && last.findCrit(key) == last.crit {
		i.nodes = append(i.nodes, last)
		last = &last.children()[last.dir(key)]
	}
	if last.crit != ^uint(0) || key != last.key {
		// Key not found.
		if len(i.nodes) == 1 {
			// Didn't get beyond root node. There are no keys this high or low. Simulate a Next or Prev call that reached the end
			i.lastDir = 1
			if key > last.key {
				i.lastDir = 0
			}
			i.nodes = i.nodes[0:0]
		}
	} else {
		// Key found
		i.nodes = append(i.nodes, last)
	}
}

// Reset restores the iterator to the initial state.
func (i *IterUint8Uintptr) Reset() {
	i.Found = false
	i.Key = i.t.transformKey(0)
	i.Value = nil
	i.lastDir = 2
	if i.nodes == nil {
		i.nodes = make([]*nodeMapuint8uintptr, 0, 64)
	} else {
		i.nodes = i.nodes[0:0]
	}
}

// Next advances the iterator to the next higher key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Next will set the iterator to the lowest key.
// The return value is true unless there is no next higher key to advance to.
func (i *IterUint8Uintptr) Next() bool {
	i.step(1)
	return i.Found
}

// Prev advances the iterator to the next lower key and populates the iterators public Fields.
// If the iterator is in the initial state, the first call to Prev will set the iterator to the highest key.
// The return value is true unless there is no next lower key to advance to.
func (i *IterUint8Uintptr) Prev() bool {
	i.step(0)
	return i.Found
}

func (i *IterUint8Uintptr) step(dir int) {
	// Check if iterator is at some node from a Seek, a leaf from step or at an end
	if len(i.nodes) == 0 {
		// Iterator is at end of map.
		if i.lastDir != dir && i.t.length > 0 {
			// Direction changed or not defined yet. Use root as starting point.
			i.lastDir = dir
			i.nodes = append(i.nodes, &i.t.root)
		} else {
			// End of map.
			i.Found = false
			return
		}
	} else if i.lastDir == 2 {
		// At node from Seek. Do nothing if this is a leaf. Otherwise take one step in the opposite direction of dir.
		if current := i.nodes[len(i.nodes)-1]; current.crit != ^uint(0) {
			i.nodes = append(i.nodes, &current.children()[dir])
		}
	} else {
		// Iterator is at some leaf from previous call to step. Comments describe behavior with dir == 1 (left to right).
		// Go up until we are at a left child. Then go to the sibling.
		for {
			// Check if there is a parent
			if len(i.nodes) == 1 {
				// No parent. Set end of map state.
				i.nodes = i.nodes[0:0]
				i.Found = false
				return
			}
			// If current node is left, replace it with the right one and stop going up.
			var rigthChild = &i.nodes[len(i.nodes)-2].children()[dir]
			if rigthChild != i.nodes[len(i.nodes)-1] {
				i.nodes[len(i.nodes)-1] = rigthChild
				break
			}
			// Go up
			i.nodes[len(i.nodes)-1] = nil // Help gc
			i.nodes = i.nodes[0 : len(i.nodes)-1]
		}
	}
	// Find next leaf by walking in correct direction. Comments describe behavior with dir == 1 (left to right).
	// Go left until next leaf is found.
	var current = i.nodes[len(i.nodes)-1]
	for current.crit != ^uint(0) {
		current = &current.children()[1-dir]
		i.nodes = append(i.nodes, current)
	}
	// Found leaf. Store data.
	i.Key = i.t.transformKey(current.key)
	i.Value = current.value()
	i.Found = true
}
